#include "qtscript_cocos2dx.hpp"
#include "QtScriptUtils.h"
#include "js_bindings/QtCocosScriptUtils.hpp"

namespace cocos2d {
QtScriptVec2::QtScriptVec2(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Vec2, false>(engine, className)
{
}

QtScriptVec2::QtScriptVec2(QScriptEngine *engine)
	: QtScriptVec2(engine, "Vec2")
{
}

void QtScriptVec2::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	QScriptValue inherit;
	auto ctor = RegisterT<Vec2, QtScriptVec2>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("angle", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptVec2::angle)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("dot", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptVec2::dot)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("forAngle", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptVec2::forAngle)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getIntersectPoint", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptVec2::getIntersectPoint)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("isLineIntersect", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptVec2::isLineIntersect)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("isLineOverlap", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptVec2::isLineOverlap)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("isLineParallel", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptVec2::isLineParallel)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("isSegmentIntersect", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptVec2::isSegmentIntersect)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("isSegmentOverlap", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptVec2::isSegmentOverlap)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

void QtScriptVec2::add(const cocos2d::Vec2& v)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		__o->add(v);
	}
}

cocos2d::Vec2 QtScriptVec2::added(const cocos2d::Vec2& v)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->operator+(v);
	}
	return cocos2d::Vec2();
}

void QtScriptVec2::clamp(const cocos2d::Vec2& min, const cocos2d::Vec2& max)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		__o->clamp(min, max);
	}
}

cocos2d::Vec2 QtScriptVec2::compOp(QScriptValue function)
{
	auto __e = this->engine();
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->compOp(!function.isFunction() ? std::function<float (float)>() : [=](float larg0) mutable -> float
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	return qscriptvalue_cast<float>(function.call(QScriptValue(), arguments));
});
	}
	return cocos2d::Vec2();
}

float QtScriptVec2::cross(const cocos2d::Vec2& other)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->cross(other);
	}
	return static_cast<float>(0);
}

bool QtScriptVec2::differs(const cocos2d::Vec2& v)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->operator!=(v);
	}
	return false;
}

float QtScriptVec2::distance(const cocos2d::Vec2& v)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->distance(v);
	}
	return static_cast<float>(0);
}

float QtScriptVec2::distanceSquared(const cocos2d::Vec2& v)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->distanceSquared(v);
	}
	return static_cast<float>(0);
}

cocos2d::Vec2 QtScriptVec2::divided(float s)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->operator/(s);
	}
	return cocos2d::Vec2();
}

float QtScriptVec2::dot(const cocos2d::Vec2& v)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->dot(v);
	}
	return static_cast<float>(0);
}

bool QtScriptVec2::equals(const cocos2d::Vec2& v)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->operator==(v);
	}
	return false;
}

bool QtScriptVec2::fuzzyEquals(const cocos2d::Vec2& target, float variance)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->fuzzyEquals(target, variance);
	}
	return false;
}

float QtScriptVec2::getAngle()
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->getAngle();
	}
	return static_cast<float>(0);
}

float QtScriptVec2::getAngle(const cocos2d::Vec2& other)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->getAngle(other);
	}
	return static_cast<float>(0);
}

cocos2d::Vec2 QtScriptVec2::getClampPoint(const cocos2d::Vec2& min_inclusive, const cocos2d::Vec2& max_inclusive)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->getClampPoint(min_inclusive, max_inclusive);
	}
	return cocos2d::Vec2();
}

float QtScriptVec2::getDistance(const cocos2d::Vec2& other)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->getDistance(other);
	}
	return static_cast<float>(0);
}

float QtScriptVec2::getDistanceSq(const cocos2d::Vec2& other)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->getDistanceSq(other);
	}
	return static_cast<float>(0);
}

float QtScriptVec2::getLength()
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->getLength();
	}
	return static_cast<float>(0);
}

float QtScriptVec2::getLengthSq()
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->getLengthSq();
	}
	return static_cast<float>(0);
}

cocos2d::Vec2 QtScriptVec2::getMidpoint(const cocos2d::Vec2& other)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->getMidpoint(other);
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptVec2::getNormalized()
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->getNormalized();
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptVec2::getPerp()
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->getPerp();
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptVec2::getRPerp()
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->getRPerp();
	}
	return cocos2d::Vec2();
}

bool QtScriptVec2::greaterThan(const cocos2d::Vec2& v)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->operator>(v);
	}
	return false;
}

bool QtScriptVec2::isOne()
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->isOne();
	}
	return false;
}

bool QtScriptVec2::isZero()
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->isZero();
	}
	return false;
}

float QtScriptVec2::length()
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->length();
	}
	return static_cast<float>(0);
}

float QtScriptVec2::lengthSquared()
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->lengthSquared();
	}
	return static_cast<float>(0);
}

cocos2d::Vec2 QtScriptVec2::lerp(const cocos2d::Vec2& other, float alpha)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->lerp(other, alpha);
	}
	return cocos2d::Vec2();
}

bool QtScriptVec2::lessThan(const cocos2d::Vec2& v)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->operator<(v);
	}
	return false;
}

void QtScriptVec2::mul(float s)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		__o->operator*=(s);
	}
}

cocos2d::Vec2 QtScriptVec2::multiplied(float s)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->operator*(s);
	}
	return cocos2d::Vec2();
}

void QtScriptVec2::negate()
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		__o->negate();
	}
}

cocos2d::Vec2 QtScriptVec2::negated()
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->operator-();
	}
	return cocos2d::Vec2();
}

void QtScriptVec2::normalize()
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		__o->normalize();
	}
}

cocos2d::Vec2 QtScriptVec2::project(const cocos2d::Vec2& other)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->project(other);
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptVec2::rotate(const cocos2d::Vec2& other)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->rotate(other);
	}
	return cocos2d::Vec2();
}

void QtScriptVec2::rotate(const cocos2d::Vec2& point, float angle)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		__o->rotate(point, angle);
	}
}

cocos2d::Vec2 QtScriptVec2::rotateByAngle(const cocos2d::Vec2& pivot, float angle)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->rotateByAngle(pivot, angle);
	}
	return cocos2d::Vec2();
}

void QtScriptVec2::scale(float scalar)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		__o->scale(scalar);
	}
}

void QtScriptVec2::set(const cocos2d::Vec2& v)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		__o->set(v);
	}
}

void QtScriptVec2::set(float xx, float yy)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		__o->set(xx, yy);
	}
}

void QtScriptVec2::setPoint(float xx, float yy)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		__o->setPoint(xx, yy);
	}
}

void QtScriptVec2::setZero()
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		__o->setZero();
	}
}

void QtScriptVec2::smooth(const cocos2d::Vec2& target, float elapsedTime, float responseTime)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		__o->smooth(target, elapsedTime, responseTime);
	}
}

void QtScriptVec2::sub(const cocos2d::Vec2& v)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		__o->operator-=(v);
	}
}

void QtScriptVec2::subtract(const cocos2d::Vec2& v)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		__o->subtract(v);
	}
}

cocos2d::Vec2 QtScriptVec2::subtracted(const cocos2d::Vec2& v)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->operator-(v);
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptVec2::unrotate(const cocos2d::Vec2& other)
{
	auto __o = this->thiz<Vec2 *>();
	if (__o)
	{
		return __o->unrotate(other);
	}
	return cocos2d::Vec2();
}

QScriptValue QtScriptVec2::angle(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(1));
			return __e->toScriptValue(Vec2::angle(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec2::angle");
	return __e->uncaughtException();
}

QScriptValue QtScriptVec2::dot(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(1));
			return __e->toScriptValue(Vec2::dot(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec2::dot");
	return __e->uncaughtException();
}

QScriptValue QtScriptVec2::forAngle(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			return __e->toScriptValue(Vec2::forAngle(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec2::forAngle");
	return __e->uncaughtException();
}

QScriptValue QtScriptVec2::getIntersectPoint(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(3));
			return __e->toScriptValue(Vec2::getIntersectPoint(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec2::getIntersectPoint");
	return __e->uncaughtException();
}

QScriptValue QtScriptVec2::isLineIntersect(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(3));
			return __e->toScriptValue(Vec2::isLineIntersect(arg0, arg1, arg2, arg3, nullptr, nullptr));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec2::isLineIntersect");
	return __e->uncaughtException();
}

QScriptValue QtScriptVec2::isLineOverlap(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(3));
			return __e->toScriptValue(Vec2::isLineOverlap(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec2::isLineOverlap");
	return __e->uncaughtException();
}

QScriptValue QtScriptVec2::isLineParallel(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(3));
			return __e->toScriptValue(Vec2::isLineParallel(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec2::isLineParallel");
	return __e->uncaughtException();
}

QScriptValue QtScriptVec2::isSegmentIntersect(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(3));
			return __e->toScriptValue(Vec2::isSegmentIntersect(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec2::isSegmentIntersect");
	return __e->uncaughtException();
}

QScriptValue QtScriptVec2::isSegmentOverlap(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 6))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(3));
			return __e->toScriptValue(Vec2::isSegmentOverlap(arg0, arg1, arg2, arg3));
		}
		case 5:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(3));
			auto arg4 = qscriptvalue_cast<cocos2d::Vec2*>(context->argument(4));
			return __e->toScriptValue(Vec2::isSegmentOverlap(arg0, arg1, arg2, arg3, arg4));
		}
		case 6:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(3));
			auto arg4 = qscriptvalue_cast<cocos2d::Vec2*>(context->argument(4));
			auto arg5 = qscriptvalue_cast<cocos2d::Vec2*>(context->argument(5));
			return __e->toScriptValue(Vec2::isSegmentOverlap(arg0, arg1, arg2, arg3, arg4, arg5));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec2::isSegmentOverlap");
	return __e->uncaughtException();
}

int QtScriptVec2::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptVec2::constructorArgumentCountMax() const
{
	return 2;
}

bool QtScriptVec2::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(0));
			out = Vec2(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			out = Vec2(arg0, arg1);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec2 constructor");
	}
	return ok;
}

float QtScriptVec2::_public_field_get_x() const
{
	auto object = thiz<Vec2 *>();
	if (object)
	{
		return object->x;
	}
	return static_cast<float>(0);
}

void QtScriptVec2::_public_field_set_x(float value)
{
	auto object = thiz<Vec2 *>();
	if (object)
	{
		object->x = value;
	}
}

float QtScriptVec2::_public_field_get_y() const
{
	auto object = thiz<Vec2 *>();
	if (object)
	{
		return object->y;
	}
	return static_cast<float>(0);
}

void QtScriptVec2::_public_field_set_y(float value)
{
	auto object = thiz<Vec2 *>();
	if (object)
	{
		object->y = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptVec3::QtScriptVec3(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Vec3, false>(engine, className)
{
}

QtScriptVec3::QtScriptVec3(QScriptEngine *engine)
	: QtScriptVec3(engine, "Vec3")
{
}

void QtScriptVec3::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	QScriptValue inherit;
	auto ctor = RegisterT<Vec3, QtScriptVec3>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("angle", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptVec3::angle)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("dot", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptVec3::dot)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("fromColor", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptVec3::fromColor)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

void QtScriptVec3::add(const cocos2d::Vec3& v)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		__o->add(v);
	}
}

cocos2d::Vec3 QtScriptVec3::added(const cocos2d::Vec3& v)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->operator+(v);
	}
	return cocos2d::Vec3();
}

void QtScriptVec3::clamp(const cocos2d::Vec3& min, const cocos2d::Vec3& max)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		__o->clamp(min, max);
	}
}

void QtScriptVec3::cross(const cocos2d::Vec3& v)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		__o->cross(v);
	}
}

bool QtScriptVec3::differs(const cocos2d::Vec3& v)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->operator!=(v);
	}
	return false;
}

float QtScriptVec3::distance(const cocos2d::Vec3& v)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->distance(v);
	}
	return static_cast<float>(0);
}

float QtScriptVec3::distanceSquared(const cocos2d::Vec3& v)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->distanceSquared(v);
	}
	return static_cast<float>(0);
}

cocos2d::Vec3 QtScriptVec3::divided(float s)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->operator/(s);
	}
	return cocos2d::Vec3();
}

float QtScriptVec3::dot(const cocos2d::Vec3& v)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->dot(v);
	}
	return static_cast<float>(0);
}

bool QtScriptVec3::equals(const cocos2d::Vec3& v)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->operator==(v);
	}
	return false;
}

cocos2d::Vec3 QtScriptVec3::getNormalized()
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->getNormalized();
	}
	return cocos2d::Vec3();
}

bool QtScriptVec3::greaterThan(const cocos2d::Vec3& rhs)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->operator>(rhs);
	}
	return false;
}

bool QtScriptVec3::isOne()
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->isOne();
	}
	return false;
}

bool QtScriptVec3::isZero()
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->isZero();
	}
	return false;
}

float QtScriptVec3::length()
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->length();
	}
	return static_cast<float>(0);
}

float QtScriptVec3::lengthSquared()
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->lengthSquared();
	}
	return static_cast<float>(0);
}

cocos2d::Vec3 QtScriptVec3::lerp(const cocos2d::Vec3& target, float alpha)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->lerp(target, alpha);
	}
	return cocos2d::Vec3();
}

bool QtScriptVec3::lessThan(const cocos2d::Vec3& rhs)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->operator<(rhs);
	}
	return false;
}

void QtScriptVec3::mul(float s)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		__o->operator*=(s);
	}
}

cocos2d::Vec3 QtScriptVec3::multiplied(float s)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->operator*(s);
	}
	return cocos2d::Vec3();
}

void QtScriptVec3::negate()
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		__o->negate();
	}
}

cocos2d::Vec3 QtScriptVec3::negated()
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->operator-();
	}
	return cocos2d::Vec3();
}

void QtScriptVec3::normalize()
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		__o->normalize();
	}
}

void QtScriptVec3::scale(float scalar)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		__o->scale(scalar);
	}
}

void QtScriptVec3::set(const cocos2d::Vec3& v)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		__o->set(v);
	}
}

void QtScriptVec3::set(const cocos2d::Vec3& p1, const cocos2d::Vec3& p2)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		__o->set(p1, p2);
	}
}

void QtScriptVec3::set(float xx, float yy, float zz)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		__o->set(xx, yy, zz);
	}
}

void QtScriptVec3::setZero()
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		__o->setZero();
	}
}

void QtScriptVec3::smooth(const cocos2d::Vec3& target, float elapsedTime, float responseTime)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		__o->smooth(target, elapsedTime, responseTime);
	}
}

void QtScriptVec3::sub(const cocos2d::Vec3& v)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		__o->operator-=(v);
	}
}

void QtScriptVec3::subtract(const cocos2d::Vec3& v)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		__o->subtract(v);
	}
}

cocos2d::Vec3 QtScriptVec3::subtracted(const cocos2d::Vec3& v)
{
	auto __o = this->thiz<Vec3 *>();
	if (__o)
	{
		return __o->operator-(v);
	}
	return cocos2d::Vec3();
}

QScriptValue QtScriptVec3::angle(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(1));
			return __e->toScriptValue(Vec3::angle(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec3::angle");
	return __e->uncaughtException();
}

QScriptValue QtScriptVec3::dot(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(1));
			return __e->toScriptValue(Vec3::dot(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec3::dot");
	return __e->uncaughtException();
}

QScriptValue QtScriptVec3::fromColor(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<unsigned int>(context->argument(0));
			return __e->toScriptValue(Vec3::fromColor(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec3::fromColor");
	return __e->uncaughtException();
}

int QtScriptVec3::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptVec3::constructorArgumentCountMax() const
{
	return 3;
}

bool QtScriptVec3::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(0));
			out = Vec3(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(1));
			out = Vec3(arg0, arg1);
			ok = true;
			break;
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			out = Vec3(arg0, arg1, arg2);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec3 constructor");
	}
	return ok;
}

float QtScriptVec3::_public_field_get_x() const
{
	auto object = thiz<Vec3 *>();
	if (object)
	{
		return object->x;
	}
	return static_cast<float>(0);
}

void QtScriptVec3::_public_field_set_x(float value)
{
	auto object = thiz<Vec3 *>();
	if (object)
	{
		object->x = value;
	}
}

float QtScriptVec3::_public_field_get_y() const
{
	auto object = thiz<Vec3 *>();
	if (object)
	{
		return object->y;
	}
	return static_cast<float>(0);
}

void QtScriptVec3::_public_field_set_y(float value)
{
	auto object = thiz<Vec3 *>();
	if (object)
	{
		object->y = value;
	}
}

float QtScriptVec3::_public_field_get_z() const
{
	auto object = thiz<Vec3 *>();
	if (object)
	{
		return object->z;
	}
	return static_cast<float>(0);
}

void QtScriptVec3::_public_field_set_z(float value)
{
	auto object = thiz<Vec3 *>();
	if (object)
	{
		object->z = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptVec4::QtScriptVec4(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Vec4, false>(engine, className)
{
}

QtScriptVec4::QtScriptVec4(QScriptEngine *engine)
	: QtScriptVec4(engine, "Vec4")
{
}

void QtScriptVec4::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	QScriptValue inherit;
	auto ctor = RegisterT<Vec4, QtScriptVec4>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("angle", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptVec4::angle)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("dot", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptVec4::dot)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("fromColor", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptVec4::fromColor)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

void QtScriptVec4::add(const cocos2d::Vec4& v)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		__o->add(v);
	}
}

cocos2d::Vec4 QtScriptVec4::added(const cocos2d::Vec4& v)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->operator+(v);
	}
	return cocos2d::Vec4();
}

void QtScriptVec4::clamp(const cocos2d::Vec4& min, const cocos2d::Vec4& max)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		__o->clamp(min, max);
	}
}

bool QtScriptVec4::differs(const cocos2d::Vec4& v)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->operator!=(v);
	}
	return false;
}

float QtScriptVec4::distance(const cocos2d::Vec4& v)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->distance(v);
	}
	return static_cast<float>(0);
}

float QtScriptVec4::distanceSquared(const cocos2d::Vec4& v)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->distanceSquared(v);
	}
	return static_cast<float>(0);
}

cocos2d::Vec4 QtScriptVec4::divided(float s)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->operator/(s);
	}
	return cocos2d::Vec4();
}

float QtScriptVec4::dot(const cocos2d::Vec4& v)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->dot(v);
	}
	return static_cast<float>(0);
}

bool QtScriptVec4::equals(const cocos2d::Vec4& v)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->operator==(v);
	}
	return false;
}

cocos2d::Vec4 QtScriptVec4::getNormalized()
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->getNormalized();
	}
	return cocos2d::Vec4();
}

bool QtScriptVec4::isOne()
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->isOne();
	}
	return false;
}

bool QtScriptVec4::isZero()
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->isZero();
	}
	return false;
}

float QtScriptVec4::length()
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->length();
	}
	return static_cast<float>(0);
}

float QtScriptVec4::lengthSquared()
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->lengthSquared();
	}
	return static_cast<float>(0);
}

bool QtScriptVec4::lessThan(const cocos2d::Vec4& v)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->operator<(v);
	}
	return false;
}

void QtScriptVec4::mul(float s)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		__o->operator*=(s);
	}
}

cocos2d::Vec4 QtScriptVec4::multiplied(float s)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->operator*(s);
	}
	return cocos2d::Vec4();
}

void QtScriptVec4::negate()
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		__o->negate();
	}
}

cocos2d::Vec4 QtScriptVec4::negated()
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->operator-();
	}
	return cocos2d::Vec4();
}

void QtScriptVec4::normalize()
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		__o->normalize();
	}
}

void QtScriptVec4::scale(float scalar)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		__o->scale(scalar);
	}
}

void QtScriptVec4::set(const cocos2d::Vec4& v)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		__o->set(v);
	}
}

void QtScriptVec4::set(const cocos2d::Vec4& p1, const cocos2d::Vec4& p2)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		__o->set(p1, p2);
	}
}

void QtScriptVec4::set(float xx, float yy, float zz, float ww)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		__o->set(xx, yy, zz, ww);
	}
}

void QtScriptVec4::sub(const cocos2d::Vec4& v)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		__o->operator-=(v);
	}
}

void QtScriptVec4::subtract(const cocos2d::Vec4& v)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		__o->subtract(v);
	}
}

cocos2d::Vec4 QtScriptVec4::subtracted(const cocos2d::Vec4& v)
{
	auto __o = this->thiz<Vec4 *>();
	if (__o)
	{
		return __o->operator-(v);
	}
	return cocos2d::Vec4();
}

QScriptValue QtScriptVec4::angle(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec4>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec4>(context->argument(1));
			return __e->toScriptValue(Vec4::angle(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec4::angle");
	return __e->uncaughtException();
}

QScriptValue QtScriptVec4::dot(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec4>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec4>(context->argument(1));
			return __e->toScriptValue(Vec4::dot(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec4::dot");
	return __e->uncaughtException();
}

QScriptValue QtScriptVec4::fromColor(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<unsigned int>(context->argument(0));
			return __e->toScriptValue(Vec4::fromColor(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec4::fromColor");
	return __e->uncaughtException();
}

int QtScriptVec4::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptVec4::constructorArgumentCountMax() const
{
	return 4;
}

bool QtScriptVec4::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec4>(context->argument(0));
			out = Vec4(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec4>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec4>(context->argument(1));
			out = Vec4(arg0, arg1);
			ok = true;
			break;
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			out = Vec4(arg0, arg1, arg2, arg3);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Vec4 constructor");
	}
	return ok;
}

float QtScriptVec4::_public_field_get_w() const
{
	auto object = thiz<Vec4 *>();
	if (object)
	{
		return object->w;
	}
	return static_cast<float>(0);
}

void QtScriptVec4::_public_field_set_w(float value)
{
	auto object = thiz<Vec4 *>();
	if (object)
	{
		object->w = value;
	}
}

float QtScriptVec4::_public_field_get_x() const
{
	auto object = thiz<Vec4 *>();
	if (object)
	{
		return object->x;
	}
	return static_cast<float>(0);
}

void QtScriptVec4::_public_field_set_x(float value)
{
	auto object = thiz<Vec4 *>();
	if (object)
	{
		object->x = value;
	}
}

float QtScriptVec4::_public_field_get_y() const
{
	auto object = thiz<Vec4 *>();
	if (object)
	{
		return object->y;
	}
	return static_cast<float>(0);
}

void QtScriptVec4::_public_field_set_y(float value)
{
	auto object = thiz<Vec4 *>();
	if (object)
	{
		object->y = value;
	}
}

float QtScriptVec4::_public_field_get_z() const
{
	auto object = thiz<Vec4 *>();
	if (object)
	{
		return object->z;
	}
	return static_cast<float>(0);
}

void QtScriptVec4::_public_field_set_z(float value)
{
	auto object = thiz<Vec4 *>();
	if (object)
	{
		object->z = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptMat4::QtScriptMat4(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Mat4, false>(engine, className)
{
}

QtScriptMat4::QtScriptMat4(QScriptEngine *engine)
	: QtScriptMat4(engine, "Mat4")
{
}

void QtScriptMat4::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<Mat4, QtScriptMat4>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

void QtScriptMat4::add(float scalar)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->add(scalar);
	}
}

cocos2d::Mat4 QtScriptMat4::added(const cocos2d::Mat4& mat)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		return __o->operator+(mat);
	}
	return cocos2d::Mat4();
}

float QtScriptMat4::determinant()
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		return __o->determinant();
	}
	return static_cast<float>(0);
}

cocos2d::Mat4 QtScriptMat4::getInversed()
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		return __o->getInversed();
	}
	return cocos2d::Mat4();
}

cocos2d::Mat4 QtScriptMat4::getNegated()
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		return __o->getNegated();
	}
	return cocos2d::Mat4();
}

cocos2d::Mat4 QtScriptMat4::getTransposed()
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		return __o->getTransposed();
	}
	return cocos2d::Mat4();
}

bool QtScriptMat4::inverse()
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		return __o->inverse();
	}
	return false;
}

bool QtScriptMat4::isIdentity()
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		return __o->isIdentity();
	}
	return false;
}

void QtScriptMat4::mul(const cocos2d::Mat4& mat)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->operator*=(mat);
	}
}

cocos2d::Mat4 QtScriptMat4::multiplied(const cocos2d::Mat4& mat)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		return __o->operator*(mat);
	}
	return cocos2d::Mat4();
}

void QtScriptMat4::multiply(float scalar)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->multiply(scalar);
	}
}

void QtScriptMat4::negate()
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->negate();
	}
}

cocos2d::Mat4 QtScriptMat4::negated()
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		return __o->operator-();
	}
	return cocos2d::Mat4();
}

void QtScriptMat4::rotate(const cocos2d::Quaternion& q)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->rotate(q);
	}
}

void QtScriptMat4::rotateX(float angle)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->rotateX(angle);
	}
}

void QtScriptMat4::rotateY(float angle)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->rotateY(angle);
	}
}

void QtScriptMat4::rotateZ(float angle)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->rotateZ(angle);
	}
}

void QtScriptMat4::scale(float value)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->scale(value);
	}
}

void QtScriptMat4::scale(float xScale, float yScale, float zScale)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->scale(xScale, yScale, zScale);
	}
}

void QtScriptMat4::set(const cocos2d::Mat4& mat)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->set(mat);
	}
}

void QtScriptMat4::set(float m11, float m12, float m13, float m14, float m21, float m22, float m23, float m24, float m31, float m32, float m33, float m34, float m41, float m42, float m43, float m44)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->set(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44);
	}
}

void QtScriptMat4::setIdentity()
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->setIdentity();
	}
}

void QtScriptMat4::setZero()
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->setZero();
	}
}

void QtScriptMat4::sub(const cocos2d::Mat4& mat)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->operator-=(mat);
	}
}

void QtScriptMat4::subtract(const cocos2d::Mat4& mat)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->subtract(mat);
	}
}

cocos2d::Mat4 QtScriptMat4::subtracted(const cocos2d::Mat4& mat)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		return __o->operator-(mat);
	}
	return cocos2d::Mat4();
}

void QtScriptMat4::translate(const cocos2d::Vec3& t)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->translate(t);
	}
}

void QtScriptMat4::translate(float x, float y, float z)
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->translate(x, y, z);
	}
}

void QtScriptMat4::transpose()
{
	auto __o = this->thiz<Mat4 *>();
	if (__o)
	{
		__o->transpose();
	}
}

int QtScriptMat4::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMat4::constructorArgumentCountMax() const
{
	return 16;
}

bool QtScriptMat4::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Mat4>(context->argument(0));
			out = Mat4(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			break;
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			break;
		}
		case 5:
		{
			break;
		}
		case 6:
		{
			break;
		}
		case 7:
		{
			break;
		}
		case 8:
		{
			break;
		}
		case 9:
		{
			break;
		}
		case 10:
		{
			break;
		}
		case 11:
		{
			break;
		}
		case 12:
		{
			break;
		}
		case 13:
		{
			break;
		}
		case 14:
		{
			break;
		}
		case 15:
		{
			break;
		}
		case 16:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			auto arg4 = qscriptvalue_cast<float>(context->argument(4));
			auto arg5 = qscriptvalue_cast<float>(context->argument(5));
			auto arg6 = qscriptvalue_cast<float>(context->argument(6));
			auto arg7 = qscriptvalue_cast<float>(context->argument(7));
			auto arg8 = qscriptvalue_cast<float>(context->argument(8));
			auto arg9 = qscriptvalue_cast<float>(context->argument(9));
			auto arg10 = qscriptvalue_cast<float>(context->argument(10));
			auto arg11 = qscriptvalue_cast<float>(context->argument(11));
			auto arg12 = qscriptvalue_cast<float>(context->argument(12));
			auto arg13 = qscriptvalue_cast<float>(context->argument(13));
			auto arg14 = qscriptvalue_cast<float>(context->argument(14));
			auto arg15 = qscriptvalue_cast<float>(context->argument(15));
			out = Mat4(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Mat4 constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptQuaternion::QtScriptQuaternion(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Quaternion, false>(engine, className)
{
}

QtScriptQuaternion::QtScriptQuaternion(QScriptEngine *engine)
	: QtScriptQuaternion(engine, "Quaternion")
{
}

void QtScriptQuaternion::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	QScriptValue inherit;
	auto ctor = RegisterT<Quaternion, QtScriptQuaternion>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("identity", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptQuaternion::identity)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("squad", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptQuaternion::squad)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("zero", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptQuaternion::zero)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

void QtScriptQuaternion::conjugate()
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		__o->conjugate();
	}
}

cocos2d::Quaternion QtScriptQuaternion::getConjugated()
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		return __o->getConjugated();
	}
	return cocos2d::Quaternion();
}

cocos2d::Quaternion QtScriptQuaternion::getInversed()
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		return __o->getInversed();
	}
	return cocos2d::Quaternion();
}

cocos2d::Quaternion QtScriptQuaternion::getNormalized()
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		return __o->getNormalized();
	}
	return cocos2d::Quaternion();
}

bool QtScriptQuaternion::inverse()
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		return __o->inverse();
	}
	return false;
}

bool QtScriptQuaternion::isIdentity()
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		return __o->isIdentity();
	}
	return false;
}

bool QtScriptQuaternion::isZero()
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		return __o->isZero();
	}
	return false;
}

void QtScriptQuaternion::mul(const cocos2d::Quaternion& q)
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		__o->operator*=(q);
	}
}

cocos2d::Quaternion QtScriptQuaternion::multiplied(const cocos2d::Quaternion& q)
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		return __o->operator*(q);
	}
	return cocos2d::Quaternion();
}

void QtScriptQuaternion::multiply(const cocos2d::Quaternion& q)
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		__o->multiply(q);
	}
}

void QtScriptQuaternion::normalize()
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		__o->normalize();
	}
}

void QtScriptQuaternion::set(const cocos2d::Mat4& m)
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		__o->set(m);
	}
}

void QtScriptQuaternion::set(const cocos2d::Vec3& axis, float angle)
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		__o->set(axis, angle);
	}
}

void QtScriptQuaternion::set(float xx, float yy, float zz, float ww)
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		__o->set(xx, yy, zz, ww);
	}
}

void QtScriptQuaternion::setIdentity()
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		__o->setIdentity();
	}
}

float QtScriptQuaternion::toAxisAngle(cocos2d::Vec3* e)
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		return __o->toAxisAngle(e);
	}
	return static_cast<float>(0);
}

cocos2d::Vec3 QtScriptQuaternion::vec3Multiplied(const cocos2d::Vec3& v)
{
	auto __o = this->thiz<Quaternion *>();
	if (__o)
	{
		return __o->operator*(v);
	}
	return cocos2d::Vec3();
}

QScriptValue QtScriptQuaternion::identity(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Quaternion::identity());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Quaternion::identity");
	return __e->uncaughtException();
}

QScriptValue QtScriptQuaternion::squad(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 6, 6))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 6:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Quaternion>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Quaternion>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Quaternion>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Quaternion>(context->argument(3));
			auto arg4 = qscriptvalue_cast<float>(context->argument(4));
			auto arg5 = qscriptvalue_cast<cocos2d::Quaternion*>(context->argument(5));
			Quaternion::squad(arg0, arg1, arg2, arg3, arg4, arg5);
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Quaternion::squad");
	return __e->uncaughtException();
}

QScriptValue QtScriptQuaternion::zero(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Quaternion::zero());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Quaternion::zero");
	return __e->uncaughtException();
}

int QtScriptQuaternion::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptQuaternion::constructorArgumentCountMax() const
{
	return 4;
}

bool QtScriptQuaternion::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Mat4>(context->argument(0));
			out = Quaternion(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			out = Quaternion(arg0, arg1);
			ok = true;
			break;
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			out = Quaternion(arg0, arg1, arg2, arg3);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Quaternion constructor");
	}
	return ok;
}

float QtScriptQuaternion::_public_field_get_w() const
{
	auto object = thiz<Quaternion *>();
	if (object)
	{
		return object->w;
	}
	return static_cast<float>(0);
}

void QtScriptQuaternion::_public_field_set_w(float value)
{
	auto object = thiz<Quaternion *>();
	if (object)
	{
		object->w = value;
	}
}

float QtScriptQuaternion::_public_field_get_x() const
{
	auto object = thiz<Quaternion *>();
	if (object)
	{
		return object->x;
	}
	return static_cast<float>(0);
}

void QtScriptQuaternion::_public_field_set_x(float value)
{
	auto object = thiz<Quaternion *>();
	if (object)
	{
		object->x = value;
	}
}

float QtScriptQuaternion::_public_field_get_y() const
{
	auto object = thiz<Quaternion *>();
	if (object)
	{
		return object->y;
	}
	return static_cast<float>(0);
}

void QtScriptQuaternion::_public_field_set_y(float value)
{
	auto object = thiz<Quaternion *>();
	if (object)
	{
		object->y = value;
	}
}

float QtScriptQuaternion::_public_field_get_z() const
{
	auto object = thiz<Quaternion *>();
	if (object)
	{
		return object->z;
	}
	return static_cast<float>(0);
}

void QtScriptQuaternion::_public_field_set_z(float value)
{
	auto object = thiz<Quaternion *>();
	if (object)
	{
		object->z = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptSize::QtScriptSize(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Size, false>(engine, className)
{
}

QtScriptSize::QtScriptSize(QScriptEngine *engine)
	: QtScriptSize(engine, "Size")
{
}

void QtScriptSize::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<Size, QtScriptSize>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

cocos2d::Size QtScriptSize::added(const cocos2d::Size& right)
{
	auto __o = this->thiz<Size *>();
	if (__o)
	{
		return __o->operator+(right);
	}
	return cocos2d::Size();
}

cocos2d::Size QtScriptSize::divided(float a)
{
	auto __o = this->thiz<Size *>();
	if (__o)
	{
		return __o->operator/(a);
	}
	return cocos2d::Size();
}

bool QtScriptSize::equals(const cocos2d::Size& target)
{
	auto __o = this->thiz<Size *>();
	if (__o)
	{
		return __o->equals(target);
	}
	return false;
}

cocos2d::Size QtScriptSize::multiplied(float a)
{
	auto __o = this->thiz<Size *>();
	if (__o)
	{
		return __o->operator*(a);
	}
	return cocos2d::Size();
}

void QtScriptSize::set(const cocos2d::Size& other)
{
	auto __o = this->thiz<Size *>();
	if (__o)
	{
		__o->operator=(other);
	}
}

void QtScriptSize::setSize(float width, float height)
{
	auto __o = this->thiz<Size *>();
	if (__o)
	{
		__o->setSize(width, height);
	}
}

cocos2d::Size QtScriptSize::subtracted(const cocos2d::Size& right)
{
	auto __o = this->thiz<Size *>();
	if (__o)
	{
		return __o->operator-(right);
	}
	return cocos2d::Size();
}

cocos2d::Vec2 QtScriptSize::toVec2()
{
	auto __o = this->thiz<Size *>();
	if (__o)
	{
		return __o->operator Vec2();
	}
	return cocos2d::Vec2();
}

int QtScriptSize::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSize::constructorArgumentCountMax() const
{
	return 2;
}

bool QtScriptSize::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Size>(context->argument(0));
			out = Size(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			out = Size(arg0, arg1);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Size constructor");
	}
	return ok;
}

float QtScriptSize::_public_field_get_height() const
{
	auto object = thiz<Size *>();
	if (object)
	{
		return object->height;
	}
	return static_cast<float>(0);
}

void QtScriptSize::_public_field_set_height(float value)
{
	auto object = thiz<Size *>();
	if (object)
	{
		object->height = value;
	}
}

float QtScriptSize::_public_field_get_width() const
{
	auto object = thiz<Size *>();
	if (object)
	{
		return object->width;
	}
	return static_cast<float>(0);
}

void QtScriptSize::_public_field_set_width(float value)
{
	auto object = thiz<Size *>();
	if (object)
	{
		object->width = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptRect::QtScriptRect(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Rect, false>(engine, className)
{
}

QtScriptRect::QtScriptRect(QScriptEngine *engine)
	: QtScriptRect(engine, "Rect")
{
}

void QtScriptRect::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<Rect, QtScriptRect>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

bool QtScriptRect::containsPoint(const cocos2d::Vec2& point)
{
	auto __o = this->thiz<Rect *>();
	if (__o)
	{
		return __o->containsPoint(point);
	}
	return false;
}

bool QtScriptRect::equals(const cocos2d::Rect& rect)
{
	auto __o = this->thiz<Rect *>();
	if (__o)
	{
		return __o->equals(rect);
	}
	return false;
}

float QtScriptRect::getMaxX()
{
	auto __o = this->thiz<Rect *>();
	if (__o)
	{
		return __o->getMaxX();
	}
	return static_cast<float>(0);
}

float QtScriptRect::getMaxY()
{
	auto __o = this->thiz<Rect *>();
	if (__o)
	{
		return __o->getMaxY();
	}
	return static_cast<float>(0);
}

float QtScriptRect::getMidX()
{
	auto __o = this->thiz<Rect *>();
	if (__o)
	{
		return __o->getMidX();
	}
	return static_cast<float>(0);
}

float QtScriptRect::getMidY()
{
	auto __o = this->thiz<Rect *>();
	if (__o)
	{
		return __o->getMidY();
	}
	return static_cast<float>(0);
}

float QtScriptRect::getMinX()
{
	auto __o = this->thiz<Rect *>();
	if (__o)
	{
		return __o->getMinX();
	}
	return static_cast<float>(0);
}

float QtScriptRect::getMinY()
{
	auto __o = this->thiz<Rect *>();
	if (__o)
	{
		return __o->getMinY();
	}
	return static_cast<float>(0);
}

bool QtScriptRect::intersectsCircle(const cocos2d::Vec2& center, float radius)
{
	auto __o = this->thiz<Rect *>();
	if (__o)
	{
		return __o->intersectsCircle(center, radius);
	}
	return false;
}

bool QtScriptRect::intersectsRect(const cocos2d::Rect& rect)
{
	auto __o = this->thiz<Rect *>();
	if (__o)
	{
		return __o->intersectsRect(rect);
	}
	return false;
}

void QtScriptRect::merge(const cocos2d::Rect& rect)
{
	auto __o = this->thiz<Rect *>();
	if (__o)
	{
		__o->merge(rect);
	}
}

void QtScriptRect::set(const cocos2d::Rect& other)
{
	auto __o = this->thiz<Rect *>();
	if (__o)
	{
		__o->operator=(other);
	}
}

void QtScriptRect::setRect(float x, float y, float width, float height)
{
	auto __o = this->thiz<Rect *>();
	if (__o)
	{
		__o->setRect(x, y, width, height);
	}
}

cocos2d::Rect QtScriptRect::unionWithRect(const cocos2d::Rect& rect)
{
	auto __o = this->thiz<Rect *>();
	if (__o)
	{
		return __o->unionWithRect(rect);
	}
	return cocos2d::Rect();
}

int QtScriptRect::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptRect::constructorArgumentCountMax() const
{
	return 4;
}

bool QtScriptRect::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Rect>(context->argument(0));
			out = Rect(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			out = Rect(arg0, arg1);
			ok = true;
			break;
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			out = Rect(arg0, arg1, arg2, arg3);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Rect constructor");
	}
	return ok;
}

cocos2d::Vec2 QtScriptRect::_public_field_get_origin() const
{
	auto object = thiz<Rect *>();
	if (object)
	{
		return object->origin;
	}
	return cocos2d::Vec2();
}

void QtScriptRect::_public_field_set_origin(const cocos2d::Vec2& value)
{
	auto object = thiz<Rect *>();
	if (object)
	{
		object->origin = value;
	}
}

cocos2d::Size QtScriptRect::_public_field_get_size() const
{
	auto object = thiz<Rect *>();
	if (object)
	{
		return object->size;
	}
	return cocos2d::Size();
}

void QtScriptRect::_public_field_set_size(const cocos2d::Size& value)
{
	auto object = thiz<Rect *>();
	if (object)
	{
		object->size = value;
	}
}

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptSamplerDescriptor::QtScriptSamplerDescriptor(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<SamplerDescriptor, false>(engine, className)
{
}

QtScriptSamplerDescriptor::QtScriptSamplerDescriptor(QScriptEngine *engine)
	: QtScriptSamplerDescriptor(engine, "SamplerDescriptor")
{
}

void QtScriptSamplerDescriptor::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<SamplerDescriptor, QtScriptSamplerDescriptor>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptSamplerDescriptor::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSamplerDescriptor::constructorArgumentCountMax() const
{
	return 4;
}

bool QtScriptSamplerDescriptor::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			break;
		}
		case 2:
		{
			break;
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			auto tmp_0 = qscriptvalue_cast<int>(context->argument(0));
			auto arg0 = cocos2d::backend::SamplerFilter(tmp_0);
			auto tmp_1 = qscriptvalue_cast<int>(context->argument(1));
			auto arg1 = cocos2d::backend::SamplerFilter(tmp_1);
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::backend::SamplerAddressMode(tmp_2);
			auto tmp_3 = qscriptvalue_cast<int>(context->argument(3));
			auto arg3 = cocos2d::backend::SamplerAddressMode(tmp_3);
			out = SamplerDescriptor(arg0, arg1, arg2, arg3);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::backend::SamplerDescriptor constructor");
	}
	return ok;
}

int QtScriptSamplerDescriptor::_public_field_get_magFilter() const
{
	auto object = thiz<SamplerDescriptor *>();
	if (object)
	{
		return int(object->magFilter);
	}
	return static_cast<int>(0);
}

void QtScriptSamplerDescriptor::_public_field_set_magFilter(int value)
{
	auto object = thiz<SamplerDescriptor *>();
	if (object)
	{
		object->magFilter = cocos2d::backend::SamplerFilter(value);
	}
}

int QtScriptSamplerDescriptor::_public_field_get_minFilter() const
{
	auto object = thiz<SamplerDescriptor *>();
	if (object)
	{
		return int(object->minFilter);
	}
	return static_cast<int>(0);
}

void QtScriptSamplerDescriptor::_public_field_set_minFilter(int value)
{
	auto object = thiz<SamplerDescriptor *>();
	if (object)
	{
		object->minFilter = cocos2d::backend::SamplerFilter(value);
	}
}

int QtScriptSamplerDescriptor::_public_field_get_sAddressMode() const
{
	auto object = thiz<SamplerDescriptor *>();
	if (object)
	{
		return int(object->sAddressMode);
	}
	return static_cast<int>(0);
}

void QtScriptSamplerDescriptor::_public_field_set_sAddressMode(int value)
{
	auto object = thiz<SamplerDescriptor *>();
	if (object)
	{
		object->sAddressMode = cocos2d::backend::SamplerAddressMode(value);
	}
}

int QtScriptSamplerDescriptor::_public_field_get_tAddressMode() const
{
	auto object = thiz<SamplerDescriptor *>();
	if (object)
	{
		return int(object->tAddressMode);
	}
	return static_cast<int>(0);
}

void QtScriptSamplerDescriptor::_public_field_set_tAddressMode(int value)
{
	auto object = thiz<SamplerDescriptor *>();
	if (object)
	{
		object->tAddressMode = cocos2d::backend::SamplerAddressMode(value);
	}
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptUniformInfo::QtScriptUniformInfo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<UniformInfo, false>(engine, className)
{
}

QtScriptUniformInfo::QtScriptUniformInfo(QScriptEngine *engine)
	: QtScriptUniformInfo(engine, "UniformInfo")
{
}

void QtScriptUniformInfo::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<UniformInfo, QtScriptUniformInfo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptUniformInfo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptUniformInfo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptUniformInfo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::backend::UniformInfo constructor");
	return false;
}

unsigned int QtScriptUniformInfo::_public_field_get_bufferOffset() const
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		return object->bufferOffset;
	}
	return static_cast<unsigned int>(0);
}

void QtScriptUniformInfo::_public_field_set_bufferOffset(unsigned int value)
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		object->bufferOffset = value;
	}
}

int QtScriptUniformInfo::_public_field_get_count() const
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		return object->count;
	}
	return static_cast<int>(0);
}

void QtScriptUniformInfo::_public_field_set_count(int value)
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		object->count = value;
	}
}

bool QtScriptUniformInfo::_public_field_get_isArray() const
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		return object->isArray;
	}
	return false;
}

void QtScriptUniformInfo::_public_field_set_isArray(const bool& value)
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		object->isArray = value;
	}
}

bool QtScriptUniformInfo::_public_field_get_isMatrix() const
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		return object->isMatrix;
	}
	return false;
}

void QtScriptUniformInfo::_public_field_set_isMatrix(const bool& value)
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		object->isMatrix = value;
	}
}

int QtScriptUniformInfo::_public_field_get_location() const
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		return object->location;
	}
	return static_cast<int>(0);
}

void QtScriptUniformInfo::_public_field_set_location(int value)
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		object->location = value;
	}
}

bool QtScriptUniformInfo::_public_field_get_needConvert() const
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		return object->needConvert;
	}
	return false;
}

void QtScriptUniformInfo::_public_field_set_needConvert(const bool& value)
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		object->needConvert = value;
	}
}

unsigned int QtScriptUniformInfo::_public_field_get_size() const
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		return object->size;
	}
	return static_cast<unsigned int>(0);
}

void QtScriptUniformInfo::_public_field_set_size(unsigned int value)
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		object->size = value;
	}
}

unsigned int QtScriptUniformInfo::_public_field_get_type() const
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		return object->type;
	}
	return static_cast<unsigned int>(0);
}

void QtScriptUniformInfo::_public_field_set_type(unsigned int value)
{
	auto object = thiz<UniformInfo *>();
	if (object)
	{
		object->type = value;
	}
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptUniformLocation::QtScriptUniformLocation(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<UniformLocation, false>(engine, className)
{
}

QtScriptUniformLocation::QtScriptUniformLocation(QScriptEngine *engine)
	: QtScriptUniformLocation(engine, "UniformLocation")
{
}

void QtScriptUniformLocation::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<UniformLocation, QtScriptUniformLocation>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

bool QtScriptUniformLocation::equals(const cocos2d::backend::UniformLocation& other)
{
	auto __o = this->thiz<UniformLocation *>();
	if (__o)
	{
		return __o->operator==(other);
	}
	return false;
}

unsigned QtScriptUniformLocation::id(const cocos2d::backend::UniformLocation& uniform)
{
	auto __o = this->thiz<UniformLocation *>();
	if (__o)
	{
		return unsigned(__o->operator()(uniform));
	}
	return static_cast<unsigned>(0);
}

void QtScriptUniformLocation::reset()
{
	auto __o = this->thiz<UniformLocation *>();
	if (__o)
	{
		__o->reset();
	}
}

bool QtScriptUniformLocation::toBool()
{
	auto __o = this->thiz<UniformLocation *>();
	if (__o)
	{
		return __o->operator bool();
	}
	return false;
}

int QtScriptUniformLocation::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptUniformLocation::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptUniformLocation::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::backend::UniformLocation constructor");
	}
	return ok;
}

int QtScriptUniformLocation::_public_field_get_shaderStage() const
{
	auto object = thiz<UniformLocation *>();
	if (object)
	{
		return int(object->shaderStage);
	}
	return static_cast<int>(0);
}

void QtScriptUniformLocation::_public_field_set_shaderStage(int value)
{
	auto object = thiz<UniformLocation *>();
	if (object)
	{
		object->shaderStage = cocos2d::backend::ShaderStage(value);
	}
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptAttributeBindInfo::QtScriptAttributeBindInfo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<AttributeBindInfo, false>(engine, className)
{
}

QtScriptAttributeBindInfo::QtScriptAttributeBindInfo(QScriptEngine *engine)
	: QtScriptAttributeBindInfo(engine, "AttributeBindInfo")
{
}

void QtScriptAttributeBindInfo::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<AttributeBindInfo, QtScriptAttributeBindInfo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptAttributeBindInfo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAttributeBindInfo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptAttributeBindInfo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::backend::AttributeBindInfo constructor");
	return false;
}

QByteArray QtScriptAttributeBindInfo::_public_field_get_attributeName() const
{
	auto object = thiz<AttributeBindInfo *>();
	if (object)
	{
		return QByteArray::fromStdString(object->attributeName);
	}
	return QByteArray();
}

void QtScriptAttributeBindInfo::_public_field_set_attributeName(const QByteArray& value)
{
	auto object = thiz<AttributeBindInfo *>();
	if (object)
	{
		object->attributeName = value.toStdString();
	}
}

int QtScriptAttributeBindInfo::_public_field_get_location() const
{
	auto object = thiz<AttributeBindInfo *>();
	if (object)
	{
		return object->location;
	}
	return static_cast<int>(0);
}

void QtScriptAttributeBindInfo::_public_field_set_location(int value)
{
	auto object = thiz<AttributeBindInfo *>();
	if (object)
	{
		object->location = value;
	}
}

int QtScriptAttributeBindInfo::_public_field_get_size() const
{
	auto object = thiz<AttributeBindInfo *>();
	if (object)
	{
		return object->size;
	}
	return static_cast<int>(0);
}

void QtScriptAttributeBindInfo::_public_field_set_size(int value)
{
	auto object = thiz<AttributeBindInfo *>();
	if (object)
	{
		object->size = value;
	}
}

int QtScriptAttributeBindInfo::_public_field_get_type() const
{
	auto object = thiz<AttributeBindInfo *>();
	if (object)
	{
		return object->type;
	}
	return static_cast<int>(0);
}

void QtScriptAttributeBindInfo::_public_field_set_type(int value)
{
	auto object = thiz<AttributeBindInfo *>();
	if (object)
	{
		object->type = value;
	}
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptBlendDescriptor::QtScriptBlendDescriptor(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<BlendDescriptor, false>(engine, className)
{
}

QtScriptBlendDescriptor::QtScriptBlendDescriptor(QScriptEngine *engine)
	: QtScriptBlendDescriptor(engine, "BlendDescriptor")
{
}

void QtScriptBlendDescriptor::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<BlendDescriptor, QtScriptBlendDescriptor>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptBlendDescriptor::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptBlendDescriptor::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptBlendDescriptor::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::backend::BlendDescriptor constructor");
	return false;
}

int QtScriptBlendDescriptor::_public_field_get_alphaBlendOperation() const
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		return int(object->alphaBlendOperation);
	}
	return static_cast<int>(0);
}

void QtScriptBlendDescriptor::_public_field_set_alphaBlendOperation(int value)
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		object->alphaBlendOperation = cocos2d::backend::BlendOperation(value);
	}
}

bool QtScriptBlendDescriptor::_public_field_get_blendEnabled() const
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		return object->blendEnabled;
	}
	return false;
}

void QtScriptBlendDescriptor::_public_field_set_blendEnabled(const bool& value)
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		object->blendEnabled = value;
	}
}

int QtScriptBlendDescriptor::_public_field_get_destinationAlphaBlendFactor() const
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		return int(object->destinationAlphaBlendFactor);
	}
	return static_cast<int>(0);
}

void QtScriptBlendDescriptor::_public_field_set_destinationAlphaBlendFactor(int value)
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		object->destinationAlphaBlendFactor = cocos2d::backend::BlendFactor(value);
	}
}

int QtScriptBlendDescriptor::_public_field_get_destinationRGBBlendFactor() const
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		return int(object->destinationRGBBlendFactor);
	}
	return static_cast<int>(0);
}

void QtScriptBlendDescriptor::_public_field_set_destinationRGBBlendFactor(int value)
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		object->destinationRGBBlendFactor = cocos2d::backend::BlendFactor(value);
	}
}

int QtScriptBlendDescriptor::_public_field_get_rgbBlendOperation() const
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		return int(object->rgbBlendOperation);
	}
	return static_cast<int>(0);
}

void QtScriptBlendDescriptor::_public_field_set_rgbBlendOperation(int value)
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		object->rgbBlendOperation = cocos2d::backend::BlendOperation(value);
	}
}

int QtScriptBlendDescriptor::_public_field_get_sourceAlphaBlendFactor() const
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		return int(object->sourceAlphaBlendFactor);
	}
	return static_cast<int>(0);
}

void QtScriptBlendDescriptor::_public_field_set_sourceAlphaBlendFactor(int value)
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		object->sourceAlphaBlendFactor = cocos2d::backend::BlendFactor(value);
	}
}

int QtScriptBlendDescriptor::_public_field_get_sourceRGBBlendFactor() const
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		return int(object->sourceRGBBlendFactor);
	}
	return static_cast<int>(0);
}

void QtScriptBlendDescriptor::_public_field_set_sourceRGBBlendFactor(int value)
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		object->sourceRGBBlendFactor = cocos2d::backend::BlendFactor(value);
	}
}

int QtScriptBlendDescriptor::_public_field_get_writeMask() const
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		return int(object->writeMask);
	}
	return static_cast<int>(0);
}

void QtScriptBlendDescriptor::_public_field_set_writeMask(int value)
{
	auto object = thiz<BlendDescriptor *>();
	if (object)
	{
		object->writeMask = cocos2d::backend::ColorWriteMask(value);
	}
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
QtScriptColor3B::QtScriptColor3B(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Color3B, false>(engine, className)
{
}

QtScriptColor3B::QtScriptColor3B(QScriptEngine *engine)
	: QtScriptColor3B(engine, "Color3B")
{
}

void QtScriptColor3B::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<Color3B, QtScriptColor3B>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

bool QtScriptColor3B::differs(const cocos2d::Color3B& right)
{
	auto __o = this->thiz<Color3B *>();
	if (__o)
	{
		return __o->operator!=(right);
	}
	return false;
}

bool QtScriptColor3B::equals(const cocos2d::Color3B& right)
{
	auto __o = this->thiz<Color3B *>();
	if (__o)
	{
		return __o->operator==(right);
	}
	return false;
}

int QtScriptColor3B::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptColor3B::constructorArgumentCountMax() const
{
	return 3;
}

bool QtScriptColor3B::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Color3B>(context->argument(0));
			out = Color3B(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			break;
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<quint8>(context->argument(0));
			auto arg1 = qscriptvalue_cast<quint8>(context->argument(1));
			auto arg2 = qscriptvalue_cast<quint8>(context->argument(2));
			out = Color3B(arg0, arg1, arg2);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Color3B constructor");
	}
	return ok;
}

quint8 QtScriptColor3B::_public_field_get_b() const
{
	auto object = thiz<Color3B *>();
	if (object)
	{
		return object->b;
	}
	return static_cast<quint8>(0);
}

void QtScriptColor3B::_public_field_set_b(quint8 value)
{
	auto object = thiz<Color3B *>();
	if (object)
	{
		object->b = value;
	}
}

quint8 QtScriptColor3B::_public_field_get_g() const
{
	auto object = thiz<Color3B *>();
	if (object)
	{
		return object->g;
	}
	return static_cast<quint8>(0);
}

void QtScriptColor3B::_public_field_set_g(quint8 value)
{
	auto object = thiz<Color3B *>();
	if (object)
	{
		object->g = value;
	}
}

quint8 QtScriptColor3B::_public_field_get_r() const
{
	auto object = thiz<Color3B *>();
	if (object)
	{
		return object->r;
	}
	return static_cast<quint8>(0);
}

void QtScriptColor3B::_public_field_set_r(quint8 value)
{
	auto object = thiz<Color3B *>();
	if (object)
	{
		object->r = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptColor4B::QtScriptColor4B(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Color4B, false>(engine, className)
{
}

QtScriptColor4B::QtScriptColor4B(QScriptEngine *engine)
	: QtScriptColor4B(engine, "Color4B")
{
}

void QtScriptColor4B::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<Color4B, QtScriptColor4B>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

bool QtScriptColor4B::differs(const cocos2d::Color4B& right)
{
	auto __o = this->thiz<Color4B *>();
	if (__o)
	{
		return __o->operator!=(right);
	}
	return false;
}

bool QtScriptColor4B::equals(const cocos2d::Color4B& right)
{
	auto __o = this->thiz<Color4B *>();
	if (__o)
	{
		return __o->operator==(right);
	}
	return false;
}

void QtScriptColor4B::set(quint8 _r, quint8 _g, quint8 _b, quint8 _a)
{
	auto __o = this->thiz<Color4B *>();
	if (__o)
	{
		__o->set(_r, _g, _b, _a);
	}
}

int QtScriptColor4B::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptColor4B::constructorArgumentCountMax() const
{
	return 4;
}

bool QtScriptColor4B::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Color4B>(context->argument(0));
			out = Color4B(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Color3B>(context->argument(0));
			auto arg1 = qscriptvalue_cast<quint8>(context->argument(1));
			out = Color4B(arg0, arg1);
			ok = true;
			break;
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			auto arg0 = qscriptvalue_cast<quint8>(context->argument(0));
			auto arg1 = qscriptvalue_cast<quint8>(context->argument(1));
			auto arg2 = qscriptvalue_cast<quint8>(context->argument(2));
			auto arg3 = qscriptvalue_cast<quint8>(context->argument(3));
			out = Color4B(arg0, arg1, arg2, arg3);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Color4B constructor");
	}
	return ok;
}

quint8 QtScriptColor4B::_public_field_get_a() const
{
	auto object = thiz<Color4B *>();
	if (object)
	{
		return object->a;
	}
	return static_cast<quint8>(0);
}

void QtScriptColor4B::_public_field_set_a(quint8 value)
{
	auto object = thiz<Color4B *>();
	if (object)
	{
		object->a = value;
	}
}

quint8 QtScriptColor4B::_public_field_get_b() const
{
	auto object = thiz<Color4B *>();
	if (object)
	{
		return object->b;
	}
	return static_cast<quint8>(0);
}

void QtScriptColor4B::_public_field_set_b(quint8 value)
{
	auto object = thiz<Color4B *>();
	if (object)
	{
		object->b = value;
	}
}

quint8 QtScriptColor4B::_public_field_get_g() const
{
	auto object = thiz<Color4B *>();
	if (object)
	{
		return object->g;
	}
	return static_cast<quint8>(0);
}

void QtScriptColor4B::_public_field_set_g(quint8 value)
{
	auto object = thiz<Color4B *>();
	if (object)
	{
		object->g = value;
	}
}

quint8 QtScriptColor4B::_public_field_get_r() const
{
	auto object = thiz<Color4B *>();
	if (object)
	{
		return object->r;
	}
	return static_cast<quint8>(0);
}

void QtScriptColor4B::_public_field_set_r(quint8 value)
{
	auto object = thiz<Color4B *>();
	if (object)
	{
		object->r = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptColor4F::QtScriptColor4F(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Color4F, false>(engine, className)
{
}

QtScriptColor4F::QtScriptColor4F(QScriptEngine *engine)
	: QtScriptColor4F(engine, "Color4F")
{
}

void QtScriptColor4F::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<Color4F, QtScriptColor4F>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

bool QtScriptColor4F::differs(const cocos2d::Color4F& right)
{
	auto __o = this->thiz<Color4F *>();
	if (__o)
	{
		return __o->operator!=(right);
	}
	return false;
}

bool QtScriptColor4F::equals(const cocos2d::Color4F& right)
{
	auto __o = this->thiz<Color4F *>();
	if (__o)
	{
		return __o->operator==(right);
	}
	return false;
}

int QtScriptColor4F::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptColor4F::constructorArgumentCountMax() const
{
	return 4;
}

bool QtScriptColor4F::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Color4F>(context->argument(0));
			out = Color4F(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Color3B>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			out = Color4F(arg0, arg1);
			ok = true;
			break;
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			out = Color4F(arg0, arg1, arg2, arg3);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Color4F constructor");
	}
	return ok;
}

float QtScriptColor4F::_public_field_get_a() const
{
	auto object = thiz<Color4F *>();
	if (object)
	{
		return object->a;
	}
	return static_cast<float>(0);
}

void QtScriptColor4F::_public_field_set_a(float value)
{
	auto object = thiz<Color4F *>();
	if (object)
	{
		object->a = value;
	}
}

float QtScriptColor4F::_public_field_get_b() const
{
	auto object = thiz<Color4F *>();
	if (object)
	{
		return object->b;
	}
	return static_cast<float>(0);
}

void QtScriptColor4F::_public_field_set_b(float value)
{
	auto object = thiz<Color4F *>();
	if (object)
	{
		object->b = value;
	}
}

float QtScriptColor4F::_public_field_get_g() const
{
	auto object = thiz<Color4F *>();
	if (object)
	{
		return object->g;
	}
	return static_cast<float>(0);
}

void QtScriptColor4F::_public_field_set_g(float value)
{
	auto object = thiz<Color4F *>();
	if (object)
	{
		object->g = value;
	}
}

float QtScriptColor4F::_public_field_get_r() const
{
	auto object = thiz<Color4F *>();
	if (object)
	{
		return object->r;
	}
	return static_cast<float>(0);
}

void QtScriptColor4F::_public_field_set_r(float value)
{
	auto object = thiz<Color4F *>();
	if (object)
	{
		object->r = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptTex2F::QtScriptTex2F(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Tex2F, false>(engine, className)
{
}

QtScriptTex2F::QtScriptTex2F(QScriptEngine *engine)
	: QtScriptTex2F(engine, "Tex2F")
{
}

void QtScriptTex2F::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<Tex2F, QtScriptTex2F>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptTex2F::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTex2F::constructorArgumentCountMax() const
{
	return 2;
}

bool QtScriptTex2F::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Tex2F>(context->argument(0));
			out = Tex2F(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			out = Tex2F(arg0, arg1);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Tex2F constructor");
	}
	return ok;
}

float QtScriptTex2F::_public_field_get_u() const
{
	auto object = thiz<Tex2F *>();
	if (object)
	{
		return object->u;
	}
	return static_cast<float>(0);
}

void QtScriptTex2F::_public_field_set_u(float value)
{
	auto object = thiz<Tex2F *>();
	if (object)
	{
		object->u = value;
	}
}

float QtScriptTex2F::_public_field_get_v() const
{
	auto object = thiz<Tex2F *>();
	if (object)
	{
		return object->v;
	}
	return static_cast<float>(0);
}

void QtScriptTex2F::_public_field_set_v(float value)
{
	auto object = thiz<Tex2F *>();
	if (object)
	{
		object->v = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptPointSprite::QtScriptPointSprite(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<PointSprite, false>(engine, className)
{
}

QtScriptPointSprite::QtScriptPointSprite(QScriptEngine *engine)
	: QtScriptPointSprite(engine, "PointSprite")
{
}

void QtScriptPointSprite::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<PointSprite, QtScriptPointSprite>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptPointSprite::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptPointSprite::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptPointSprite::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::PointSprite constructor");
	return false;
}

cocos2d::Color4B QtScriptPointSprite::_public_field_get_color() const
{
	auto object = thiz<PointSprite *>();
	if (object)
	{
		return object->color;
	}
	return cocos2d::Color4B();
}

void QtScriptPointSprite::_public_field_set_color(const cocos2d::Color4B& value)
{
	auto object = thiz<PointSprite *>();
	if (object)
	{
		object->color = value;
	}
}

cocos2d::Vec2 QtScriptPointSprite::_public_field_get_pos() const
{
	auto object = thiz<PointSprite *>();
	if (object)
	{
		return object->pos;
	}
	return cocos2d::Vec2();
}

void QtScriptPointSprite::_public_field_set_pos(const cocos2d::Vec2& value)
{
	auto object = thiz<PointSprite *>();
	if (object)
	{
		object->pos = value;
	}
}

float QtScriptPointSprite::_public_field_get_size() const
{
	auto object = thiz<PointSprite *>();
	if (object)
	{
		return object->size;
	}
	return static_cast<float>(0);
}

void QtScriptPointSprite::_public_field_set_size(float value)
{
	auto object = thiz<PointSprite *>();
	if (object)
	{
		object->size = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptQuad2::QtScriptQuad2(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Quad2, false>(engine, className)
{
}

QtScriptQuad2::QtScriptQuad2(QScriptEngine *engine)
	: QtScriptQuad2(engine, "Quad2")
{
}

void QtScriptQuad2::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<Quad2, QtScriptQuad2>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptQuad2::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptQuad2::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptQuad2::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::Quad2 constructor");
	return false;
}

cocos2d::Vec2 QtScriptQuad2::_public_field_get_bl() const
{
	auto object = thiz<Quad2 *>();
	if (object)
	{
		return object->bl;
	}
	return cocos2d::Vec2();
}

void QtScriptQuad2::_public_field_set_bl(const cocos2d::Vec2& value)
{
	auto object = thiz<Quad2 *>();
	if (object)
	{
		object->bl = value;
	}
}

cocos2d::Vec2 QtScriptQuad2::_public_field_get_br() const
{
	auto object = thiz<Quad2 *>();
	if (object)
	{
		return object->br;
	}
	return cocos2d::Vec2();
}

void QtScriptQuad2::_public_field_set_br(const cocos2d::Vec2& value)
{
	auto object = thiz<Quad2 *>();
	if (object)
	{
		object->br = value;
	}
}

cocos2d::Vec2 QtScriptQuad2::_public_field_get_tl() const
{
	auto object = thiz<Quad2 *>();
	if (object)
	{
		return object->tl;
	}
	return cocos2d::Vec2();
}

void QtScriptQuad2::_public_field_set_tl(const cocos2d::Vec2& value)
{
	auto object = thiz<Quad2 *>();
	if (object)
	{
		object->tl = value;
	}
}

cocos2d::Vec2 QtScriptQuad2::_public_field_get_tr() const
{
	auto object = thiz<Quad2 *>();
	if (object)
	{
		return object->tr;
	}
	return cocos2d::Vec2();
}

void QtScriptQuad2::_public_field_set_tr(const cocos2d::Vec2& value)
{
	auto object = thiz<Quad2 *>();
	if (object)
	{
		object->tr = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptQuad3::QtScriptQuad3(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Quad3, false>(engine, className)
{
}

QtScriptQuad3::QtScriptQuad3(QScriptEngine *engine)
	: QtScriptQuad3(engine, "Quad3")
{
}

void QtScriptQuad3::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<Quad3, QtScriptQuad3>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptQuad3::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptQuad3::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptQuad3::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::Quad3 constructor");
	return false;
}

cocos2d::Vec3 QtScriptQuad3::_public_field_get_bl() const
{
	auto object = thiz<Quad3 *>();
	if (object)
	{
		return object->bl;
	}
	return cocos2d::Vec3();
}

void QtScriptQuad3::_public_field_set_bl(const cocos2d::Vec3& value)
{
	auto object = thiz<Quad3 *>();
	if (object)
	{
		object->bl = value;
	}
}

cocos2d::Vec3 QtScriptQuad3::_public_field_get_br() const
{
	auto object = thiz<Quad3 *>();
	if (object)
	{
		return object->br;
	}
	return cocos2d::Vec3();
}

void QtScriptQuad3::_public_field_set_br(const cocos2d::Vec3& value)
{
	auto object = thiz<Quad3 *>();
	if (object)
	{
		object->br = value;
	}
}

cocos2d::Vec3 QtScriptQuad3::_public_field_get_tl() const
{
	auto object = thiz<Quad3 *>();
	if (object)
	{
		return object->tl;
	}
	return cocos2d::Vec3();
}

void QtScriptQuad3::_public_field_set_tl(const cocos2d::Vec3& value)
{
	auto object = thiz<Quad3 *>();
	if (object)
	{
		object->tl = value;
	}
}

cocos2d::Vec3 QtScriptQuad3::_public_field_get_tr() const
{
	auto object = thiz<Quad3 *>();
	if (object)
	{
		return object->tr;
	}
	return cocos2d::Vec3();
}

void QtScriptQuad3::_public_field_set_tr(const cocos2d::Vec3& value)
{
	auto object = thiz<Quad3 *>();
	if (object)
	{
		object->tr = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptV2F_C4B_T2F::QtScriptV2F_C4B_T2F(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<V2F_C4B_T2F, false>(engine, className)
{
}

QtScriptV2F_C4B_T2F::QtScriptV2F_C4B_T2F(QScriptEngine *engine)
	: QtScriptV2F_C4B_T2F(engine, "V2F_C4B_T2F")
{
}

void QtScriptV2F_C4B_T2F::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<V2F_C4B_T2F, QtScriptV2F_C4B_T2F>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptV2F_C4B_T2F::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptV2F_C4B_T2F::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptV2F_C4B_T2F::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::V2F_C4B_T2F constructor");
	return false;
}

cocos2d::Color4B QtScriptV2F_C4B_T2F::_public_field_get_colors() const
{
	auto object = thiz<V2F_C4B_T2F *>();
	if (object)
	{
		return object->colors;
	}
	return cocos2d::Color4B();
}

void QtScriptV2F_C4B_T2F::_public_field_set_colors(const cocos2d::Color4B& value)
{
	auto object = thiz<V2F_C4B_T2F *>();
	if (object)
	{
		object->colors = value;
	}
}

cocos2d::Tex2F QtScriptV2F_C4B_T2F::_public_field_get_texCoords() const
{
	auto object = thiz<V2F_C4B_T2F *>();
	if (object)
	{
		return object->texCoords;
	}
	return cocos2d::Tex2F();
}

void QtScriptV2F_C4B_T2F::_public_field_set_texCoords(const cocos2d::Tex2F& value)
{
	auto object = thiz<V2F_C4B_T2F *>();
	if (object)
	{
		object->texCoords = value;
	}
}

cocos2d::Vec2 QtScriptV2F_C4B_T2F::_public_field_get_vertices() const
{
	auto object = thiz<V2F_C4B_T2F *>();
	if (object)
	{
		return object->vertices;
	}
	return cocos2d::Vec2();
}

void QtScriptV2F_C4B_T2F::_public_field_set_vertices(const cocos2d::Vec2& value)
{
	auto object = thiz<V2F_C4B_T2F *>();
	if (object)
	{
		object->vertices = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptV2F_C4B_PF::QtScriptV2F_C4B_PF(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<V2F_C4B_PF, false>(engine, className)
{
}

QtScriptV2F_C4B_PF::QtScriptV2F_C4B_PF(QScriptEngine *engine)
	: QtScriptV2F_C4B_PF(engine, "V2F_C4B_PF")
{
}

void QtScriptV2F_C4B_PF::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<V2F_C4B_PF, QtScriptV2F_C4B_PF>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptV2F_C4B_PF::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptV2F_C4B_PF::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptV2F_C4B_PF::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::V2F_C4B_PF constructor");
	return false;
}

cocos2d::Color4B QtScriptV2F_C4B_PF::_public_field_get_colors() const
{
	auto object = thiz<V2F_C4B_PF *>();
	if (object)
	{
		return object->colors;
	}
	return cocos2d::Color4B();
}

void QtScriptV2F_C4B_PF::_public_field_set_colors(const cocos2d::Color4B& value)
{
	auto object = thiz<V2F_C4B_PF *>();
	if (object)
	{
		object->colors = value;
	}
}

float QtScriptV2F_C4B_PF::_public_field_get_pointSize() const
{
	auto object = thiz<V2F_C4B_PF *>();
	if (object)
	{
		return object->pointSize;
	}
	return static_cast<float>(0);
}

void QtScriptV2F_C4B_PF::_public_field_set_pointSize(float value)
{
	auto object = thiz<V2F_C4B_PF *>();
	if (object)
	{
		object->pointSize = value;
	}
}

cocos2d::Vec2 QtScriptV2F_C4B_PF::_public_field_get_vertices() const
{
	auto object = thiz<V2F_C4B_PF *>();
	if (object)
	{
		return object->vertices;
	}
	return cocos2d::Vec2();
}

void QtScriptV2F_C4B_PF::_public_field_set_vertices(const cocos2d::Vec2& value)
{
	auto object = thiz<V2F_C4B_PF *>();
	if (object)
	{
		object->vertices = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptV2F_C4F_T2F::QtScriptV2F_C4F_T2F(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<V2F_C4F_T2F, false>(engine, className)
{
}

QtScriptV2F_C4F_T2F::QtScriptV2F_C4F_T2F(QScriptEngine *engine)
	: QtScriptV2F_C4F_T2F(engine, "V2F_C4F_T2F")
{
}

void QtScriptV2F_C4F_T2F::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<V2F_C4F_T2F, QtScriptV2F_C4F_T2F>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptV2F_C4F_T2F::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptV2F_C4F_T2F::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptV2F_C4F_T2F::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::V2F_C4F_T2F constructor");
	return false;
}

cocos2d::Color4F QtScriptV2F_C4F_T2F::_public_field_get_colors() const
{
	auto object = thiz<V2F_C4F_T2F *>();
	if (object)
	{
		return object->colors;
	}
	return cocos2d::Color4F();
}

void QtScriptV2F_C4F_T2F::_public_field_set_colors(const cocos2d::Color4F& value)
{
	auto object = thiz<V2F_C4F_T2F *>();
	if (object)
	{
		object->colors = value;
	}
}

cocos2d::Tex2F QtScriptV2F_C4F_T2F::_public_field_get_texCoords() const
{
	auto object = thiz<V2F_C4F_T2F *>();
	if (object)
	{
		return object->texCoords;
	}
	return cocos2d::Tex2F();
}

void QtScriptV2F_C4F_T2F::_public_field_set_texCoords(const cocos2d::Tex2F& value)
{
	auto object = thiz<V2F_C4F_T2F *>();
	if (object)
	{
		object->texCoords = value;
	}
}

cocos2d::Vec2 QtScriptV2F_C4F_T2F::_public_field_get_vertices() const
{
	auto object = thiz<V2F_C4F_T2F *>();
	if (object)
	{
		return object->vertices;
	}
	return cocos2d::Vec2();
}

void QtScriptV2F_C4F_T2F::_public_field_set_vertices(const cocos2d::Vec2& value)
{
	auto object = thiz<V2F_C4F_T2F *>();
	if (object)
	{
		object->vertices = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptV3F_C4B_T2F::QtScriptV3F_C4B_T2F(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<V3F_C4B_T2F, false>(engine, className)
{
}

QtScriptV3F_C4B_T2F::QtScriptV3F_C4B_T2F(QScriptEngine *engine)
	: QtScriptV3F_C4B_T2F(engine, "V3F_C4B_T2F")
{
}

void QtScriptV3F_C4B_T2F::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<V3F_C4B_T2F, QtScriptV3F_C4B_T2F>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptV3F_C4B_T2F::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptV3F_C4B_T2F::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptV3F_C4B_T2F::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::V3F_C4B_T2F constructor");
	return false;
}

cocos2d::Color4B QtScriptV3F_C4B_T2F::_public_field_get_colors() const
{
	auto object = thiz<V3F_C4B_T2F *>();
	if (object)
	{
		return object->colors;
	}
	return cocos2d::Color4B();
}

void QtScriptV3F_C4B_T2F::_public_field_set_colors(const cocos2d::Color4B& value)
{
	auto object = thiz<V3F_C4B_T2F *>();
	if (object)
	{
		object->colors = value;
	}
}

cocos2d::Tex2F QtScriptV3F_C4B_T2F::_public_field_get_texCoords() const
{
	auto object = thiz<V3F_C4B_T2F *>();
	if (object)
	{
		return object->texCoords;
	}
	return cocos2d::Tex2F();
}

void QtScriptV3F_C4B_T2F::_public_field_set_texCoords(const cocos2d::Tex2F& value)
{
	auto object = thiz<V3F_C4B_T2F *>();
	if (object)
	{
		object->texCoords = value;
	}
}

cocos2d::Vec3 QtScriptV3F_C4B_T2F::_public_field_get_vertices() const
{
	auto object = thiz<V3F_C4B_T2F *>();
	if (object)
	{
		return object->vertices;
	}
	return cocos2d::Vec3();
}

void QtScriptV3F_C4B_T2F::_public_field_set_vertices(const cocos2d::Vec3& value)
{
	auto object = thiz<V3F_C4B_T2F *>();
	if (object)
	{
		object->vertices = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptV3F_T2F::QtScriptV3F_T2F(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<V3F_T2F, false>(engine, className)
{
}

QtScriptV3F_T2F::QtScriptV3F_T2F(QScriptEngine *engine)
	: QtScriptV3F_T2F(engine, "V3F_T2F")
{
}

void QtScriptV3F_T2F::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<V3F_T2F, QtScriptV3F_T2F>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptV3F_T2F::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptV3F_T2F::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptV3F_T2F::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::V3F_T2F constructor");
	return false;
}

cocos2d::Tex2F QtScriptV3F_T2F::_public_field_get_texCoords() const
{
	auto object = thiz<V3F_T2F *>();
	if (object)
	{
		return object->texCoords;
	}
	return cocos2d::Tex2F();
}

void QtScriptV3F_T2F::_public_field_set_texCoords(const cocos2d::Tex2F& value)
{
	auto object = thiz<V3F_T2F *>();
	if (object)
	{
		object->texCoords = value;
	}
}

cocos2d::Vec3 QtScriptV3F_T2F::_public_field_get_vertices() const
{
	auto object = thiz<V3F_T2F *>();
	if (object)
	{
		return object->vertices;
	}
	return cocos2d::Vec3();
}

void QtScriptV3F_T2F::_public_field_set_vertices(const cocos2d::Vec3& value)
{
	auto object = thiz<V3F_T2F *>();
	if (object)
	{
		object->vertices = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptV3F_C4F::QtScriptV3F_C4F(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<V3F_C4F, false>(engine, className)
{
}

QtScriptV3F_C4F::QtScriptV3F_C4F(QScriptEngine *engine)
	: QtScriptV3F_C4F(engine, "V3F_C4F")
{
}

void QtScriptV3F_C4F::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<V3F_C4F, QtScriptV3F_C4F>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptV3F_C4F::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptV3F_C4F::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptV3F_C4F::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::V3F_C4F constructor");
	return false;
}

cocos2d::Color4F QtScriptV3F_C4F::_public_field_get_colors() const
{
	auto object = thiz<V3F_C4F *>();
	if (object)
	{
		return object->colors;
	}
	return cocos2d::Color4F();
}

void QtScriptV3F_C4F::_public_field_set_colors(const cocos2d::Color4F& value)
{
	auto object = thiz<V3F_C4F *>();
	if (object)
	{
		object->colors = value;
	}
}

cocos2d::Vec3 QtScriptV3F_C4F::_public_field_get_vertices() const
{
	auto object = thiz<V3F_C4F *>();
	if (object)
	{
		return object->vertices;
	}
	return cocos2d::Vec3();
}

void QtScriptV3F_C4F::_public_field_set_vertices(const cocos2d::Vec3& value)
{
	auto object = thiz<V3F_C4F *>();
	if (object)
	{
		object->vertices = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptV2F_C4B_T2F_Triangle::QtScriptV2F_C4B_T2F_Triangle(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<V2F_C4B_T2F_Triangle, false>(engine, className)
{
}

QtScriptV2F_C4B_T2F_Triangle::QtScriptV2F_C4B_T2F_Triangle(QScriptEngine *engine)
	: QtScriptV2F_C4B_T2F_Triangle(engine, "V2F_C4B_T2F_Triangle")
{
}

void QtScriptV2F_C4B_T2F_Triangle::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<V2F_C4B_T2F_Triangle, QtScriptV2F_C4B_T2F_Triangle>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptV2F_C4B_T2F_Triangle::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptV2F_C4B_T2F_Triangle::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptV2F_C4B_T2F_Triangle::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::V2F_C4B_T2F_Triangle constructor");
	return false;
}

cocos2d::V2F_C4B_T2F QtScriptV2F_C4B_T2F_Triangle::_public_field_get_a() const
{
	auto object = thiz<V2F_C4B_T2F_Triangle *>();
	if (object)
	{
		return object->a;
	}
	return cocos2d::V2F_C4B_T2F();
}

void QtScriptV2F_C4B_T2F_Triangle::_public_field_set_a(const cocos2d::V2F_C4B_T2F& value)
{
	auto object = thiz<V2F_C4B_T2F_Triangle *>();
	if (object)
	{
		object->a = value;
	}
}

cocos2d::V2F_C4B_T2F QtScriptV2F_C4B_T2F_Triangle::_public_field_get_b() const
{
	auto object = thiz<V2F_C4B_T2F_Triangle *>();
	if (object)
	{
		return object->b;
	}
	return cocos2d::V2F_C4B_T2F();
}

void QtScriptV2F_C4B_T2F_Triangle::_public_field_set_b(const cocos2d::V2F_C4B_T2F& value)
{
	auto object = thiz<V2F_C4B_T2F_Triangle *>();
	if (object)
	{
		object->b = value;
	}
}

cocos2d::V2F_C4B_T2F QtScriptV2F_C4B_T2F_Triangle::_public_field_get_c() const
{
	auto object = thiz<V2F_C4B_T2F_Triangle *>();
	if (object)
	{
		return object->c;
	}
	return cocos2d::V2F_C4B_T2F();
}

void QtScriptV2F_C4B_T2F_Triangle::_public_field_set_c(const cocos2d::V2F_C4B_T2F& value)
{
	auto object = thiz<V2F_C4B_T2F_Triangle *>();
	if (object)
	{
		object->c = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptV2F_C4B_T2F_Quad::QtScriptV2F_C4B_T2F_Quad(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<V2F_C4B_T2F_Quad, false>(engine, className)
{
}

QtScriptV2F_C4B_T2F_Quad::QtScriptV2F_C4B_T2F_Quad(QScriptEngine *engine)
	: QtScriptV2F_C4B_T2F_Quad(engine, "V2F_C4B_T2F_Quad")
{
}

void QtScriptV2F_C4B_T2F_Quad::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<V2F_C4B_T2F_Quad, QtScriptV2F_C4B_T2F_Quad>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptV2F_C4B_T2F_Quad::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptV2F_C4B_T2F_Quad::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptV2F_C4B_T2F_Quad::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::V2F_C4B_T2F_Quad constructor");
	return false;
}

cocos2d::V2F_C4B_T2F QtScriptV2F_C4B_T2F_Quad::_public_field_get_bl() const
{
	auto object = thiz<V2F_C4B_T2F_Quad *>();
	if (object)
	{
		return object->bl;
	}
	return cocos2d::V2F_C4B_T2F();
}

void QtScriptV2F_C4B_T2F_Quad::_public_field_set_bl(const cocos2d::V2F_C4B_T2F& value)
{
	auto object = thiz<V2F_C4B_T2F_Quad *>();
	if (object)
	{
		object->bl = value;
	}
}

cocos2d::V2F_C4B_T2F QtScriptV2F_C4B_T2F_Quad::_public_field_get_br() const
{
	auto object = thiz<V2F_C4B_T2F_Quad *>();
	if (object)
	{
		return object->br;
	}
	return cocos2d::V2F_C4B_T2F();
}

void QtScriptV2F_C4B_T2F_Quad::_public_field_set_br(const cocos2d::V2F_C4B_T2F& value)
{
	auto object = thiz<V2F_C4B_T2F_Quad *>();
	if (object)
	{
		object->br = value;
	}
}

cocos2d::V2F_C4B_T2F QtScriptV2F_C4B_T2F_Quad::_public_field_get_tl() const
{
	auto object = thiz<V2F_C4B_T2F_Quad *>();
	if (object)
	{
		return object->tl;
	}
	return cocos2d::V2F_C4B_T2F();
}

void QtScriptV2F_C4B_T2F_Quad::_public_field_set_tl(const cocos2d::V2F_C4B_T2F& value)
{
	auto object = thiz<V2F_C4B_T2F_Quad *>();
	if (object)
	{
		object->tl = value;
	}
}

cocos2d::V2F_C4B_T2F QtScriptV2F_C4B_T2F_Quad::_public_field_get_tr() const
{
	auto object = thiz<V2F_C4B_T2F_Quad *>();
	if (object)
	{
		return object->tr;
	}
	return cocos2d::V2F_C4B_T2F();
}

void QtScriptV2F_C4B_T2F_Quad::_public_field_set_tr(const cocos2d::V2F_C4B_T2F& value)
{
	auto object = thiz<V2F_C4B_T2F_Quad *>();
	if (object)
	{
		object->tr = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptV3F_C4B_T2F_Quad::QtScriptV3F_C4B_T2F_Quad(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<V3F_C4B_T2F_Quad, false>(engine, className)
{
}

QtScriptV3F_C4B_T2F_Quad::QtScriptV3F_C4B_T2F_Quad(QScriptEngine *engine)
	: QtScriptV3F_C4B_T2F_Quad(engine, "V3F_C4B_T2F_Quad")
{
}

void QtScriptV3F_C4B_T2F_Quad::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<V3F_C4B_T2F_Quad, QtScriptV3F_C4B_T2F_Quad>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptV3F_C4B_T2F_Quad::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptV3F_C4B_T2F_Quad::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptV3F_C4B_T2F_Quad::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::V3F_C4B_T2F_Quad constructor");
	return false;
}

cocos2d::V3F_C4B_T2F QtScriptV3F_C4B_T2F_Quad::_public_field_get_bl() const
{
	auto object = thiz<V3F_C4B_T2F_Quad *>();
	if (object)
	{
		return object->bl;
	}
	return cocos2d::V3F_C4B_T2F();
}

void QtScriptV3F_C4B_T2F_Quad::_public_field_set_bl(const cocos2d::V3F_C4B_T2F& value)
{
	auto object = thiz<V3F_C4B_T2F_Quad *>();
	if (object)
	{
		object->bl = value;
	}
}

cocos2d::V3F_C4B_T2F QtScriptV3F_C4B_T2F_Quad::_public_field_get_br() const
{
	auto object = thiz<V3F_C4B_T2F_Quad *>();
	if (object)
	{
		return object->br;
	}
	return cocos2d::V3F_C4B_T2F();
}

void QtScriptV3F_C4B_T2F_Quad::_public_field_set_br(const cocos2d::V3F_C4B_T2F& value)
{
	auto object = thiz<V3F_C4B_T2F_Quad *>();
	if (object)
	{
		object->br = value;
	}
}

cocos2d::V3F_C4B_T2F QtScriptV3F_C4B_T2F_Quad::_public_field_get_tl() const
{
	auto object = thiz<V3F_C4B_T2F_Quad *>();
	if (object)
	{
		return object->tl;
	}
	return cocos2d::V3F_C4B_T2F();
}

void QtScriptV3F_C4B_T2F_Quad::_public_field_set_tl(const cocos2d::V3F_C4B_T2F& value)
{
	auto object = thiz<V3F_C4B_T2F_Quad *>();
	if (object)
	{
		object->tl = value;
	}
}

cocos2d::V3F_C4B_T2F QtScriptV3F_C4B_T2F_Quad::_public_field_get_tr() const
{
	auto object = thiz<V3F_C4B_T2F_Quad *>();
	if (object)
	{
		return object->tr;
	}
	return cocos2d::V3F_C4B_T2F();
}

void QtScriptV3F_C4B_T2F_Quad::_public_field_set_tr(const cocos2d::V3F_C4B_T2F& value)
{
	auto object = thiz<V3F_C4B_T2F_Quad *>();
	if (object)
	{
		object->tr = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptV2F_C4F_T2F_Quad::QtScriptV2F_C4F_T2F_Quad(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<V2F_C4F_T2F_Quad, false>(engine, className)
{
}

QtScriptV2F_C4F_T2F_Quad::QtScriptV2F_C4F_T2F_Quad(QScriptEngine *engine)
	: QtScriptV2F_C4F_T2F_Quad(engine, "V2F_C4F_T2F_Quad")
{
}

void QtScriptV2F_C4F_T2F_Quad::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<V2F_C4F_T2F_Quad, QtScriptV2F_C4F_T2F_Quad>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptV2F_C4F_T2F_Quad::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptV2F_C4F_T2F_Quad::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptV2F_C4F_T2F_Quad::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::V2F_C4F_T2F_Quad constructor");
	return false;
}

cocos2d::V2F_C4F_T2F QtScriptV2F_C4F_T2F_Quad::_public_field_get_bl() const
{
	auto object = thiz<V2F_C4F_T2F_Quad *>();
	if (object)
	{
		return object->bl;
	}
	return cocos2d::V2F_C4F_T2F();
}

void QtScriptV2F_C4F_T2F_Quad::_public_field_set_bl(const cocos2d::V2F_C4F_T2F& value)
{
	auto object = thiz<V2F_C4F_T2F_Quad *>();
	if (object)
	{
		object->bl = value;
	}
}

cocos2d::V2F_C4F_T2F QtScriptV2F_C4F_T2F_Quad::_public_field_get_br() const
{
	auto object = thiz<V2F_C4F_T2F_Quad *>();
	if (object)
	{
		return object->br;
	}
	return cocos2d::V2F_C4F_T2F();
}

void QtScriptV2F_C4F_T2F_Quad::_public_field_set_br(const cocos2d::V2F_C4F_T2F& value)
{
	auto object = thiz<V2F_C4F_T2F_Quad *>();
	if (object)
	{
		object->br = value;
	}
}

cocos2d::V2F_C4F_T2F QtScriptV2F_C4F_T2F_Quad::_public_field_get_tl() const
{
	auto object = thiz<V2F_C4F_T2F_Quad *>();
	if (object)
	{
		return object->tl;
	}
	return cocos2d::V2F_C4F_T2F();
}

void QtScriptV2F_C4F_T2F_Quad::_public_field_set_tl(const cocos2d::V2F_C4F_T2F& value)
{
	auto object = thiz<V2F_C4F_T2F_Quad *>();
	if (object)
	{
		object->tl = value;
	}
}

cocos2d::V2F_C4F_T2F QtScriptV2F_C4F_T2F_Quad::_public_field_get_tr() const
{
	auto object = thiz<V2F_C4F_T2F_Quad *>();
	if (object)
	{
		return object->tr;
	}
	return cocos2d::V2F_C4F_T2F();
}

void QtScriptV2F_C4F_T2F_Quad::_public_field_set_tr(const cocos2d::V2F_C4F_T2F& value)
{
	auto object = thiz<V2F_C4F_T2F_Quad *>();
	if (object)
	{
		object->tr = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptV3F_T2F_Quad::QtScriptV3F_T2F_Quad(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<V3F_T2F_Quad, false>(engine, className)
{
}

QtScriptV3F_T2F_Quad::QtScriptV3F_T2F_Quad(QScriptEngine *engine)
	: QtScriptV3F_T2F_Quad(engine, "V3F_T2F_Quad")
{
}

void QtScriptV3F_T2F_Quad::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<V3F_T2F_Quad, QtScriptV3F_T2F_Quad>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptV3F_T2F_Quad::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptV3F_T2F_Quad::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptV3F_T2F_Quad::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::V3F_T2F_Quad constructor");
	return false;
}

cocos2d::V3F_T2F QtScriptV3F_T2F_Quad::_public_field_get_bl() const
{
	auto object = thiz<V3F_T2F_Quad *>();
	if (object)
	{
		return object->bl;
	}
	return cocos2d::V3F_T2F();
}

void QtScriptV3F_T2F_Quad::_public_field_set_bl(const cocos2d::V3F_T2F& value)
{
	auto object = thiz<V3F_T2F_Quad *>();
	if (object)
	{
		object->bl = value;
	}
}

cocos2d::V3F_T2F QtScriptV3F_T2F_Quad::_public_field_get_br() const
{
	auto object = thiz<V3F_T2F_Quad *>();
	if (object)
	{
		return object->br;
	}
	return cocos2d::V3F_T2F();
}

void QtScriptV3F_T2F_Quad::_public_field_set_br(const cocos2d::V3F_T2F& value)
{
	auto object = thiz<V3F_T2F_Quad *>();
	if (object)
	{
		object->br = value;
	}
}

cocos2d::V3F_T2F QtScriptV3F_T2F_Quad::_public_field_get_tl() const
{
	auto object = thiz<V3F_T2F_Quad *>();
	if (object)
	{
		return object->tl;
	}
	return cocos2d::V3F_T2F();
}

void QtScriptV3F_T2F_Quad::_public_field_set_tl(const cocos2d::V3F_T2F& value)
{
	auto object = thiz<V3F_T2F_Quad *>();
	if (object)
	{
		object->tl = value;
	}
}

cocos2d::V3F_T2F QtScriptV3F_T2F_Quad::_public_field_get_tr() const
{
	auto object = thiz<V3F_T2F_Quad *>();
	if (object)
	{
		return object->tr;
	}
	return cocos2d::V3F_T2F();
}

void QtScriptV3F_T2F_Quad::_public_field_set_tr(const cocos2d::V3F_T2F& value)
{
	auto object = thiz<V3F_T2F_Quad *>();
	if (object)
	{
		object->tr = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptBlendFunc::QtScriptBlendFunc(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<BlendFunc, false>(engine, className)
{
}

QtScriptBlendFunc::QtScriptBlendFunc(QScriptEngine *engine)
	: QtScriptBlendFunc(engine, "BlendFunc")
{
}

void QtScriptBlendFunc::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<BlendFunc, QtScriptBlendFunc>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptBlendFunc::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptBlendFunc::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptBlendFunc::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::BlendFunc constructor");
	return false;
}

bool QtScriptBlendFunc::differs(const cocos2d::BlendFunc& a)
{
	auto __o = this->thiz<BlendFunc *>();
	if (__o)
	{
		return __o->operator!=(a);
	}
	return false;
}

bool QtScriptBlendFunc::equals(const cocos2d::BlendFunc& a)
{
	auto __o = this->thiz<BlendFunc *>();
	if (__o)
	{
		return __o->operator==(a);
	}
	return false;
}

bool QtScriptBlendFunc::lessThan(const cocos2d::BlendFunc& a)
{
	auto __o = this->thiz<BlendFunc *>();
	if (__o)
	{
		return __o->operator<(a);
	}
	return false;
}

int QtScriptBlendFunc::_public_field_get_dst() const
{
	auto object = thiz<BlendFunc *>();
	if (object)
	{
		return int(object->dst);
	}
	return static_cast<int>(0);
}

void QtScriptBlendFunc::_public_field_set_dst(int value)
{
	auto object = thiz<BlendFunc *>();
	if (object)
	{
		object->dst = cocos2d::backend::BlendFactor(value);
	}
}

int QtScriptBlendFunc::_public_field_get_src() const
{
	auto object = thiz<BlendFunc *>();
	if (object)
	{
		return int(object->src);
	}
	return static_cast<int>(0);
}

void QtScriptBlendFunc::_public_field_set_src(int value)
{
	auto object = thiz<BlendFunc *>();
	if (object)
	{
		object->src = cocos2d::backend::BlendFactor(value);
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptT2F_Quad::QtScriptT2F_Quad(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<T2F_Quad, false>(engine, className)
{
}

QtScriptT2F_Quad::QtScriptT2F_Quad(QScriptEngine *engine)
	: QtScriptT2F_Quad(engine, "T2F_Quad")
{
}

void QtScriptT2F_Quad::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<T2F_Quad, QtScriptT2F_Quad>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptT2F_Quad::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptT2F_Quad::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptT2F_Quad::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::T2F_Quad constructor");
	return false;
}

cocos2d::Tex2F QtScriptT2F_Quad::_public_field_get_bl() const
{
	auto object = thiz<T2F_Quad *>();
	if (object)
	{
		return object->bl;
	}
	return cocos2d::Tex2F();
}

void QtScriptT2F_Quad::_public_field_set_bl(const cocos2d::Tex2F& value)
{
	auto object = thiz<T2F_Quad *>();
	if (object)
	{
		object->bl = value;
	}
}

cocos2d::Tex2F QtScriptT2F_Quad::_public_field_get_br() const
{
	auto object = thiz<T2F_Quad *>();
	if (object)
	{
		return object->br;
	}
	return cocos2d::Tex2F();
}

void QtScriptT2F_Quad::_public_field_set_br(const cocos2d::Tex2F& value)
{
	auto object = thiz<T2F_Quad *>();
	if (object)
	{
		object->br = value;
	}
}

cocos2d::Tex2F QtScriptT2F_Quad::_public_field_get_tl() const
{
	auto object = thiz<T2F_Quad *>();
	if (object)
	{
		return object->tl;
	}
	return cocos2d::Tex2F();
}

void QtScriptT2F_Quad::_public_field_set_tl(const cocos2d::Tex2F& value)
{
	auto object = thiz<T2F_Quad *>();
	if (object)
	{
		object->tl = value;
	}
}

cocos2d::Tex2F QtScriptT2F_Quad::_public_field_get_tr() const
{
	auto object = thiz<T2F_Quad *>();
	if (object)
	{
		return object->tr;
	}
	return cocos2d::Tex2F();
}

void QtScriptT2F_Quad::_public_field_set_tr(const cocos2d::Tex2F& value)
{
	auto object = thiz<T2F_Quad *>();
	if (object)
	{
		object->tr = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptFontShadow::QtScriptFontShadow(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<FontShadow, false>(engine, className)
{
}

QtScriptFontShadow::QtScriptFontShadow(QScriptEngine *engine)
	: QtScriptFontShadow(engine, "FontShadow")
{
}

void QtScriptFontShadow::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<FontShadow, QtScriptFontShadow>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptFontShadow::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFontShadow::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFontShadow::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::FontShadow constructor");
	return false;
}

float QtScriptFontShadow::_public_field_get_shadowBlur() const
{
	auto object = thiz<FontShadow *>();
	if (object)
	{
		return object->_shadowBlur;
	}
	return static_cast<float>(0);
}

void QtScriptFontShadow::_public_field_set_shadowBlur(float value)
{
	auto object = thiz<FontShadow *>();
	if (object)
	{
		object->_shadowBlur = value;
	}
}

bool QtScriptFontShadow::_public_field_get_shadowEnabled() const
{
	auto object = thiz<FontShadow *>();
	if (object)
	{
		return object->_shadowEnabled;
	}
	return false;
}

void QtScriptFontShadow::_public_field_set_shadowEnabled(const bool& value)
{
	auto object = thiz<FontShadow *>();
	if (object)
	{
		object->_shadowEnabled = value;
	}
}

cocos2d::Size QtScriptFontShadow::_public_field_get_shadowOffset() const
{
	auto object = thiz<FontShadow *>();
	if (object)
	{
		return object->_shadowOffset;
	}
	return cocos2d::Size();
}

void QtScriptFontShadow::_public_field_set_shadowOffset(const cocos2d::Size& value)
{
	auto object = thiz<FontShadow *>();
	if (object)
	{
		object->_shadowOffset = value;
	}
}

float QtScriptFontShadow::_public_field_get_shadowOpacity() const
{
	auto object = thiz<FontShadow *>();
	if (object)
	{
		return object->_shadowOpacity;
	}
	return static_cast<float>(0);
}

void QtScriptFontShadow::_public_field_set_shadowOpacity(float value)
{
	auto object = thiz<FontShadow *>();
	if (object)
	{
		object->_shadowOpacity = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptFontStroke::QtScriptFontStroke(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<FontStroke, false>(engine, className)
{
}

QtScriptFontStroke::QtScriptFontStroke(QScriptEngine *engine)
	: QtScriptFontStroke(engine, "FontStroke")
{
}

void QtScriptFontStroke::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<FontStroke, QtScriptFontStroke>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptFontStroke::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFontStroke::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFontStroke::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::FontStroke constructor");
	return false;
}

quint8 QtScriptFontStroke::_public_field_get_strokeAlpha() const
{
	auto object = thiz<FontStroke *>();
	if (object)
	{
		return object->_strokeAlpha;
	}
	return static_cast<quint8>(0);
}

void QtScriptFontStroke::_public_field_set_strokeAlpha(quint8 value)
{
	auto object = thiz<FontStroke *>();
	if (object)
	{
		object->_strokeAlpha = value;
	}
}

cocos2d::Color3B QtScriptFontStroke::_public_field_get_strokeColor() const
{
	auto object = thiz<FontStroke *>();
	if (object)
	{
		return object->_strokeColor;
	}
	return cocos2d::Color3B();
}

void QtScriptFontStroke::_public_field_set_strokeColor(const cocos2d::Color3B& value)
{
	auto object = thiz<FontStroke *>();
	if (object)
	{
		object->_strokeColor = value;
	}
}

bool QtScriptFontStroke::_public_field_get_strokeEnabled() const
{
	auto object = thiz<FontStroke *>();
	if (object)
	{
		return object->_strokeEnabled;
	}
	return false;
}

void QtScriptFontStroke::_public_field_set_strokeEnabled(const bool& value)
{
	auto object = thiz<FontStroke *>();
	if (object)
	{
		object->_strokeEnabled = value;
	}
}

float QtScriptFontStroke::_public_field_get_strokeSize() const
{
	auto object = thiz<FontStroke *>();
	if (object)
	{
		return object->_strokeSize;
	}
	return static_cast<float>(0);
}

void QtScriptFontStroke::_public_field_set_strokeSize(float value)
{
	auto object = thiz<FontStroke *>();
	if (object)
	{
		object->_strokeSize = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptFontDefinition::QtScriptFontDefinition(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<FontDefinition, false>(engine, className)
{
}

QtScriptFontDefinition::QtScriptFontDefinition(QScriptEngine *engine)
	: QtScriptFontDefinition(engine, "FontDefinition")
{
}

void QtScriptFontDefinition::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<FontDefinition, QtScriptFontDefinition>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptFontDefinition::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFontDefinition::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFontDefinition::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::FontDefinition constructor");
	return false;
}

int QtScriptFontDefinition::_public_field_get_alignment() const
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		return int(object->_alignment);
	}
	return static_cast<int>(0);
}

void QtScriptFontDefinition::_public_field_set_alignment(int value)
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		object->_alignment = cocos2d::TextHAlignment(value);
	}
}

cocos2d::Size QtScriptFontDefinition::_public_field_get_dimensions() const
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		return object->_dimensions;
	}
	return cocos2d::Size();
}

void QtScriptFontDefinition::_public_field_set_dimensions(const cocos2d::Size& value)
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		object->_dimensions = value;
	}
}

bool QtScriptFontDefinition::_public_field_get_enableWrap() const
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		return object->_enableWrap;
	}
	return false;
}

void QtScriptFontDefinition::_public_field_set_enableWrap(const bool& value)
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		object->_enableWrap = value;
	}
}

quint8 QtScriptFontDefinition::_public_field_get_fontAlpha() const
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		return object->_fontAlpha;
	}
	return static_cast<quint8>(0);
}

void QtScriptFontDefinition::_public_field_set_fontAlpha(quint8 value)
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		object->_fontAlpha = value;
	}
}

cocos2d::Color3B QtScriptFontDefinition::_public_field_get_fontFillColor() const
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		return object->_fontFillColor;
	}
	return cocos2d::Color3B();
}

void QtScriptFontDefinition::_public_field_set_fontFillColor(const cocos2d::Color3B& value)
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		object->_fontFillColor = value;
	}
}

QByteArray QtScriptFontDefinition::_public_field_get_fontName() const
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		return QByteArray::fromStdString(object->_fontName);
	}
	return QByteArray();
}

void QtScriptFontDefinition::_public_field_set_fontName(const QByteArray& value)
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		object->_fontName = value.toStdString();
	}
}

int QtScriptFontDefinition::_public_field_get_fontSize() const
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		return object->_fontSize;
	}
	return static_cast<int>(0);
}

void QtScriptFontDefinition::_public_field_set_fontSize(int value)
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		object->_fontSize = value;
	}
}

int QtScriptFontDefinition::_public_field_get_overflow() const
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		return object->_overflow;
	}
	return static_cast<int>(0);
}

void QtScriptFontDefinition::_public_field_set_overflow(int value)
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		object->_overflow = value;
	}
}

cocos2d::FontShadow QtScriptFontDefinition::_public_field_get_shadow() const
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		return object->_shadow;
	}
	return cocos2d::FontShadow();
}

void QtScriptFontDefinition::_public_field_set_shadow(const cocos2d::FontShadow& value)
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		object->_shadow = value;
	}
}

cocos2d::FontStroke QtScriptFontDefinition::_public_field_get_stroke() const
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		return object->_stroke;
	}
	return cocos2d::FontStroke();
}

void QtScriptFontDefinition::_public_field_set_stroke(const cocos2d::FontStroke& value)
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		object->_stroke = value;
	}
}

int QtScriptFontDefinition::_public_field_get_vertAlignment() const
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		return int(object->_vertAlignment);
	}
	return static_cast<int>(0);
}

void QtScriptFontDefinition::_public_field_set_vertAlignment(int value)
{
	auto object = thiz<FontDefinition *>();
	if (object)
	{
		object->_vertAlignment = cocos2d::TextVAlignment(value);
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptViewport::QtScriptViewport(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Viewport, false>(engine, className)
{
}

QtScriptViewport::QtScriptViewport(QScriptEngine *engine)
	: QtScriptViewport(engine, "Viewport")
{
}

void QtScriptViewport::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<Viewport, QtScriptViewport>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptViewport::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptViewport::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptViewport::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::Viewport constructor");
	return false;
}

unsigned int QtScriptViewport::_public_field_get_h() const
{
	auto object = thiz<Viewport *>();
	if (object)
	{
		return object->h;
	}
	return static_cast<unsigned int>(0);
}

void QtScriptViewport::_public_field_set_h(unsigned int value)
{
	auto object = thiz<Viewport *>();
	if (object)
	{
		object->h = value;
	}
}

unsigned int QtScriptViewport::_public_field_get_w() const
{
	auto object = thiz<Viewport *>();
	if (object)
	{
		return object->w;
	}
	return static_cast<unsigned int>(0);
}

void QtScriptViewport::_public_field_set_w(unsigned int value)
{
	auto object = thiz<Viewport *>();
	if (object)
	{
		object->w = value;
	}
}

int QtScriptViewport::_public_field_get_x() const
{
	auto object = thiz<Viewport *>();
	if (object)
	{
		return object->x;
	}
	return static_cast<int>(0);
}

void QtScriptViewport::_public_field_set_x(int value)
{
	auto object = thiz<Viewport *>();
	if (object)
	{
		object->x = value;
	}
}

int QtScriptViewport::_public_field_get_y() const
{
	auto object = thiz<Viewport *>();
	if (object)
	{
		return object->y;
	}
	return static_cast<int>(0);
}

void QtScriptViewport::_public_field_set_y(int value)
{
	auto object = thiz<Viewport *>();
	if (object)
	{
		object->y = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptScissorRect::QtScriptScissorRect(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<ScissorRect, false>(engine, className)
{
}

QtScriptScissorRect::QtScriptScissorRect(QScriptEngine *engine)
	: QtScriptScissorRect(engine, "ScissorRect")
{
}

void QtScriptScissorRect::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<ScissorRect, QtScriptScissorRect>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptScissorRect::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptScissorRect::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptScissorRect::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::ScissorRect constructor");
	return false;
}

float QtScriptScissorRect::_public_field_get_height() const
{
	auto object = thiz<ScissorRect *>();
	if (object)
	{
		return object->height;
	}
	return static_cast<float>(0);
}

void QtScriptScissorRect::_public_field_set_height(float value)
{
	auto object = thiz<ScissorRect *>();
	if (object)
	{
		object->height = value;
	}
}

float QtScriptScissorRect::_public_field_get_width() const
{
	auto object = thiz<ScissorRect *>();
	if (object)
	{
		return object->width;
	}
	return static_cast<float>(0);
}

void QtScriptScissorRect::_public_field_set_width(float value)
{
	auto object = thiz<ScissorRect *>();
	if (object)
	{
		object->width = value;
	}
}

float QtScriptScissorRect::_public_field_get_x() const
{
	auto object = thiz<ScissorRect *>();
	if (object)
	{
		return object->x;
	}
	return static_cast<float>(0);
}

void QtScriptScissorRect::_public_field_set_x(float value)
{
	auto object = thiz<ScissorRect *>();
	if (object)
	{
		object->x = value;
	}
}

float QtScriptScissorRect::_public_field_get_y() const
{
	auto object = thiz<ScissorRect *>();
	if (object)
	{
		return object->y;
	}
	return static_cast<float>(0);
}

void QtScriptScissorRect::_public_field_set_y(float value)
{
	auto object = thiz<ScissorRect *>();
	if (object)
	{
		object->y = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptAABB::QtScriptAABB(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<AABB, false>(engine, className)
{
}

QtScriptAABB::QtScriptAABB(QScriptEngine *engine)
	: QtScriptAABB(engine, "AABB")
{
}

void QtScriptAABB::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<AABB, QtScriptAABB>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

bool QtScriptAABB::containPoint(const cocos2d::Vec3& point)
{
	auto __o = this->thiz<AABB *>();
	if (__o)
	{
		return __o->containPoint(point);
	}
	return false;
}

bool QtScriptAABB::differs(const cocos2d::AABB& other)
{
	auto __o = this->thiz<AABB *>();
	if (__o)
	{
		return __o->operator!=(other);
	}
	return false;
}

bool QtScriptAABB::equals(const cocos2d::AABB& other)
{
	auto __o = this->thiz<AABB *>();
	if (__o)
	{
		return __o->operator==(other);
	}
	return false;
}

cocos2d::Vec3 QtScriptAABB::getCenter()
{
	auto __o = this->thiz<AABB *>();
	if (__o)
	{
		return __o->getCenter();
	}
	return cocos2d::Vec3();
}

void QtScriptAABB::getCorners(cocos2d::Vec3* dst)
{
	auto __o = this->thiz<AABB *>();
	if (__o)
	{
		__o->getCorners(dst);
	}
}

bool QtScriptAABB::intersects(const cocos2d::AABB& aabb)
{
	auto __o = this->thiz<AABB *>();
	if (__o)
	{
		return __o->intersects(aabb);
	}
	return false;
}

bool QtScriptAABB::isEmpty()
{
	auto __o = this->thiz<AABB *>();
	if (__o)
	{
		return __o->isEmpty();
	}
	return false;
}

void QtScriptAABB::merge(const cocos2d::AABB& box)
{
	auto __o = this->thiz<AABB *>();
	if (__o)
	{
		__o->merge(box);
	}
}

void QtScriptAABB::reset()
{
	auto __o = this->thiz<AABB *>();
	if (__o)
	{
		__o->reset();
	}
}

void QtScriptAABB::set(const cocos2d::Vec3& min, const cocos2d::Vec3& max)
{
	auto __o = this->thiz<AABB *>();
	if (__o)
	{
		__o->set(min, max);
	}
}

void QtScriptAABB::transform(const cocos2d::Mat4& mat)
{
	auto __o = this->thiz<AABB *>();
	if (__o)
	{
		__o->transform(mat);
	}
}

cocos2d::AABB QtScriptAABB::transformed(const cocos2d::Mat4& mat)
{
	auto __o = this->thiz<AABB *>();
	if (__o)
	{
		return __o->transformed(mat);
	}
	return cocos2d::AABB();
}

int QtScriptAABB::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAABB::constructorArgumentCountMax() const
{
	return 2;
}

bool QtScriptAABB::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::AABB>(context->argument(0));
			out = AABB(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(1));
			out = AABB(arg0, arg1);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::AABB constructor");
	}
	return ok;
}

cocos2d::Vec3 QtScriptAABB::_public_field_get_max() const
{
	auto object = thiz<AABB *>();
	if (object)
	{
		return object->_max;
	}
	return cocos2d::Vec3();
}

void QtScriptAABB::_public_field_set_max(const cocos2d::Vec3& value)
{
	auto object = thiz<AABB *>();
	if (object)
	{
		object->_max = value;
	}
}

cocos2d::Vec3 QtScriptAABB::_public_field_get_min() const
{
	auto object = thiz<AABB *>();
	if (object)
	{
		return object->_min;
	}
	return cocos2d::Vec3();
}

void QtScriptAABB::_public_field_set_min(const cocos2d::Vec3& value)
{
	auto object = thiz<AABB *>();
	if (object)
	{
		object->_min = value;
	}
}

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptStencilDescriptor::QtScriptStencilDescriptor(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<StencilDescriptor, false>(engine, className)
{
}

QtScriptStencilDescriptor::QtScriptStencilDescriptor(QScriptEngine *engine)
	: QtScriptStencilDescriptor(engine, "StencilDescriptor")
{
}

void QtScriptStencilDescriptor::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<StencilDescriptor, QtScriptStencilDescriptor>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptStencilDescriptor::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptStencilDescriptor::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptStencilDescriptor::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::backend::StencilDescriptor constructor");
	return false;
}

bool QtScriptStencilDescriptor::equals(const cocos2d::backend::StencilDescriptor& rhs)
{
	auto __o = this->thiz<StencilDescriptor *>();
	if (__o)
	{
		return __o->operator==(rhs);
	}
	return false;
}

int QtScriptStencilDescriptor::_public_field_get_depthFailureOperation() const
{
	auto object = thiz<StencilDescriptor *>();
	if (object)
	{
		return int(object->depthFailureOperation);
	}
	return static_cast<int>(0);
}

void QtScriptStencilDescriptor::_public_field_set_depthFailureOperation(int value)
{
	auto object = thiz<StencilDescriptor *>();
	if (object)
	{
		object->depthFailureOperation = cocos2d::backend::StencilOperation(value);
	}
}

int QtScriptStencilDescriptor::_public_field_get_depthStencilPassOperation() const
{
	auto object = thiz<StencilDescriptor *>();
	if (object)
	{
		return int(object->depthStencilPassOperation);
	}
	return static_cast<int>(0);
}

void QtScriptStencilDescriptor::_public_field_set_depthStencilPassOperation(int value)
{
	auto object = thiz<StencilDescriptor *>();
	if (object)
	{
		object->depthStencilPassOperation = cocos2d::backend::StencilOperation(value);
	}
}

unsigned int QtScriptStencilDescriptor::_public_field_get_readMask() const
{
	auto object = thiz<StencilDescriptor *>();
	if (object)
	{
		return object->readMask;
	}
	return static_cast<unsigned int>(0);
}

void QtScriptStencilDescriptor::_public_field_set_readMask(unsigned int value)
{
	auto object = thiz<StencilDescriptor *>();
	if (object)
	{
		object->readMask = value;
	}
}

int QtScriptStencilDescriptor::_public_field_get_stencilCompareFunction() const
{
	auto object = thiz<StencilDescriptor *>();
	if (object)
	{
		return int(object->stencilCompareFunction);
	}
	return static_cast<int>(0);
}

void QtScriptStencilDescriptor::_public_field_set_stencilCompareFunction(int value)
{
	auto object = thiz<StencilDescriptor *>();
	if (object)
	{
		object->stencilCompareFunction = cocos2d::backend::CompareFunction(value);
	}
}

int QtScriptStencilDescriptor::_public_field_get_stencilFailureOperation() const
{
	auto object = thiz<StencilDescriptor *>();
	if (object)
	{
		return int(object->stencilFailureOperation);
	}
	return static_cast<int>(0);
}

void QtScriptStencilDescriptor::_public_field_set_stencilFailureOperation(int value)
{
	auto object = thiz<StencilDescriptor *>();
	if (object)
	{
		object->stencilFailureOperation = cocos2d::backend::StencilOperation(value);
	}
}

unsigned int QtScriptStencilDescriptor::_public_field_get_writeMask() const
{
	auto object = thiz<StencilDescriptor *>();
	if (object)
	{
		return object->writeMask;
	}
	return static_cast<unsigned int>(0);
}

void QtScriptStencilDescriptor::_public_field_set_writeMask(unsigned int value)
{
	auto object = thiz<StencilDescriptor *>();
	if (object)
	{
		object->writeMask = value;
	}
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptDepthStencilDescriptor::QtScriptDepthStencilDescriptor(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<DepthStencilDescriptor, false>(engine, className)
{
}

QtScriptDepthStencilDescriptor::QtScriptDepthStencilDescriptor(QScriptEngine *engine)
	: QtScriptDepthStencilDescriptor(engine, "DepthStencilDescriptor")
{
}

void QtScriptDepthStencilDescriptor::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<DepthStencilDescriptor, QtScriptDepthStencilDescriptor>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptDepthStencilDescriptor::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptDepthStencilDescriptor::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptDepthStencilDescriptor::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::backend::DepthStencilDescriptor constructor");
	return false;
}

cocos2d::backend::StencilDescriptor QtScriptDepthStencilDescriptor::_public_field_get_backFaceStencil() const
{
	auto object = thiz<DepthStencilDescriptor *>();
	if (object)
	{
		return object->backFaceStencil;
	}
	return cocos2d::backend::StencilDescriptor();
}

void QtScriptDepthStencilDescriptor::_public_field_set_backFaceStencil(const cocos2d::backend::StencilDescriptor& value)
{
	auto object = thiz<DepthStencilDescriptor *>();
	if (object)
	{
		object->backFaceStencil = value;
	}
}

int QtScriptDepthStencilDescriptor::_public_field_get_depthCompareFunction() const
{
	auto object = thiz<DepthStencilDescriptor *>();
	if (object)
	{
		return int(object->depthCompareFunction);
	}
	return static_cast<int>(0);
}

void QtScriptDepthStencilDescriptor::_public_field_set_depthCompareFunction(int value)
{
	auto object = thiz<DepthStencilDescriptor *>();
	if (object)
	{
		object->depthCompareFunction = cocos2d::backend::CompareFunction(value);
	}
}

bool QtScriptDepthStencilDescriptor::_public_field_get_depthTestEnabled() const
{
	auto object = thiz<DepthStencilDescriptor *>();
	if (object)
	{
		return object->depthTestEnabled;
	}
	return false;
}

void QtScriptDepthStencilDescriptor::_public_field_set_depthTestEnabled(const bool& value)
{
	auto object = thiz<DepthStencilDescriptor *>();
	if (object)
	{
		object->depthTestEnabled = value;
	}
}

bool QtScriptDepthStencilDescriptor::_public_field_get_depthWriteEnabled() const
{
	auto object = thiz<DepthStencilDescriptor *>();
	if (object)
	{
		return object->depthWriteEnabled;
	}
	return false;
}

void QtScriptDepthStencilDescriptor::_public_field_set_depthWriteEnabled(const bool& value)
{
	auto object = thiz<DepthStencilDescriptor *>();
	if (object)
	{
		object->depthWriteEnabled = value;
	}
}

cocos2d::backend::StencilDescriptor QtScriptDepthStencilDescriptor::_public_field_get_frontFaceStencil() const
{
	auto object = thiz<DepthStencilDescriptor *>();
	if (object)
	{
		return object->frontFaceStencil;
	}
	return cocos2d::backend::StencilDescriptor();
}

void QtScriptDepthStencilDescriptor::_public_field_set_frontFaceStencil(const cocos2d::backend::StencilDescriptor& value)
{
	auto object = thiz<DepthStencilDescriptor *>();
	if (object)
	{
		object->frontFaceStencil = value;
	}
}

bool QtScriptDepthStencilDescriptor::_public_field_get_stencilTestEnabled() const
{
	auto object = thiz<DepthStencilDescriptor *>();
	if (object)
	{
		return object->stencilTestEnabled;
	}
	return false;
}

void QtScriptDepthStencilDescriptor::_public_field_set_stencilTestEnabled(const bool& value)
{
	auto object = thiz<DepthStencilDescriptor *>();
	if (object)
	{
		object->stencilTestEnabled = value;
	}
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptDepthStencilState::QtScriptDepthStencilState(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptDepthStencilState::QtScriptDepthStencilState(QScriptEngine *engine)
	: QtScriptDepthStencilState(engine, "DepthStencilState")
{
}

void QtScriptDepthStencilState::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<DepthStencilState, QtScriptDepthStencilState>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptDepthStencilState::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptDepthStencilState::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptDepthStencilState::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::backend::DepthStencilState");
	return false;
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptTextureDescriptor::QtScriptTextureDescriptor(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<TextureDescriptor, false>(engine, className)
{
}

QtScriptTextureDescriptor::QtScriptTextureDescriptor(QScriptEngine *engine)
	: QtScriptTextureDescriptor(engine, "TextureDescriptor")
{
}

void QtScriptTextureDescriptor::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<TextureDescriptor, QtScriptTextureDescriptor>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptTextureDescriptor::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTextureDescriptor::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTextureDescriptor::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::backend::TextureDescriptor constructor");
	return false;
}

quint32 QtScriptTextureDescriptor::_public_field_get_depth() const
{
	auto object = thiz<TextureDescriptor *>();
	if (object)
	{
		return object->depth;
	}
	return static_cast<quint32>(0);
}

void QtScriptTextureDescriptor::_public_field_set_depth(quint32 value)
{
	auto object = thiz<TextureDescriptor *>();
	if (object)
	{
		object->depth = value;
	}
}

quint32 QtScriptTextureDescriptor::_public_field_get_height() const
{
	auto object = thiz<TextureDescriptor *>();
	if (object)
	{
		return object->height;
	}
	return static_cast<quint32>(0);
}

void QtScriptTextureDescriptor::_public_field_set_height(quint32 value)
{
	auto object = thiz<TextureDescriptor *>();
	if (object)
	{
		object->height = value;
	}
}

cocos2d::backend::SamplerDescriptor QtScriptTextureDescriptor::_public_field_get_samplerDescriptor() const
{
	auto object = thiz<TextureDescriptor *>();
	if (object)
	{
		return object->samplerDescriptor;
	}
	return cocos2d::backend::SamplerDescriptor();
}

void QtScriptTextureDescriptor::_public_field_set_samplerDescriptor(const cocos2d::backend::SamplerDescriptor& value)
{
	auto object = thiz<TextureDescriptor *>();
	if (object)
	{
		object->samplerDescriptor = value;
	}
}

int QtScriptTextureDescriptor::_public_field_get_textureFormat() const
{
	auto object = thiz<TextureDescriptor *>();
	if (object)
	{
		return int(object->textureFormat);
	}
	return static_cast<int>(0);
}

void QtScriptTextureDescriptor::_public_field_set_textureFormat(int value)
{
	auto object = thiz<TextureDescriptor *>();
	if (object)
	{
		object->textureFormat = cocos2d::backend::PixelFormat(value);
	}
}

int QtScriptTextureDescriptor::_public_field_get_textureType() const
{
	auto object = thiz<TextureDescriptor *>();
	if (object)
	{
		return int(object->textureType);
	}
	return static_cast<int>(0);
}

void QtScriptTextureDescriptor::_public_field_set_textureType(int value)
{
	auto object = thiz<TextureDescriptor *>();
	if (object)
	{
		object->textureType = cocos2d::backend::TextureType(value);
	}
}

int QtScriptTextureDescriptor::_public_field_get_textureUsage() const
{
	auto object = thiz<TextureDescriptor *>();
	if (object)
	{
		return int(object->textureUsage);
	}
	return static_cast<int>(0);
}

void QtScriptTextureDescriptor::_public_field_set_textureUsage(int value)
{
	auto object = thiz<TextureDescriptor *>();
	if (object)
	{
		object->textureUsage = cocos2d::backend::TextureUsage(value);
	}
}

quint32 QtScriptTextureDescriptor::_public_field_get_width() const
{
	auto object = thiz<TextureDescriptor *>();
	if (object)
	{
		return object->width;
	}
	return static_cast<quint32>(0);
}

void QtScriptTextureDescriptor::_public_field_set_width(quint32 value)
{
	auto object = thiz<TextureDescriptor *>();
	if (object)
	{
		object->width = value;
	}
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptTextureBackend::QtScriptTextureBackend(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptTextureBackend::QtScriptTextureBackend(QScriptEngine *engine)
	: QtScriptTextureBackend(engine, "TextureBackend")
{
}

void QtScriptTextureBackend::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<TextureBackend, QtScriptTextureBackend>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptTextureBackend::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTextureBackend::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTextureBackend::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::backend::TextureBackend");
	return false;
}

void QtScriptTextureBackend::getBytes(unsigned arg0, unsigned arg1, unsigned arg2, unsigned arg3, bool arg4, const QScriptValue& arg5)
{
	auto __o = this->thiz<TextureBackend *>();
	if (__o)
	{
		__o->getBytes(arg0, arg1, arg2, arg3, arg4, QtCocosScriptUtils::getPixelsCallback(arg5));
	}
}

int QtScriptTextureBackend::getTextureFormat()
{
	auto __o = this->thiz<TextureBackend *>();
	if (__o)
	{
		return int(__o->getTextureFormat());
	}
	return 0;
}

int QtScriptTextureBackend::getTextureType()
{
	auto __o = this->thiz<TextureBackend *>();
	if (__o)
	{
		return int(__o->getTextureType());
	}
	return 0;
}

int QtScriptTextureBackend::getTextureUsage()
{
	auto __o = this->thiz<TextureBackend *>();
	if (__o)
	{
		return int(__o->getTextureUsage());
	}
	return 0;
}

bool QtScriptTextureBackend::hasMipmaps()
{
	auto __o = this->thiz<TextureBackend *>();
	if (__o)
	{
		return __o->hasMipmaps();
	}
	return false;
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptTexture2DBackend::QtScriptTexture2DBackend(QScriptEngine *engine, const QByteArray &className)
	: QtScriptTextureBackend(engine, className)
{
}

QtScriptTexture2DBackend::QtScriptTexture2DBackend(QScriptEngine *engine)
	: QtScriptTexture2DBackend(engine, "Texture2DBackend")
{
}

void QtScriptTexture2DBackend::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<TextureBackend *>());
	auto ctor = RegisterT<Texture2DBackend, QtScriptTexture2DBackend>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptTexture2DBackend::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTexture2DBackend::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTexture2DBackend::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::backend::Texture2DBackend");
	return false;
}

unsigned QtScriptTexture2DBackend::getHeight()
{
	auto __o = this->thiz<Texture2DBackend *>();
	if (__o)
	{
		return unsigned(__o->getHeight());
	}
	return static_cast<unsigned>(0);
}

unsigned QtScriptTexture2DBackend::getWidth()
{
	auto __o = this->thiz<Texture2DBackend *>();
	if (__o)
	{
		return unsigned(__o->getWidth());
	}
	return static_cast<unsigned>(0);
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptTextureCubemapBackend::QtScriptTextureCubemapBackend(QScriptEngine *engine, const QByteArray &className)
	: QtScriptTextureBackend(engine, className)
{
}

QtScriptTextureCubemapBackend::QtScriptTextureCubemapBackend(QScriptEngine *engine)
	: QtScriptTextureCubemapBackend(engine, "TextureCubemapBackend")
{
}

void QtScriptTextureCubemapBackend::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<TextureBackend *>());
	auto ctor = RegisterT<TextureCubemapBackend, QtScriptTextureCubemapBackend>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptTextureCubemapBackend::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTextureCubemapBackend::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTextureCubemapBackend::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::backend::TextureCubemapBackend");
	return false;
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptShaderModule::QtScriptShaderModule(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptShaderModule::QtScriptShaderModule(QScriptEngine *engine)
	: QtScriptShaderModule(engine, "ShaderModule")
{
}

void QtScriptShaderModule::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<ShaderModule, QtScriptShaderModule>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptShaderModule::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptShaderModule::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptShaderModule::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::backend::ShaderModule");
	return false;
}

unsigned QtScriptShaderModule::getHashValue()
{
	auto __o = this->thiz<ShaderModule *>();
	if (__o)
	{
		return unsigned(__o->getHashValue());
	}
	return static_cast<unsigned>(0);
}

int QtScriptShaderModule::getShaderStage()
{
	auto __o = this->thiz<ShaderModule *>();
	if (__o)
	{
		return int(__o->getShaderStage());
	}
	return 0;
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptShaderCache::QtScriptShaderCache(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptShaderCache::QtScriptShaderCache(QScriptEngine *engine)
	: QtScriptShaderCache(engine, "ShaderCache")
{
}

void QtScriptShaderCache::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<ShaderCache, QtScriptShaderCache>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("destroyInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptShaderCache::destroyInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptShaderCache::getInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("newFragmentShaderModule", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptShaderCache::newFragmentShaderModule)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("newVertexShaderModule", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptShaderCache::newVertexShaderModule)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptShaderCache::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptShaderCache::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptShaderCache::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::backend::ShaderCache");
	return false;
}

void QtScriptShaderCache::removeAllShaders()
{
	auto __o = this->thiz<ShaderCache *>();
	if (__o)
	{
		__o->removeAllShaders();
	}
}

void QtScriptShaderCache::removeUnusedShader()
{
	auto __o = this->thiz<ShaderCache *>();
	if (__o)
	{
		__o->removeUnusedShader();
	}
}

QScriptValue QtScriptShaderCache::destroyInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			ShaderCache::destroyInstance();
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::backend::ShaderCache::destroyInstance");
	return __e->uncaughtException();
}

QScriptValue QtScriptShaderCache::getInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ShaderCache::getInstance());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::backend::ShaderCache::getInstance");
	return __e->uncaughtException();
}

QScriptValue QtScriptShaderCache::newFragmentShaderModule(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(ShaderCache::newFragmentShaderModule(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::backend::ShaderCache::newFragmentShaderModule");
	return __e->uncaughtException();
}

QScriptValue QtScriptShaderCache::newVertexShaderModule(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(ShaderCache::newVertexShaderModule(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::backend::ShaderCache::newVertexShaderModule");
	return __e->uncaughtException();
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptProgram::QtScriptProgram(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptProgram::QtScriptProgram(QScriptEngine *engine)
	: QtScriptProgram(engine, "Program")
{
}

void QtScriptProgram::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Program, QtScriptProgram>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("getBuiltinProgram", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptProgram::getBuiltinProgram)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptProgram::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptProgram::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptProgram::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::backend::Program");
	return false;
}

cocos2d::backend::UniformInfo QtScriptProgram::getActiveUniformInfo(int stage, int location)
{
	auto __o = this->thiz<Program *>();
	if (__o)
	{
		return __o->getActiveUniformInfo(cocos2d::backend::ShaderStage(stage), location);
	}
	return cocos2d::backend::UniformInfo();
}

int QtScriptProgram::getAttributeLocation(const QByteArray& name)
{
	auto __o = this->thiz<Program *>();
	if (__o)
	{
		return __o->getAttributeLocation(name.toStdString());
	}
	return 0;
}

QByteArray QtScriptProgram::getFragmentShader()
{
	auto __o = this->thiz<Program *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getFragmentShader());
	}
	return QByteArray();
}

int QtScriptProgram::getMaxFragmentLocation()
{
	auto __o = this->thiz<Program *>();
	if (__o)
	{
		return __o->getMaxFragmentLocation();
	}
	return 0;
}

int QtScriptProgram::getMaxVertexLocation()
{
	auto __o = this->thiz<Program *>();
	if (__o)
	{
		return __o->getMaxVertexLocation();
	}
	return 0;
}

int QtScriptProgram::getProgramType()
{
	auto __o = this->thiz<Program *>();
	if (__o)
	{
		return int(__o->getProgramType());
	}
	return 0;
}

unsigned QtScriptProgram::getUniformBufferSize(int stage)
{
	auto __o = this->thiz<Program *>();
	if (__o)
	{
		return unsigned(__o->getUniformBufferSize(cocos2d::backend::ShaderStage(stage)));
	}
	return static_cast<unsigned>(0);
}

cocos2d::backend::UniformLocation QtScriptProgram::getUniformLocation(const QByteArray& uniform)
{
	auto __o = this->thiz<Program *>();
	if (__o)
	{
		return __o->getUniformLocation(uniform.toStdString());
	}
	return cocos2d::backend::UniformLocation();
}

QByteArray QtScriptProgram::getVertexShader()
{
	auto __o = this->thiz<Program *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getVertexShader());
	}
	return QByteArray();
}

QScriptValue QtScriptProgram::getBuiltinProgram(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<int>(context->argument(0));
			auto arg0 = cocos2d::backend::ProgramType(tmp_0);
			return __e->toScriptValue(Program::getBuiltinProgram(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::backend::Program::getBuiltinProgram");
	return __e->uncaughtException();
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptProgramState::QtScriptProgramState(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptProgramState::QtScriptProgramState(QScriptEngine *engine)
	: QtScriptProgramState(engine, "ProgramState")
{
}

void QtScriptProgramState::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<ProgramState, QtScriptProgramState>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

cocos2d::backend::ProgramState* QtScriptProgramState::clone()
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

void QtScriptProgramState::forkVertexLayout()
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		__o->forkVertexLayout();
	}
}

int QtScriptProgramState::getAttributeLocation(const QByteArray& name)
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		return __o->getAttributeLocation(name.toStdString());
	}
	return 0;
}

cocos2d::backend::Program* QtScriptProgramState::getProgram()
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		return __o->getProgram();
	}
	return nullptr;
}

cocos2d::backend::UniformLocation QtScriptProgramState::getUniformLocation(const QByteArray& uniform)
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		return __o->getUniformLocation(uniform.toStdString());
	}
	return cocos2d::backend::UniformLocation();
}

void QtScriptProgramState::setCallbackUniform(const cocos2d::backend::UniformLocation& arg0, QScriptValue arg1)
{
	auto __e = this->engine();
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		__o->setCallbackUniform(arg0, !arg1.isFunction() ? cocos2d::backend::ProgramState::UniformCallback() : [=](cocos2d::backend::ProgramState* larg0, const cocos2d::backend::UniformLocation& larg1) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	arguments << __e->toScriptValue(larg1);
	arg1.call(QScriptValue(), arguments);
});
	}
}

void QtScriptProgramState::setParameterAutoBinding(const QByteArray& uniformName, const QByteArray& autoBinding)
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		__o->setParameterAutoBinding(uniformName.toStdString(), autoBinding.toStdString());
	}
}

void QtScriptProgramState::setTexture(const cocos2d::backend::UniformLocation& uniformLocation, quint32 slot, cocos2d::backend::TextureBackend* texture)
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		__o->setTexture(uniformLocation, slot, texture);
	}
}

void QtScriptProgramState::setUniform(const cocos2d::backend::UniformLocation& arg0, const QByteArray& arg1)
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		__o->setUniform(arg0, arg1.data(), size_t(arg1.length()));
	}
}

void QtScriptProgramState::setUniformWith1f(const cocos2d::backend::UniformLocation& uniformLocation, float f1)
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		__o->setUniformWith1f(uniformLocation, f1);
	}
}

void QtScriptProgramState::setUniformWith1i(const cocos2d::backend::UniformLocation& uniformLocation, int i1)
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		__o->setUniformWith1i(uniformLocation, i1);
	}
}

void QtScriptProgramState::setUniformWith2f(const cocos2d::backend::UniformLocation& uniformLocation, float f1, float f2)
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		__o->setUniformWith2f(uniformLocation, f1, f2);
	}
}

void QtScriptProgramState::setUniformWith2i(const cocos2d::backend::UniformLocation& uniformLocation, int i1, int i2)
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		__o->setUniformWith2i(uniformLocation, i1, i2);
	}
}

void QtScriptProgramState::setUniformWith3f(const cocos2d::backend::UniformLocation& uniformLocation, float f1, float f2, float f3)
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		__o->setUniformWith3f(uniformLocation, f1, f2, f3);
	}
}

void QtScriptProgramState::setUniformWith3i(const cocos2d::backend::UniformLocation& uniformLocation, int i1, int i2, int i3)
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		__o->setUniformWith3i(uniformLocation, i1, i2, i3);
	}
}

void QtScriptProgramState::setUniformWith4f(const cocos2d::backend::UniformLocation& uniformLocation, float f1, float f2, float f3, float f4)
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		__o->setUniformWith4f(uniformLocation, f1, f2, f3, f4);
	}
}

void QtScriptProgramState::setUniformWith4i(const cocos2d::backend::UniformLocation& uniformLocation, int i1, int i2, int i3, int i4)
{
	auto __o = this->thiz<ProgramState *>();
	if (__o)
	{
		__o->setUniformWith4i(uniformLocation, i1, i2, i3, i4);
	}
}

int QtScriptProgramState::constructorArgumentCountMin() const
{
	return 1;
}

int QtScriptProgramState::constructorArgumentCountMax() const
{
	return 1;
}

bool QtScriptProgramState::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::backend::Program*>(context->argument(0));
			out = new ProgramState(arg0);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::backend::ProgramState constructor");
	}
	return ok;
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
QtScriptPipelineDescriptor::QtScriptPipelineDescriptor(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<PipelineDescriptor, false>(engine, className)
{
}

QtScriptPipelineDescriptor::QtScriptPipelineDescriptor(QScriptEngine *engine)
	: QtScriptPipelineDescriptor(engine, "PipelineDescriptor")
{
}

void QtScriptPipelineDescriptor::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<PipelineDescriptor, QtScriptPipelineDescriptor>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptPipelineDescriptor::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptPipelineDescriptor::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptPipelineDescriptor::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::PipelineDescriptor constructor");
	return false;
}

cocos2d::backend::BlendDescriptor QtScriptPipelineDescriptor::_public_field_get_blendDescriptor() const
{
	auto object = thiz<PipelineDescriptor *>();
	if (object)
	{
		return object->blendDescriptor;
	}
	return cocos2d::backend::BlendDescriptor();
}

void QtScriptPipelineDescriptor::_public_field_set_blendDescriptor(const cocos2d::backend::BlendDescriptor& value)
{
	auto object = thiz<PipelineDescriptor *>();
	if (object)
	{
		object->blendDescriptor = value;
	}
}

cocos2d::backend::ProgramState* QtScriptPipelineDescriptor::_public_field_get_programState() const
{
	auto object = thiz<PipelineDescriptor *>();
	if (object)
	{
		return object->programState;
	}
	return nullptr;
}

void QtScriptPipelineDescriptor::_public_field_set_programState(cocos2d::backend::ProgramState* value)
{
	auto object = thiz<PipelineDescriptor *>();
	if (object)
	{
		object->programState = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptRenderCommand::QtScriptRenderCommand(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<RenderCommand *, true>(engine, className)
{
}

QtScriptRenderCommand::QtScriptRenderCommand(QScriptEngine *engine)
	: QtScriptRenderCommand(engine, "RenderCommand")
{
}

void QtScriptRenderCommand::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<RenderCommand, QtScriptRenderCommand>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptRenderCommand::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptRenderCommand::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptRenderCommand::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::RenderCommand");
	return false;
}

float QtScriptRenderCommand::getDepth()
{
	auto __o = this->thiz<RenderCommand *>();
	if (__o)
	{
		return __o->getDepth();
	}
	return static_cast<float>(0);
}

float QtScriptRenderCommand::getGlobalOrder()
{
	auto __o = this->thiz<RenderCommand *>();
	if (__o)
	{
		return __o->getGlobalOrder();
	}
	return static_cast<float>(0);
}

cocos2d::Mat4 QtScriptRenderCommand::getMV()
{
	auto __o = this->thiz<RenderCommand *>();
	if (__o)
	{
		return __o->getMV();
	}
	return cocos2d::Mat4();
}

cocos2d::PipelineDescriptor* QtScriptRenderCommand::getPipelineDescriptor()
{
	auto __o = this->thiz<RenderCommand *>();
	if (__o)
	{
		return &__o->getPipelineDescriptor();
	}
	return nullptr;
}

int QtScriptRenderCommand::getType()
{
	auto __o = this->thiz<RenderCommand *>();
	if (__o)
	{
		return int(__o->getType());
	}
	return 0;
}

void QtScriptRenderCommand::init(float globalZOrder, const cocos2d::Mat4& modelViewTransform, unsigned int flags)
{
	auto __o = this->thiz<RenderCommand *>();
	if (__o)
	{
		__o->init(globalZOrder, modelViewTransform, flags);
	}
}

bool QtScriptRenderCommand::is2DQueue()
{
	auto __o = this->thiz<RenderCommand *>();
	if (__o)
	{
		return __o->is2DQueue();
	}
	return false;
}

bool QtScriptRenderCommand::is3D()
{
	auto __o = this->thiz<RenderCommand *>();
	if (__o)
	{
		return __o->is3D();
	}
	return false;
}

bool QtScriptRenderCommand::isSkipBatching()
{
	auto __o = this->thiz<RenderCommand *>();
	if (__o)
	{
		return __o->isSkipBatching();
	}
	return false;
}

bool QtScriptRenderCommand::isTransparent()
{
	auto __o = this->thiz<RenderCommand *>();
	if (__o)
	{
		return __o->isTransparent();
	}
	return false;
}

void QtScriptRenderCommand::set2DQueue(bool value)
{
	auto __o = this->thiz<RenderCommand *>();
	if (__o)
	{
		__o->set2DQueue(value);
	}
}

void QtScriptRenderCommand::set3D(bool value)
{
	auto __o = this->thiz<RenderCommand *>();
	if (__o)
	{
		__o->set3D(value);
	}
}

void QtScriptRenderCommand::setSkipBatching(bool value)
{
	auto __o = this->thiz<RenderCommand *>();
	if (__o)
	{
		__o->setSkipBatching(value);
	}
}

void QtScriptRenderCommand::setTransparent(bool isTransparent)
{
	auto __o = this->thiz<RenderCommand *>();
	if (__o)
	{
		__o->setTransparent(isTransparent);
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptCustomCommand::QtScriptCustomCommand(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRenderCommand(engine, className)
{
}

QtScriptCustomCommand::QtScriptCustomCommand(QScriptEngine *engine)
	: QtScriptCustomCommand(engine, "CustomCommand")
{
}

void QtScriptCustomCommand::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<RenderCommand *>());
	auto ctor = RegisterT<CustomCommand, QtScriptCustomCommand>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

void QtScriptCustomCommand::createIndexBuffer(int format, unsigned capacity, int usage)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->createIndexBuffer(cocos2d::backend::IndexFormat(format), capacity, cocos2d::backend::BufferUsage(usage));
	}
}

void QtScriptCustomCommand::createVertexBuffer(unsigned vertexSize, unsigned capacity, int usage)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->createVertexBuffer(vertexSize, capacity, cocos2d::backend::BufferUsage(usage));
	}
}

int QtScriptCustomCommand::getDrawType()
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		return int(__o->getDrawType());
	}
	return 0;
}

cocos2d::backend::Buffer* QtScriptCustomCommand::getIndexBuffer()
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		return __o->getIndexBuffer();
	}
	return nullptr;
}

unsigned QtScriptCustomCommand::getIndexCapacity()
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		return unsigned(__o->getIndexCapacity());
	}
	return static_cast<unsigned>(0);
}

unsigned QtScriptCustomCommand::getIndexDrawCount()
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		return unsigned(__o->getIndexDrawCount());
	}
	return static_cast<unsigned>(0);
}

unsigned QtScriptCustomCommand::getIndexDrawOffset()
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		return unsigned(__o->getIndexDrawOffset());
	}
	return static_cast<unsigned>(0);
}

int QtScriptCustomCommand::getIndexFormat()
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		return int(__o->getIndexFormat());
	}
	return 0;
}

float QtScriptCustomCommand::getLineWidth()
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		return __o->getLineWidth();
	}
	return static_cast<float>(0);
}

int QtScriptCustomCommand::getPrimitiveType()
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		return int(__o->getPrimitiveType());
	}
	return 0;
}

cocos2d::backend::Buffer* QtScriptCustomCommand::getVertexBuffer()
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		return __o->getVertexBuffer();
	}
	return nullptr;
}

unsigned QtScriptCustomCommand::getVertexCapacity()
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		return unsigned(__o->getVertexCapacity());
	}
	return static_cast<unsigned>(0);
}

unsigned QtScriptCustomCommand::getVertexDrawCount()
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		return unsigned(__o->getVertexDrawCount());
	}
	return static_cast<unsigned>(0);
}

unsigned QtScriptCustomCommand::getVertexDrawStart()
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		return unsigned(__o->getVertexDrawStart());
	}
	return static_cast<unsigned>(0);
}

void QtScriptCustomCommand::init(float globalZOrder)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->init(globalZOrder);
	}
}

void QtScriptCustomCommand::init(float globalZOrder, const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->init(globalZOrder, blendFunc);
	}
}

void QtScriptCustomCommand::init(float globalZOrder, const cocos2d::Mat4& modelViewTransform, unsigned int flags)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->init(globalZOrder, modelViewTransform, flags);
	}
}

void QtScriptCustomCommand::setAfterCallback(QScriptValue after)
{
	auto __e = this->engine();
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->setAfterCallback(!after.isFunction() ? cocos2d::CustomCommand::CallBackFunc() : [=]() mutable -> void
{
	QScriptValueList arguments;
	after.call(QScriptValue(), arguments);
});
	}
}

void QtScriptCustomCommand::setBeforeCallback(QScriptValue before)
{
	auto __e = this->engine();
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->setBeforeCallback(!before.isFunction() ? cocos2d::CustomCommand::CallBackFunc() : [=]() mutable -> void
{
	QScriptValueList arguments;
	before.call(QScriptValue(), arguments);
});
	}
}

void QtScriptCustomCommand::setDrawType(int drawType)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->setDrawType(cocos2d::CustomCommand::DrawType(drawType));
	}
}

void QtScriptCustomCommand::setIndexBuffer(cocos2d::backend::Buffer* indexBuffer, int indexFormat)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->setIndexBuffer(indexBuffer, cocos2d::backend::IndexFormat(indexFormat));
	}
}

void QtScriptCustomCommand::setIndexDrawInfo(unsigned start, unsigned count)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->setIndexDrawInfo(start, count);
	}
}

void QtScriptCustomCommand::setLineWidth(float lineWidth)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->setLineWidth(lineWidth);
	}
}

void QtScriptCustomCommand::setPrimitiveType(int primitiveType)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->setPrimitiveType(cocos2d::backend::PrimitiveType(primitiveType));
	}
}

void QtScriptCustomCommand::setVertexBuffer(cocos2d::backend::Buffer* vertexBuffer)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->setVertexBuffer(vertexBuffer);
	}
}

void QtScriptCustomCommand::setVertexDrawInfo(unsigned start, unsigned count)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->setVertexDrawInfo(start, count);
	}
}

void QtScriptCustomCommand::updateIndexBuffer(const QByteArray& arg0)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->updateIndexBuffer(const_cast<char*>(arg0.data()), size_t(arg0.length()));
	}
}

void QtScriptCustomCommand::updateIndexBuffer(const QByteArray& arg0, unsigned arg1)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->updateIndexBuffer(const_cast<char*>(arg0.data()), arg1, size_t(arg0.length()));
	}
}

void QtScriptCustomCommand::updateVertexBuffer(const QByteArray& arg0)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->updateVertexBuffer(const_cast<char*>(arg0.data()), size_t(arg0.length()));
	}
}

void QtScriptCustomCommand::updateVertexBuffer(const QByteArray& arg0, unsigned arg1)
{
	auto __o = this->thiz<CustomCommand *>();
	if (__o)
	{
		__o->updateVertexBuffer(const_cast<char*>(arg0.data()), arg1, size_t(arg0.length()));
	}
}

int QtScriptCustomCommand::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptCustomCommand::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptCustomCommand::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new CustomCommand();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::CustomCommand constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptTexture2D::QtScriptTexture2D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptTexture2D::QtScriptTexture2D(QScriptEngine *engine)
	: QtScriptTexture2D(engine, "Texture2D")
{
}

void QtScriptTexture2D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Texture2D, QtScriptTexture2D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("getDefaultAlphaPixelFormat", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTexture2D::getDefaultAlphaPixelFormat)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("setDefaultAlphaPixelFormat", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTexture2D::setDefaultAlphaPixelFormat)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

void QtScriptTexture2D::generateMipmap()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		__o->generateMipmap();
	}
}

cocos2d::Texture2D* QtScriptTexture2D::getAlphaTexture()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->getAlphaTexture();
	}
	return nullptr;
}

bool QtScriptTexture2D::getAlphaTextureName()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->getAlphaTextureName();
	}
	return false;
}

cocos2d::backend::TextureBackend* QtScriptTexture2D::getBackendTexture()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->getBackendTexture();
	}
	return nullptr;
}

unsigned int QtScriptTexture2D::getBitsPerPixelForFormat()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->getBitsPerPixelForFormat();
	}
	return static_cast<unsigned int>(0);
}

unsigned int QtScriptTexture2D::getBitsPerPixelForFormat(int format)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->getBitsPerPixelForFormat(cocos2d::backend::PixelFormat(format));
	}
	return static_cast<unsigned int>(0);
}

cocos2d::Size QtScriptTexture2D::getContentSize()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->getContentSize();
	}
	return cocos2d::Size();
}

cocos2d::Size QtScriptTexture2D::getContentSizeInPixels()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->getContentSizeInPixels();
	}
	return cocos2d::Size();
}

float QtScriptTexture2D::getMaxS()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->getMaxS();
	}
	return static_cast<float>(0);
}

float QtScriptTexture2D::getMaxT()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->getMaxT();
	}
	return static_cast<float>(0);
}

QByteArray QtScriptTexture2D::getPath()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getPath());
	}
	return QByteArray();
}

int QtScriptTexture2D::getPixelFormat()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return int(__o->getPixelFormat());
	}
	return 0;
}

int QtScriptTexture2D::getPixelsHigh()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->getPixelsHigh();
	}
	return 0;
}

int QtScriptTexture2D::getPixelsWide()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->getPixelsWide();
	}
	return 0;
}

QByteArray QtScriptTexture2D::getStringForFormat()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return QByteArray(__o->getStringForFormat());
	}
	return QByteArray();
}

bool QtScriptTexture2D::hasMipmaps()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->hasMipmaps();
	}
	return false;
}

bool QtScriptTexture2D::hasPremultipliedAlpha()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->hasPremultipliedAlpha();
	}
	return false;
}

bool QtScriptTexture2D::initWithBackendTexture(cocos2d::backend::TextureBackend* texture)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->initWithBackendTexture(texture);
	}
	return false;
}

bool QtScriptTexture2D::initWithBackendTexture(cocos2d::backend::TextureBackend* texture, bool preMultipliedAlpha)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->initWithBackendTexture(texture, preMultipliedAlpha);
	}
	return false;
}

bool QtScriptTexture2D::initWithData(const QByteArray& arg0, int arg1, int arg2, int arg3, const cocos2d::Size& arg4, bool arg5)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->initWithData(arg0.data(), arg0.size(), PixelFormat(arg1), arg2, arg3, arg4, arg5);
	}
	return false;
}

bool QtScriptTexture2D::initWithData(const QByteArray& arg0, int arg1, int arg2, int arg3, int arg4, const cocos2d::Size& arg5, bool arg6)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->initWithData(arg0.data(), arg0.size(), PixelFormat(arg1), PixelFormat(arg2), arg3, arg4, arg5, arg6);
	}
	return false;
}

bool QtScriptTexture2D::initWithImage(cocos2d::Image* image)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->initWithImage(image);
	}
	return false;
}

bool QtScriptTexture2D::initWithImage(cocos2d::Image* image, int format)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->initWithImage(image, cocos2d::backend::PixelFormat(format));
	}
	return false;
}

bool QtScriptTexture2D::initWithString(const QByteArray& text, const cocos2d::FontDefinition& textDefinition)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->initWithString(text.data(), textDefinition);
	}
	return false;
}

bool QtScriptTexture2D::initWithString(const QByteArray& text, const QByteArray& fontName, float fontSize)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->initWithString(text.data(), fontName.toStdString(), fontSize);
	}
	return false;
}

bool QtScriptTexture2D::initWithString(const QByteArray& text, const QByteArray& fontName, float fontSize, const cocos2d::Size& dimensions)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->initWithString(text.data(), fontName.toStdString(), fontSize, dimensions);
	}
	return false;
}

bool QtScriptTexture2D::initWithString(const QByteArray& text, const QByteArray& fontName, float fontSize, const cocos2d::Size& dimensions, int hAlignment)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->initWithString(text.data(), fontName.toStdString(), fontSize, dimensions, cocos2d::TextHAlignment(hAlignment));
	}
	return false;
}

bool QtScriptTexture2D::initWithString(const QByteArray& text, const QByteArray& fontName, float fontSize, const cocos2d::Size& dimensions, int hAlignment, int vAlignment)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->initWithString(text.data(), fontName.toStdString(), fontSize, dimensions, cocos2d::TextHAlignment(hAlignment), cocos2d::TextVAlignment(vAlignment));
	}
	return false;
}

bool QtScriptTexture2D::initWithString(const QByteArray& text, const QByteArray& fontName, float fontSize, const cocos2d::Size& dimensions, int hAlignment, int vAlignment, bool enableWrap)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->initWithString(text.data(), fontName.toStdString(), fontSize, dimensions, cocos2d::TextHAlignment(hAlignment), cocos2d::TextVAlignment(vAlignment), enableWrap);
	}
	return false;
}

bool QtScriptTexture2D::initWithString(const QByteArray& text, const QByteArray& fontName, float fontSize, const cocos2d::Size& dimensions, int hAlignment, int vAlignment, bool enableWrap, int overflow)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->initWithString(text.data(), fontName.toStdString(), fontSize, dimensions, cocos2d::TextHAlignment(hAlignment), cocos2d::TextVAlignment(vAlignment), enableWrap, overflow);
	}
	return false;
}

bool QtScriptTexture2D::isRenderTarget()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->isRenderTarget();
	}
	return false;
}

void QtScriptTexture2D::setAliasTexParameters()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		__o->setAliasTexParameters();
	}
}

void QtScriptTexture2D::setAlphaTexture(cocos2d::Texture2D* alphaTexture)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		__o->setAlphaTexture(alphaTexture);
	}
}

void QtScriptTexture2D::setAntiAliasTexParameters()
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		__o->setAntiAliasTexParameters();
	}
}

void QtScriptTexture2D::setMaxS(float maxS)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		__o->setMaxS(maxS);
	}
}

void QtScriptTexture2D::setMaxT(float maxT)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		__o->setMaxT(maxT);
	}
}

void QtScriptTexture2D::setRenderTarget(bool renderTarget)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		__o->setRenderTarget(renderTarget);
	}
}

void QtScriptTexture2D::setTexParameters(const cocos2d::backend::SamplerDescriptor& params)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		__o->setTexParameters(params);
	}
}

bool QtScriptTexture2D::updateWithData(const QByteArray& arg0, int arg1, int arg2, int arg3, int arg4)
{
	auto __o = this->thiz<Texture2D *>();
	if (__o)
	{
		return __o->updateWithData(const_cast<char*>(arg0.data()), arg1, arg2, arg3, arg4);
	}
	return false;
}

QScriptValue QtScriptTexture2D::getDefaultAlphaPixelFormat(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(int(Texture2D::getDefaultAlphaPixelFormat()));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Texture2D::getDefaultAlphaPixelFormat");
	return __e->uncaughtException();
}

QScriptValue QtScriptTexture2D::setDefaultAlphaPixelFormat(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<int>(context->argument(0));
			auto arg0 = cocos2d::backend::PixelFormat(tmp_0);
			Texture2D::setDefaultAlphaPixelFormat(arg0);
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Texture2D::setDefaultAlphaPixelFormat");
	return __e->uncaughtException();
}

int QtScriptTexture2D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTexture2D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTexture2D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new Texture2D();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Texture2D constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptTextureCacheProtocol::QtScriptTextureCacheProtocol(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<TextureCacheProtocol *, true>(engine, className)
{
}

QtScriptTextureCacheProtocol::QtScriptTextureCacheProtocol(QScriptEngine *engine)
	: QtScriptTextureCacheProtocol(engine, "TextureCacheProtocol")
{
}

void QtScriptTextureCacheProtocol::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<TextureCacheProtocol, QtScriptTextureCacheProtocol>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptTextureCacheProtocol::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTextureCacheProtocol::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTextureCacheProtocol::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::TextureCacheProtocol");
	return false;
}

cocos2d::Texture2D* QtScriptTextureCacheProtocol::getCachedTexture(const QByteArray& key)
{
	auto __o = this->thiz<TextureCacheProtocol *>();
	if (__o)
	{
		return __o->getCachedTexture(key.toStdString());
	}
	return nullptr;
}

} // end of cocos2d

namespace cocos2d {
QtScriptTouch::QtScriptTouch(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptTouch::QtScriptTouch(QScriptEngine *engine)
	: QtScriptTouch(engine, "Touch")
{
}

void QtScriptTouch::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Touch, QtScriptTouch>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

float QtScriptTouch::getCurrentForce()
{
	auto __o = this->thiz<Touch *>();
	if (__o)
	{
		return __o->getCurrentForce();
	}
	return static_cast<float>(0);
}

cocos2d::Vec2 QtScriptTouch::getDelta()
{
	auto __o = this->thiz<Touch *>();
	if (__o)
	{
		return __o->getDelta();
	}
	return cocos2d::Vec2();
}

int QtScriptTouch::getID()
{
	auto __o = this->thiz<Touch *>();
	if (__o)
	{
		return __o->getID();
	}
	return 0;
}

cocos2d::Vec2 QtScriptTouch::getLocation()
{
	auto __o = this->thiz<Touch *>();
	if (__o)
	{
		return __o->getLocation();
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptTouch::getLocationInView()
{
	auto __o = this->thiz<Touch *>();
	if (__o)
	{
		return __o->getLocationInView();
	}
	return cocos2d::Vec2();
}

float QtScriptTouch::getMaxForce()
{
	auto __o = this->thiz<Touch *>();
	if (__o)
	{
		return __o->getMaxForce();
	}
	return static_cast<float>(0);
}

cocos2d::Vec2 QtScriptTouch::getPreviousLocation()
{
	auto __o = this->thiz<Touch *>();
	if (__o)
	{
		return __o->getPreviousLocation();
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptTouch::getPreviousLocationInView()
{
	auto __o = this->thiz<Touch *>();
	if (__o)
	{
		return __o->getPreviousLocationInView();
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptTouch::getStartLocation()
{
	auto __o = this->thiz<Touch *>();
	if (__o)
	{
		return __o->getStartLocation();
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptTouch::getStartLocationInView()
{
	auto __o = this->thiz<Touch *>();
	if (__o)
	{
		return __o->getStartLocationInView();
	}
	return cocos2d::Vec2();
}

void QtScriptTouch::reset()
{
	auto __o = this->thiz<Touch *>();
	if (__o)
	{
		__o->reset();
	}
}

void QtScriptTouch::setTouchInfo(int id, float x, float y)
{
	auto __o = this->thiz<Touch *>();
	if (__o)
	{
		__o->setTouchInfo(id, x, y);
	}
}

void QtScriptTouch::setTouchInfo(int id, float x, float y, float force, float maxForce)
{
	auto __o = this->thiz<Touch *>();
	if (__o)
	{
		__o->setTouchInfo(id, x, y, force, maxForce);
	}
}

int QtScriptTouch::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTouch::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTouch::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new Touch();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Touch constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptAffineTransform::QtScriptAffineTransform(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<AffineTransform, false>(engine, className)
{
}

QtScriptAffineTransform::QtScriptAffineTransform(QScriptEngine *engine)
	: QtScriptAffineTransform(engine, "AffineTransform")
{
}

void QtScriptAffineTransform::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<AffineTransform, QtScriptAffineTransform>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptAffineTransform::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAffineTransform::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptAffineTransform::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::AffineTransform constructor");
	return false;
}

float QtScriptAffineTransform::_public_field_get_a() const
{
	auto object = thiz<AffineTransform *>();
	if (object)
	{
		return object->a;
	}
	return static_cast<float>(0);
}

void QtScriptAffineTransform::_public_field_set_a(float value)
{
	auto object = thiz<AffineTransform *>();
	if (object)
	{
		object->a = value;
	}
}

float QtScriptAffineTransform::_public_field_get_b() const
{
	auto object = thiz<AffineTransform *>();
	if (object)
	{
		return object->b;
	}
	return static_cast<float>(0);
}

void QtScriptAffineTransform::_public_field_set_b(float value)
{
	auto object = thiz<AffineTransform *>();
	if (object)
	{
		object->b = value;
	}
}

float QtScriptAffineTransform::_public_field_get_c() const
{
	auto object = thiz<AffineTransform *>();
	if (object)
	{
		return object->c;
	}
	return static_cast<float>(0);
}

void QtScriptAffineTransform::_public_field_set_c(float value)
{
	auto object = thiz<AffineTransform *>();
	if (object)
	{
		object->c = value;
	}
}

float QtScriptAffineTransform::_public_field_get_d() const
{
	auto object = thiz<AffineTransform *>();
	if (object)
	{
		return object->d;
	}
	return static_cast<float>(0);
}

void QtScriptAffineTransform::_public_field_set_d(float value)
{
	auto object = thiz<AffineTransform *>();
	if (object)
	{
		object->d = value;
	}
}

float QtScriptAffineTransform::_public_field_get_tx() const
{
	auto object = thiz<AffineTransform *>();
	if (object)
	{
		return object->tx;
	}
	return static_cast<float>(0);
}

void QtScriptAffineTransform::_public_field_set_tx(float value)
{
	auto object = thiz<AffineTransform *>();
	if (object)
	{
		object->tx = value;
	}
}

float QtScriptAffineTransform::_public_field_get_ty() const
{
	auto object = thiz<AffineTransform *>();
	if (object)
	{
		return object->ty;
	}
	return static_cast<float>(0);
}

void QtScriptAffineTransform::_public_field_set_ty(float value)
{
	auto object = thiz<AffineTransform *>();
	if (object)
	{
		object->ty = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptComponent::QtScriptComponent(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptComponent::QtScriptComponent(QScriptEngine *engine)
	: QtScriptComponent(engine, "Component")
{
}

void QtScriptComponent::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Component, QtScriptComponent>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptComponent::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

QByteArray QtScriptComponent::getName()
{
	auto __o = this->thiz<Component *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getName());
	}
	return QByteArray();
}

cocos2d::Node* QtScriptComponent::getOwner()
{
	auto __o = this->thiz<Component *>();
	if (__o)
	{
		return __o->getOwner();
	}
	return nullptr;
}

bool QtScriptComponent::init()
{
	auto __o = this->thiz<Component *>();
	if (__o)
	{
		return __o->init();
	}
	return false;
}

bool QtScriptComponent::isEnabled()
{
	auto __o = this->thiz<Component *>();
	if (__o)
	{
		return __o->isEnabled();
	}
	return false;
}

void QtScriptComponent::setEnabled(bool enabled)
{
	auto __o = this->thiz<Component *>();
	if (__o)
	{
		__o->setEnabled(enabled);
	}
}

void QtScriptComponent::setName(const QByteArray& name)
{
	auto __o = this->thiz<Component *>();
	if (__o)
	{
		__o->setName(name.toStdString());
	}
}

QScriptValue QtScriptComponent::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Component::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Component::create");
	return __e->uncaughtException();
}

int QtScriptComponent::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptComponent::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptComponent::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new Component();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Component constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptNode::QtScriptNode(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptNode::QtScriptNode(QScriptEngine *engine)
	: QtScriptNode(engine, "Node")
{
}

void QtScriptNode::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Node, QtScriptNode>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptNode::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getAttachedNodeCount", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptNode::getAttachedNodeCount)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptNode::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptNode::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptNode::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Node");
	return false;
}

void QtScriptNode::addChild(cocos2d::Node* child)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->addChild(child);
	}
}

void QtScriptNode::addChild(cocos2d::Node* child, int localZOrder)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->addChild(child, localZOrder);
	}
}

void QtScriptNode::addChild(cocos2d::Node* child, int localZOrder, int tag)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->addChild(child, localZOrder, tag);
	}
}

bool QtScriptNode::addComponent(cocos2d::Component* component)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->addComponent(component);
	}
	return false;
}

void QtScriptNode::cleanup()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->cleanup();
	}
}

cocos2d::Node* QtScriptNode::clone()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::Vec2 QtScriptNode::convertToNodeSpace(const cocos2d::Vec2& worldPoint)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->convertToNodeSpace(worldPoint);
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptNode::convertToNodeSpaceAR(const cocos2d::Vec2& worldPoint)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->convertToNodeSpaceAR(worldPoint);
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptNode::convertToWorldSpace(const cocos2d::Vec2& nodePoint)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->convertToWorldSpace(nodePoint);
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptNode::convertToWorldSpaceAR(const cocos2d::Vec2& nodePoint)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->convertToWorldSpaceAR(nodePoint);
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptNode::convertTouchToNodeSpace(cocos2d::Touch* touch)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->convertTouchToNodeSpace(touch);
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptNode::convertTouchToNodeSpaceAR(cocos2d::Touch* touch)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->convertTouchToNodeSpaceAR(touch);
	}
	return cocos2d::Vec2();
}

void QtScriptNode::copyNodeChildrenFrom(const cocos2d::Node* from)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->copyNodeChildrenFrom(from);
	}
}

void QtScriptNode::copyNodeChildrenFrom(const cocos2d::Node* from, bool skipHidden)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->copyNodeChildrenFrom(from, skipHidden);
	}
}

void QtScriptNode::copyPropertiesFrom(const cocos2d::Node* from)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->copyPropertiesFrom(from);
	}
}

void QtScriptNode::enumerateChildren(const QByteArray& name, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->enumerateChildren(name.toStdString(), !callback.isFunction() ? std::function<bool (cocos2d::Node *)>() : [=](cocos2d::Node* larg0) mutable -> bool
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	return qscriptvalue_cast<bool>(callback.call(QScriptValue(), arguments));
});
	}
}

cocos2d::Action* QtScriptNode::getActionByTag(int tag)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getActionByTag(tag);
	}
	return nullptr;
}

const cocos2d::Mat4* QtScriptNode::getAdditionalTransform()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getAdditionalTransform();
	}
	return nullptr;
}

cocos2d::Vec2 QtScriptNode::getAnchorPoint()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getAnchorPoint();
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptNode::getAnchorPointInPoints()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getAnchorPointInPoints();
	}
	return cocos2d::Vec2();
}

cocos2d::Rect QtScriptNode::getBoundingBox()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getBoundingBox();
	}
	return cocos2d::Rect();
}

unsigned short QtScriptNode::getCameraMask()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getCameraMask();
	}
	return static_cast<unsigned short>(0);
}

cocos2d::Node* QtScriptNode::getChildAt(int index)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getChildAt(index);
	}
	return nullptr;
}

cocos2d::Node* QtScriptNode::getChildByName(const QByteArray& name)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getChildByName(name.toStdString());
	}
	return nullptr;
}

cocos2d::Node* QtScriptNode::getChildByTag(int tag)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getChildByTag(tag);
	}
	return nullptr;
}

cocos2d::Vector<cocos2d::Node *> QtScriptNode::getChildren()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getChildren();
	}
	return cocos2d::Vector<cocos2d::Node *>();
}

int QtScriptNode::getChildrenCount()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return int(__o->getChildrenCount());
	}
	return 0;
}

cocos2d::Color3B QtScriptNode::getColor()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getColor();
	}
	return cocos2d::Color3B();
}

cocos2d::Component* QtScriptNode::getComponent(const QByteArray& name)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getComponent(name.toStdString());
	}
	return nullptr;
}

cocos2d::Size QtScriptNode::getContentSize()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getContentSize();
	}
	return cocos2d::Size();
}

QByteArray QtScriptNode::getDescription()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getDescription());
	}
	return QByteArray();
}

cocos2d::Color3B QtScriptNode::getDisplayedColor()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getDisplayedColor();
	}
	return cocos2d::Color3B();
}

quint8 QtScriptNode::getDisplayedOpacity()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getDisplayedOpacity();
	}
	return static_cast<quint8>(0);
}

float QtScriptNode::getGlobalZOrder()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getGlobalZOrder();
	}
	return static_cast<float>(0);
}

qint32 QtScriptNode::getLocalZOrder()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getLocalZOrder();
	}
	return static_cast<qint32>(0);
}

cocos2d::Mat4 QtScriptNode::getModelViewTransform()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getModelViewTransform();
	}
	return cocos2d::Mat4();
}

QByteArray QtScriptNode::getName()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getName());
	}
	return QByteArray();
}

cocos2d::AffineTransform QtScriptNode::getNodeToParentAffineTransform()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getNodeToParentAffineTransform();
	}
	return cocos2d::AffineTransform();
}

cocos2d::AffineTransform QtScriptNode::getNodeToParentAffineTransform(const cocos2d::Node* ancestor)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getNodeToParentAffineTransform(ancestor);
	}
	return cocos2d::AffineTransform();
}

cocos2d::Mat4 QtScriptNode::getNodeToParentTransform()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getNodeToParentTransform();
	}
	return cocos2d::Mat4();
}

cocos2d::Mat4 QtScriptNode::getNodeToParentTransform(const cocos2d::Node* ancestor)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getNodeToParentTransform(ancestor);
	}
	return cocos2d::Mat4();
}

cocos2d::AffineTransform QtScriptNode::getNodeToWorldAffineTransform()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getNodeToWorldAffineTransform();
	}
	return cocos2d::AffineTransform();
}

cocos2d::Mat4 QtScriptNode::getNodeToWorldTransform()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getNodeToWorldTransform();
	}
	return cocos2d::Mat4();
}

cocos2d::Vec2 QtScriptNode::getNormalizedPosition()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getNormalizedPosition();
	}
	return cocos2d::Vec2();
}

int QtScriptNode::getNumberOfRunningActions()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return int(__o->getNumberOfRunningActions());
	}
	return 0;
}

int QtScriptNode::getNumberOfRunningActionsByTag(int tag)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return int(__o->getNumberOfRunningActionsByTag(tag));
	}
	return 0;
}

quint8 QtScriptNode::getOpacity()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getOpacity();
	}
	return static_cast<quint8>(0);
}

unsigned int QtScriptNode::getOrderOfArrival()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getOrderOfArrival();
	}
	return static_cast<unsigned int>(0);
}

cocos2d::Node* QtScriptNode::getParent()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getParent();
	}
	return nullptr;
}

cocos2d::AffineTransform QtScriptNode::getParentToNodeAffineTransform()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getParentToNodeAffineTransform();
	}
	return cocos2d::AffineTransform();
}

cocos2d::Mat4 QtScriptNode::getParentToNodeTransform()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getParentToNodeTransform();
	}
	return cocos2d::Mat4();
}

cocos2d::Vec2 QtScriptNode::getPosition()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getPosition();
	}
	return cocos2d::Vec2();
}

cocos2d::Vec3 QtScriptNode::getPosition3D()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getPosition3D();
	}
	return cocos2d::Vec3();
}

cocos2d::Vec2 QtScriptNode::getPositionNormalized()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getPositionNormalized();
	}
	return cocos2d::Vec2();
}

float QtScriptNode::getPositionX()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getPositionX();
	}
	return static_cast<float>(0);
}

float QtScriptNode::getPositionY()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getPositionY();
	}
	return static_cast<float>(0);
}

float QtScriptNode::getPositionZ()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getPositionZ();
	}
	return static_cast<float>(0);
}

cocos2d::backend::ProgramState* QtScriptNode::getProgramState()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getProgramState();
	}
	return nullptr;
}

float QtScriptNode::getRotation()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getRotation();
	}
	return static_cast<float>(0);
}

cocos2d::Vec3 QtScriptNode::getRotation3D()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getRotation3D();
	}
	return cocos2d::Vec3();
}

cocos2d::Quaternion QtScriptNode::getRotationQuat()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getRotationQuat();
	}
	return cocos2d::Quaternion();
}

float QtScriptNode::getRotationSkewX()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getRotationSkewX();
	}
	return static_cast<float>(0);
}

float QtScriptNode::getRotationSkewY()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getRotationSkewY();
	}
	return static_cast<float>(0);
}

float QtScriptNode::getScale()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getScale();
	}
	return static_cast<float>(0);
}

float QtScriptNode::getScaleX()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getScaleX();
	}
	return static_cast<float>(0);
}

float QtScriptNode::getScaleY()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getScaleY();
	}
	return static_cast<float>(0);
}

float QtScriptNode::getScaleZ()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getScaleZ();
	}
	return static_cast<float>(0);
}

cocos2d::Scene* QtScriptNode::getScene()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getScene();
	}
	return nullptr;
}

cocos2d::backend::Program* QtScriptNode::getShaderProgram()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getShaderProgram();
	}
	return nullptr;
}

float QtScriptNode::getSkewX()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getSkewX();
	}
	return static_cast<float>(0);
}

float QtScriptNode::getSkewY()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getSkewY();
	}
	return static_cast<float>(0);
}

int QtScriptNode::getTag()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getTag();
	}
	return 0;
}

const cocos2d::Node* QtScriptNode::getTransformParent()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getTransformParent();
	}
	return nullptr;
}

cocos2d::Ref* QtScriptNode::getUserObject()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getUserObject();
	}
	return nullptr;
}

cocos2d::AffineTransform QtScriptNode::getWorldToNodeAffineTransform()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getWorldToNodeAffineTransform();
	}
	return cocos2d::AffineTransform();
}

cocos2d::Mat4 QtScriptNode::getWorldToNodeTransform()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->getWorldToNodeTransform();
	}
	return cocos2d::Mat4();
}

bool QtScriptNode::init()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->init();
	}
	return false;
}

bool QtScriptNode::isCascadeColorEnabled()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->isCascadeColorEnabled();
	}
	return false;
}

bool QtScriptNode::isCascadeOpacityEnabled()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->isCascadeOpacityEnabled();
	}
	return false;
}

bool QtScriptNode::isIgnoreAnchorPointForPosition()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->isIgnoreAnchorPointForPosition();
	}
	return false;
}

bool QtScriptNode::isOpacityModifyRGB()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->isOpacityModifyRGB();
	}
	return false;
}

bool QtScriptNode::isRunning()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->isRunning();
	}
	return false;
}

bool QtScriptNode::isScheduled(const QByteArray& key)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->isScheduled(key.toStdString());
	}
	return false;
}

bool QtScriptNode::isUseInvertedAdditionalTransformOrder()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->isUseInvertedAdditionalTransformOrder();
	}
	return false;
}

bool QtScriptNode::isVisible()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->isVisible();
	}
	return false;
}

void QtScriptNode::removeAllChildren()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->removeAllChildren();
	}
}

void QtScriptNode::removeAllChildrenWithCleanup(bool cleanup)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->removeAllChildrenWithCleanup(cleanup);
	}
}

void QtScriptNode::removeAllComponents()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->removeAllComponents();
	}
}

void QtScriptNode::removeChild(cocos2d::Node* child)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->removeChild(child);
	}
}

void QtScriptNode::removeChild(cocos2d::Node* child, bool cleanup)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->removeChild(child, cleanup);
	}
}

void QtScriptNode::removeChildByName(const QByteArray& name)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->removeChildByName(name.toStdString());
	}
}

void QtScriptNode::removeChildByName(const QByteArray& name, bool cleanup)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->removeChildByName(name.toStdString(), cleanup);
	}
}

void QtScriptNode::removeChildByTag(int tag)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->removeChildByTag(tag);
	}
}

void QtScriptNode::removeChildByTag(int tag, bool cleanup)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->removeChildByTag(tag, cleanup);
	}
}

bool QtScriptNode::removeComponent(const QByteArray& name)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->removeComponent(name.toStdString());
	}
	return false;
}

void QtScriptNode::removeFromParent()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->removeFromParent();
	}
}

void QtScriptNode::removeFromParentAndCleanup(bool cleanup)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->removeFromParentAndCleanup(cleanup);
	}
}

cocos2d::Action* QtScriptNode::runAction(cocos2d::Action* action)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		return __o->runAction(action);
	}
	return nullptr;
}

void QtScriptNode::schedule(QScriptValue callback, const QByteArray& key)
{
	auto __e = this->engine();
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->schedule(!callback.isFunction() ? std::function<void (float)>() : [=](float larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
}, key.toStdString());
	}
}

void QtScriptNode::schedule(QScriptValue callback, float interval, const QByteArray& key)
{
	auto __e = this->engine();
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->schedule(!callback.isFunction() ? std::function<void (float)>() : [=](float larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
}, interval, key.toStdString());
	}
}

void QtScriptNode::schedule(QScriptValue callback, float interval, unsigned int repeat, float delay, const QByteArray& key)
{
	auto __e = this->engine();
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->schedule(!callback.isFunction() ? std::function<void (float)>() : [=](float larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
}, interval, repeat, delay, key.toStdString());
	}
}

void QtScriptNode::scheduleOnce(QScriptValue callback, float delay, const QByteArray& key)
{
	auto __e = this->engine();
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->scheduleOnce(!callback.isFunction() ? std::function<void (float)>() : [=](float larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
}, delay, key.toStdString());
	}
}

void QtScriptNode::scheduleUpdate()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->scheduleUpdate();
	}
}

void QtScriptNode::scheduleUpdateWithPriority(int priority)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->scheduleUpdateWithPriority(priority);
	}
}

void QtScriptNode::setAdditionalTransform(const cocos2d::Mat4* additionalTransform)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setAdditionalTransform(additionalTransform);
	}
}

void QtScriptNode::setAffineTransform(const cocos2d::AffineTransform& additionalTransform)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setAdditionalTransform(additionalTransform);
	}
}

void QtScriptNode::setAnchorPoint(const cocos2d::Vec2& anchorPoint)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setAnchorPoint(anchorPoint);
	}
}

void QtScriptNode::setCameraMask(unsigned short mask)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setCameraMask(mask);
	}
}

void QtScriptNode::setCameraMask(unsigned short mask, bool applyChildren)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setCameraMask(mask, applyChildren);
	}
}

void QtScriptNode::setCascadeColorEnabled(bool cascadeColorEnabled)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setCascadeColorEnabled(cascadeColorEnabled);
	}
}

void QtScriptNode::setCascadeOpacityEnabled(bool cascadeOpacityEnabled)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setCascadeOpacityEnabled(cascadeOpacityEnabled);
	}
}

void QtScriptNode::setColor(const cocos2d::Color3B& color)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setColor(color);
	}
}

void QtScriptNode::setContentSize(const cocos2d::Size& contentSize)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setContentSize(contentSize);
	}
}

void QtScriptNode::setGlobalZOrder(float globalZOrder)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setGlobalZOrder(globalZOrder);
	}
}

void QtScriptNode::setIgnoreAnchorPointForPosition(bool ignore)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setIgnoreAnchorPointForPosition(ignore);
	}
}

void QtScriptNode::setLocalZOrder(qint32 localZOrder)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setLocalZOrder(localZOrder);
	}
}

void QtScriptNode::setName(const QByteArray& name)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setName(name.toStdString());
	}
}

void QtScriptNode::setNodeToParentTransform(const cocos2d::Mat4& transform)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setNodeToParentTransform(transform);
	}
}

void QtScriptNode::setNormalizedPosition(const cocos2d::Vec2& position)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setNormalizedPosition(position);
	}
}

void QtScriptNode::setOnEnterCallback(QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setOnEnterCallback(!callback.isFunction() ? std::function<void ()>() : [=]() mutable -> void
{
	QScriptValueList arguments;
	callback.call(QScriptValue(), arguments);
});
	}
}

void QtScriptNode::setOnEnterTransitionDidFinishCallback(QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setOnEnterTransitionDidFinishCallback(!callback.isFunction() ? std::function<void ()>() : [=]() mutable -> void
{
	QScriptValueList arguments;
	callback.call(QScriptValue(), arguments);
});
	}
}

void QtScriptNode::setOnExitCallback(QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setOnExitCallback(!callback.isFunction() ? std::function<void ()>() : [=]() mutable -> void
{
	QScriptValueList arguments;
	callback.call(QScriptValue(), arguments);
});
	}
}

void QtScriptNode::setOnExitTransitionDidStartCallback(QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setOnExitTransitionDidStartCallback(!callback.isFunction() ? std::function<void ()>() : [=]() mutable -> void
{
	QScriptValueList arguments;
	callback.call(QScriptValue(), arguments);
});
	}
}

void QtScriptNode::setOnUpdateCallback(QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setOnUpdateCallback(!callback.isFunction() ? std::function<void (float)>() : [=](float larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

void QtScriptNode::setOpacity(quint8 opacity)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setOpacity(opacity);
	}
}

void QtScriptNode::setOpacityModifyRGB(bool value)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setOpacityModifyRGB(value);
	}
}

void QtScriptNode::setOrderOfArrival(unsigned int value)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setOrderOfArrival(value);
	}
}

void QtScriptNode::setPosition(const cocos2d::Vec2& position)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setPosition(position);
	}
}

void QtScriptNode::setPosition(float x, float y)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setPosition(x, y);
	}
}

void QtScriptNode::setPosition3D(const cocos2d::Vec3& position)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setPosition3D(position);
	}
}

void QtScriptNode::setPositionNormalized(const cocos2d::Vec2& position)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setPositionNormalized(position);
	}
}

void QtScriptNode::setPositionX(float x)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setPositionX(x);
	}
}

void QtScriptNode::setPositionY(float y)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setPositionY(y);
	}
}

void QtScriptNode::setPositionZ(float positionZ)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setPositionZ(positionZ);
	}
}

void QtScriptNode::setProgramState(cocos2d::backend::ProgramState* programState)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setProgramState(programState);
	}
}

void QtScriptNode::setRotation(float rotation)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setRotation(rotation);
	}
}

void QtScriptNode::setRotation3D(const cocos2d::Vec3& rotation)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setRotation3D(rotation);
	}
}

void QtScriptNode::setRotationQuat(const cocos2d::Quaternion& quat)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setRotationQuat(quat);
	}
}

void QtScriptNode::setRotationSkewX(float rotationX)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setRotationSkewX(rotationX);
	}
}

void QtScriptNode::setRotationSkewY(float rotationY)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setRotationSkewY(rotationY);
	}
}

void QtScriptNode::setScale(float scale)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setScale(scale);
	}
}

void QtScriptNode::setScale(float scaleX, float scaleY)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setScale(scaleX, scaleY);
	}
}

void QtScriptNode::setScaleX(float scaleX)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setScaleX(scaleX);
	}
}

void QtScriptNode::setScaleY(float scaleY)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setScaleY(scaleY);
	}
}

void QtScriptNode::setScaleZ(float scaleZ)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setScaleZ(scaleZ);
	}
}

void QtScriptNode::setShaderProgram(cocos2d::backend::Program* program)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setShaderProgram(program);
	}
}

void QtScriptNode::setSkewX(float skewX)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setSkewX(skewX);
	}
}

void QtScriptNode::setSkewY(float skewY)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setSkewY(skewY);
	}
}

void QtScriptNode::setTag(int tag)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setTag(tag);
	}
}

void QtScriptNode::setUseInvertedAdditionalTransformOrder(bool value)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setUseInvertedAdditionalTransformOrder(value);
	}
}

void QtScriptNode::setUserObject(cocos2d::Ref* userObject)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setUserObject(userObject);
	}
}

void QtScriptNode::setVisible(bool visible)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->setVisible(visible);
	}
}

void QtScriptNode::sortAllChildren()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->sortAllChildren();
	}
}

void QtScriptNode::stopAction(cocos2d::Action* action)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->stopAction(action);
	}
}

void QtScriptNode::stopActionByTag(int tag)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->stopActionByTag(tag);
	}
}

void QtScriptNode::stopActionsByFlags(unsigned int flags)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->stopActionsByFlags(flags);
	}
}

void QtScriptNode::stopAllActions()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->stopAllActions();
	}
}

void QtScriptNode::stopAllActionsByTag(int tag)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->stopAllActionsByTag(tag);
	}
}

void QtScriptNode::unschedule(const QByteArray& key)
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->unschedule(key.toStdString());
	}
}

void QtScriptNode::unscheduleAllCallbacks()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->unscheduleAllCallbacks();
	}
}

void QtScriptNode::unscheduleUpdate()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->unscheduleUpdate();
	}
}

void QtScriptNode::updateTransform()
{
	auto __o = this->thiz<Node *>();
	if (__o)
	{
		__o->updateTransform();
	}
}

QScriptValue QtScriptNode::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Node::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Node::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptNode::getAttachedNodeCount(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Node::getAttachedNodeCount());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Node::getAttachedNodeCount");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptScene::QtScriptScene(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptScene::QtScriptScene(QScriptEngine *engine)
	: QtScriptScene(engine, "Scene")
{
}

void QtScriptScene::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<Scene, QtScriptScene>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptScene::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithSize", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptScene::createWithSize)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptScene::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptScene::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptScene::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Scene");
	return false;
}

cocos2d::Camera* QtScriptScene::getDefaultCamera()
{
	auto __o = this->thiz<Scene *>();
	if (__o)
	{
		return __o->getDefaultCamera();
	}
	return nullptr;
}

cocos2d::NavMesh* QtScriptScene::getNavMesh()
{
	auto __o = this->thiz<Scene *>();
	if (__o)
	{
		return __o->getNavMesh();
	}
	return nullptr;
}

bool QtScriptScene::initWithSize(const cocos2d::Size& size)
{
	auto __o = this->thiz<Scene *>();
	if (__o)
	{
		return __o->initWithSize(size);
	}
	return false;
}

void QtScriptScene::setCameraOrderDirty()
{
	auto __o = this->thiz<Scene *>();
	if (__o)
	{
		__o->setCameraOrderDirty();
	}
}

void QtScriptScene::setNavMesh(cocos2d::NavMesh* navMesh)
{
	auto __o = this->thiz<Scene *>();
	if (__o)
	{
		__o->setNavMesh(navMesh);
	}
}

void QtScriptScene::setNavMeshDebugCamera(cocos2d::Camera* camera)
{
	auto __o = this->thiz<Scene *>();
	if (__o)
	{
		__o->setNavMeshDebugCamera(camera);
	}
}

void QtScriptScene::stepPhysicsAndNavigation(float deltaTime)
{
	auto __o = this->thiz<Scene *>();
	if (__o)
	{
		__o->stepPhysicsAndNavigation(deltaTime);
	}
}

QScriptValue QtScriptScene::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Scene::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Scene::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptScene::createWithSize(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Size>(context->argument(0));
			return __e->toScriptValue(Scene::createWithSize(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Scene::createWithSize");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptGLContextAttrs::QtScriptGLContextAttrs(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<GLContextAttrs, false>(engine, className)
{
}

QtScriptGLContextAttrs::QtScriptGLContextAttrs(QScriptEngine *engine)
	: QtScriptGLContextAttrs(engine, "GLContextAttrs")
{
}

void QtScriptGLContextAttrs::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<GLContextAttrs, QtScriptGLContextAttrs>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptGLContextAttrs::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptGLContextAttrs::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptGLContextAttrs::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::GLContextAttrs constructor");
	return false;
}

int QtScriptGLContextAttrs::_public_field_get_alphaBits() const
{
	auto object = thiz<GLContextAttrs *>();
	if (object)
	{
		return object->alphaBits;
	}
	return static_cast<int>(0);
}

void QtScriptGLContextAttrs::_public_field_set_alphaBits(int value)
{
	auto object = thiz<GLContextAttrs *>();
	if (object)
	{
		object->alphaBits = value;
	}
}

int QtScriptGLContextAttrs::_public_field_get_blueBits() const
{
	auto object = thiz<GLContextAttrs *>();
	if (object)
	{
		return object->blueBits;
	}
	return static_cast<int>(0);
}

void QtScriptGLContextAttrs::_public_field_set_blueBits(int value)
{
	auto object = thiz<GLContextAttrs *>();
	if (object)
	{
		object->blueBits = value;
	}
}

int QtScriptGLContextAttrs::_public_field_get_depthBits() const
{
	auto object = thiz<GLContextAttrs *>();
	if (object)
	{
		return object->depthBits;
	}
	return static_cast<int>(0);
}

void QtScriptGLContextAttrs::_public_field_set_depthBits(int value)
{
	auto object = thiz<GLContextAttrs *>();
	if (object)
	{
		object->depthBits = value;
	}
}

int QtScriptGLContextAttrs::_public_field_get_greenBits() const
{
	auto object = thiz<GLContextAttrs *>();
	if (object)
	{
		return object->greenBits;
	}
	return static_cast<int>(0);
}

void QtScriptGLContextAttrs::_public_field_set_greenBits(int value)
{
	auto object = thiz<GLContextAttrs *>();
	if (object)
	{
		object->greenBits = value;
	}
}

int QtScriptGLContextAttrs::_public_field_get_multisamplingCount() const
{
	auto object = thiz<GLContextAttrs *>();
	if (object)
	{
		return object->multisamplingCount;
	}
	return static_cast<int>(0);
}

void QtScriptGLContextAttrs::_public_field_set_multisamplingCount(int value)
{
	auto object = thiz<GLContextAttrs *>();
	if (object)
	{
		object->multisamplingCount = value;
	}
}

int QtScriptGLContextAttrs::_public_field_get_redBits() const
{
	auto object = thiz<GLContextAttrs *>();
	if (object)
	{
		return object->redBits;
	}
	return static_cast<int>(0);
}

void QtScriptGLContextAttrs::_public_field_set_redBits(int value)
{
	auto object = thiz<GLContextAttrs *>();
	if (object)
	{
		object->redBits = value;
	}
}

int QtScriptGLContextAttrs::_public_field_get_stencilBits() const
{
	auto object = thiz<GLContextAttrs *>();
	if (object)
	{
		return object->stencilBits;
	}
	return static_cast<int>(0);
}

void QtScriptGLContextAttrs::_public_field_set_stencilBits(int value)
{
	auto object = thiz<GLContextAttrs *>();
	if (object)
	{
		object->stencilBits = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptGLView::QtScriptGLView(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptGLView::QtScriptGLView(QScriptEngine *engine)
	: QtScriptGLView(engine, "GLView")
{
}

void QtScriptGLView::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<GLView, QtScriptGLView>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("getGLContextAttrs", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptGLView::getGLContextAttrs)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptGLView::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptGLView::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptGLView::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::GLView");
	return false;
}

cocos2d::Size QtScriptGLView::getDesignResolutionSize()
{
	auto __o = this->thiz<GLView *>();
	if (__o)
	{
		return __o->getDesignResolutionSize();
	}
	return cocos2d::Size();
}

cocos2d::Size QtScriptGLView::getFrameSize()
{
	auto __o = this->thiz<GLView *>();
	if (__o)
	{
		return __o->getFrameSize();
	}
	return cocos2d::Size();
}

cocos2d::Rect QtScriptGLView::getSafeAreaRect()
{
	auto __o = this->thiz<GLView *>();
	if (__o)
	{
		return __o->getSafeAreaRect();
	}
	return cocos2d::Rect();
}

float QtScriptGLView::getScaleX()
{
	auto __o = this->thiz<GLView *>();
	if (__o)
	{
		return __o->getScaleX();
	}
	return static_cast<float>(0);
}

float QtScriptGLView::getScaleY()
{
	auto __o = this->thiz<GLView *>();
	if (__o)
	{
		return __o->getScaleY();
	}
	return static_cast<float>(0);
}

cocos2d::Rect QtScriptGLView::getScissorRect()
{
	auto __o = this->thiz<GLView *>();
	if (__o)
	{
		return __o->getScissorRect();
	}
	return cocos2d::Rect();
}

QByteArray QtScriptGLView::getViewName()
{
	auto __o = this->thiz<GLView *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getViewName());
	}
	return QByteArray();
}

cocos2d::Rect QtScriptGLView::getViewPortRect()
{
	auto __o = this->thiz<GLView *>();
	if (__o)
	{
		return __o->getViewPortRect();
	}
	return cocos2d::Rect();
}

cocos2d::Vec2 QtScriptGLView::getVisibleOrigin()
{
	auto __o = this->thiz<GLView *>();
	if (__o)
	{
		return __o->getVisibleOrigin();
	}
	return cocos2d::Vec2();
}

cocos2d::Rect QtScriptGLView::getVisibleRect()
{
	auto __o = this->thiz<GLView *>();
	if (__o)
	{
		return __o->getVisibleRect();
	}
	return cocos2d::Rect();
}

cocos2d::Size QtScriptGLView::getVisibleSize()
{
	auto __o = this->thiz<GLView *>();
	if (__o)
	{
		return __o->getVisibleSize();
	}
	return cocos2d::Size();
}

bool QtScriptGLView::isScissorEnabled()
{
	auto __o = this->thiz<GLView *>();
	if (__o)
	{
		return __o->isScissorEnabled();
	}
	return false;
}

void QtScriptGLView::pollEvents()
{
	auto __o = this->thiz<GLView *>();
	if (__o)
	{
		__o->pollEvents();
	}
}

QScriptValue QtScriptGLView::getGLContextAttrs(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(GLView::getGLContextAttrs());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::GLView::getGLContextAttrs");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptDirector::QtScriptDirector(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptDirector::QtScriptDirector(QScriptEngine *engine)
	: QtScriptDirector(engine, "Director")
{
}

void QtScriptDirector::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Director, QtScriptDirector>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("getInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptDirector::getInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

cocos2d::Vec2 QtScriptDirector::convertToGL(const cocos2d::Vec2& point)
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->convertToGL(point);
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptDirector::convertToUI(const cocos2d::Vec2& point)
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->convertToUI(point);
	}
	return cocos2d::Vec2();
}

cocos2d::ActionManager* QtScriptDirector::getActionManager()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getActionManager();
	}
	return nullptr;
}

float QtScriptDirector::getAnimationInterval()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getAnimationInterval();
	}
	return static_cast<float>(0);
}

float QtScriptDirector::getContentScaleFactor()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getContentScaleFactor();
	}
	return static_cast<float>(0);
}

float QtScriptDirector::getDeltaTime()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getDeltaTime();
	}
	return static_cast<float>(0);
}

float QtScriptDirector::getFrameRate()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getFrameRate();
	}
	return static_cast<float>(0);
}

qint64 QtScriptDirector::getFrameStartTimeMicros()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getFrameStartTimeMicros();
	}
	return static_cast<qint64>(0);
}

cocos2d::Mat4 QtScriptDirector::getMatrix(int type)
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getMatrix(cocos2d::MATRIX_STACK_TYPE(type));
	}
	return cocos2d::Mat4();
}

cocos2d::Node* QtScriptDirector::getNotificationNode()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getNotificationNode();
	}
	return nullptr;
}

cocos2d::GLView* QtScriptDirector::getOpenGLView()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getOpenGLView();
	}
	return nullptr;
}

int QtScriptDirector::getProjection()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return int(__o->getProjection());
	}
	return 0;
}

cocos2d::Renderer* QtScriptDirector::getRenderer()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getRenderer();
	}
	return nullptr;
}

cocos2d::Scene* QtScriptDirector::getRunningScene()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getRunningScene();
	}
	return nullptr;
}

cocos2d::Rect QtScriptDirector::getSafeAreaRect()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getSafeAreaRect();
	}
	return cocos2d::Rect();
}

cocos2d::Scheduler* QtScriptDirector::getScheduler()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getScheduler();
	}
	return nullptr;
}

float QtScriptDirector::getSecondsPerFrame()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getSecondsPerFrame();
	}
	return static_cast<float>(0);
}

cocos2d::TextureCache* QtScriptDirector::getTextureCache()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getTextureCache();
	}
	return nullptr;
}

unsigned int QtScriptDirector::getTotalFrames()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getTotalFrames();
	}
	return static_cast<unsigned int>(0);
}

cocos2d::Vec2 QtScriptDirector::getVisibleOrigin()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getVisibleOrigin();
	}
	return cocos2d::Vec2();
}

cocos2d::Size QtScriptDirector::getVisibleSize()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getVisibleSize();
	}
	return cocos2d::Size();
}

cocos2d::Size QtScriptDirector::getWinSize()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getWinSize();
	}
	return cocos2d::Size();
}

cocos2d::Size QtScriptDirector::getWinSizeInPixels()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getWinSizeInPixels();
	}
	return cocos2d::Size();
}

float QtScriptDirector::getZEye()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->getZEye();
	}
	return static_cast<float>(0);
}

bool QtScriptDirector::isDisplayStats()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->isDisplayStats();
	}
	return false;
}

bool QtScriptDirector::isNextDeltaTimeZero()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->isNextDeltaTimeZero();
	}
	return false;
}

bool QtScriptDirector::isPaused()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->isPaused();
	}
	return false;
}

bool QtScriptDirector::isSendCleanupToScene()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->isSendCleanupToScene();
	}
	return false;
}

bool QtScriptDirector::isValid()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		return __o->isValid();
	}
	return false;
}

void QtScriptDirector::purgeCachedData()
{
	auto __o = this->thiz<Director *>();
	if (__o)
	{
		__o->purgeCachedData();
	}
}

QScriptValue QtScriptDirector::getInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Director::getInstance());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Director::getInstance");
	return __e->uncaughtException();
}

int QtScriptDirector::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptDirector::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptDirector::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new Director();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Director constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptScheduler::QtScriptScheduler(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptScheduler::QtScriptScheduler(QScriptEngine *engine)
	: QtScriptScheduler(engine, "Scheduler")
{
}

void QtScriptScheduler::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Scheduler, QtScriptScheduler>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

void QtScriptScheduler::cancelPerformAll()
{
	auto __o = this->thiz<Scheduler *>();
	if (__o)
	{
		__o->removeAllFunctionsToBePerformedInCocosThread();
	}
}

float QtScriptScheduler::getTimeScale()
{
	auto __o = this->thiz<Scheduler *>();
	if (__o)
	{
		return __o->getTimeScale();
	}
	return static_cast<float>(0);
}

void QtScriptScheduler::perform(QScriptValue function)
{
	auto __e = this->engine();
	auto __o = this->thiz<Scheduler *>();
	if (__o)
	{
		__o->performFunctionInCocosThread(!function.isFunction() ? std::function<void ()>() : [=]() mutable -> void
{
	QScriptValueList arguments;
	function.call(QScriptValue(), arguments);
});
	}
}

void QtScriptScheduler::setTimeScale(float timeScale)
{
	auto __o = this->thiz<Scheduler *>();
	if (__o)
	{
		__o->setTimeScale(timeScale);
	}
}

int QtScriptScheduler::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptScheduler::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptScheduler::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new Scheduler();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Scheduler constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptMeshVertexAttrib::QtScriptMeshVertexAttrib(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<MeshVertexAttrib, false>(engine, className)
{
}

QtScriptMeshVertexAttrib::QtScriptMeshVertexAttrib(QScriptEngine *engine)
	: QtScriptMeshVertexAttrib(engine, "MeshVertexAttrib")
{
}

void QtScriptMeshVertexAttrib::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<MeshVertexAttrib, QtScriptMeshVertexAttrib>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptMeshVertexAttrib::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMeshVertexAttrib::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMeshVertexAttrib::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::MeshVertexAttrib constructor");
	return false;
}

int QtScriptMeshVertexAttrib::getAttribSizeBytes()
{
	auto __o = this->thiz<MeshVertexAttrib *>();
	if (__o)
	{
		return __o->getAttribSizeBytes();
	}
	return 0;
}

int QtScriptMeshVertexAttrib::_public_field_get_type() const
{
	auto object = thiz<MeshVertexAttrib *>();
	if (object)
	{
		return int(object->type);
	}
	return static_cast<int>(0);
}

void QtScriptMeshVertexAttrib::_public_field_set_type(int value)
{
	auto object = thiz<MeshVertexAttrib *>();
	if (object)
	{
		object->type = cocos2d::backend::VertexFormat(value);
	}
}

int QtScriptMeshVertexAttrib::_public_field_get_vertexAttrib() const
{
	auto object = thiz<MeshVertexAttrib *>();
	if (object)
	{
		return int(object->vertexAttrib);
	}
	return static_cast<int>(0);
}

void QtScriptMeshVertexAttrib::_public_field_set_vertexAttrib(int value)
{
	auto object = thiz<MeshVertexAttrib *>();
	if (object)
	{
		object->vertexAttrib = cocos2d::shaderinfos::VertexKey(value);
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptAnimation3D::QtScriptAnimation3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptAnimation3D::QtScriptAnimation3D(QScriptEngine *engine)
	: QtScriptAnimation3D(engine, "Animation3D")
{
}

void QtScriptAnimation3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Animation3D, QtScriptAnimation3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAnimation3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithBundle", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAnimation3D::createWithBundle)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

float QtScriptAnimation3D::getDuration()
{
	auto __o = this->thiz<Animation3D *>();
	if (__o)
	{
		return __o->getDuration();
	}
	return static_cast<float>(0);
}

bool QtScriptAnimation3D::initWithBundle(cocos2d::Bundle3D* bundle, const QByteArray& animationName)
{
	auto __o = this->thiz<Animation3D *>();
	if (__o)
	{
		return __o->initWithBundle(bundle, animationName.toStdString());
	}
	return false;
}

bool QtScriptAnimation3D::initWithFile(const QByteArray& filename, const QByteArray& animationName)
{
	auto __o = this->thiz<Animation3D *>();
	if (__o)
	{
		return __o->initWithFile(filename.toStdString(), animationName.toStdString());
	}
	return false;
}

QScriptValue QtScriptAnimation3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(Animation3D::create(arg0));
		}
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			return __e->toScriptValue(Animation3D::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Animation3D::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptAnimation3D::createWithBundle(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Bundle3D*>(context->argument(0));
			return __e->toScriptValue(Animation3D::createWithBundle(arg0));
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Bundle3D*>(context->argument(0));
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			return __e->toScriptValue(Animation3D::createWithBundle(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Animation3D::createWithBundle");
	return __e->uncaughtException();
}

int QtScriptAnimation3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAnimation3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptAnimation3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new Animation3D();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Animation3D constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptAnimation3DCache::QtScriptAnimation3DCache(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Animation3DCache *, true>(engine, className)
{
}

QtScriptAnimation3DCache::QtScriptAnimation3DCache(QScriptEngine *engine)
	: QtScriptAnimation3DCache(engine, "Animation3DCache")
{
}

void QtScriptAnimation3DCache::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	QScriptValue inherit;
	auto ctor = RegisterT<Animation3DCache, QtScriptAnimation3DCache>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("destroyInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAnimation3DCache::destroyInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAnimation3DCache::getInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptAnimation3DCache::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAnimation3DCache::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptAnimation3DCache::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Animation3DCache");
	return false;
}

void QtScriptAnimation3DCache::addAnimation(const QByteArray& key, cocos2d::Animation3D* animation)
{
	auto __o = this->thiz<Animation3DCache *>();
	if (__o)
	{
		__o->addAnimation(key.toStdString(), animation);
	}
}

cocos2d::Animation3D* QtScriptAnimation3DCache::getAnimation(const QByteArray& key)
{
	auto __o = this->thiz<Animation3DCache *>();
	if (__o)
	{
		return __o->getAnimation(key.toStdString());
	}
	return nullptr;
}

void QtScriptAnimation3DCache::removeAllAnimations()
{
	auto __o = this->thiz<Animation3DCache *>();
	if (__o)
	{
		__o->removeAllAnimations();
	}
}

void QtScriptAnimation3DCache::removeAnimation(const QByteArray& key)
{
	auto __o = this->thiz<Animation3DCache *>();
	if (__o)
	{
		__o->removeAnimation(key.toStdString());
	}
}

void QtScriptAnimation3DCache::removeUnusedAnimations()
{
	auto __o = this->thiz<Animation3DCache *>();
	if (__o)
	{
		__o->removeUnusedAnimations();
	}
}

QScriptValue QtScriptAnimation3DCache::destroyInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			Animation3DCache::destroyInstance();
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Animation3DCache::destroyInstance");
	return __e->uncaughtException();
}

QScriptValue QtScriptAnimation3DCache::getInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Animation3DCache::getInstance());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Animation3DCache::getInstance");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptAction::QtScriptAction(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptAction::QtScriptAction(QScriptEngine *engine)
	: QtScriptAction(engine, "Action")
{
}

void QtScriptAction::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Action, QtScriptAction>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptAction::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAction::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptAction::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Action");
	return false;
}

cocos2d::Action* QtScriptAction::clone()
{
	auto __o = this->thiz<Action *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

QByteArray QtScriptAction::description()
{
	auto __o = this->thiz<Action *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->description());
	}
	return QByteArray();
}

unsigned int QtScriptAction::getFlags()
{
	auto __o = this->thiz<Action *>();
	if (__o)
	{
		return __o->getFlags();
	}
	return static_cast<unsigned int>(0);
}

cocos2d::Node* QtScriptAction::getOriginalTarget()
{
	auto __o = this->thiz<Action *>();
	if (__o)
	{
		return __o->getOriginalTarget();
	}
	return nullptr;
}

int QtScriptAction::getTag()
{
	auto __o = this->thiz<Action *>();
	if (__o)
	{
		return __o->getTag();
	}
	return 0;
}

cocos2d::Node* QtScriptAction::getTarget()
{
	auto __o = this->thiz<Action *>();
	if (__o)
	{
		return __o->getTarget();
	}
	return nullptr;
}

bool QtScriptAction::isDone()
{
	auto __o = this->thiz<Action *>();
	if (__o)
	{
		return __o->isDone();
	}
	return false;
}

cocos2d::Action* QtScriptAction::reverse()
{
	auto __o = this->thiz<Action *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptAction::setFlags(unsigned int flags)
{
	auto __o = this->thiz<Action *>();
	if (__o)
	{
		__o->setFlags(flags);
	}
}

void QtScriptAction::setTag(int tag)
{
	auto __o = this->thiz<Action *>();
	if (__o)
	{
		__o->setTag(tag);
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptFiniteTimeAction::QtScriptFiniteTimeAction(QScriptEngine *engine, const QByteArray &className)
	: QtScriptAction(engine, className)
{
}

QtScriptFiniteTimeAction::QtScriptFiniteTimeAction(QScriptEngine *engine)
	: QtScriptFiniteTimeAction(engine, "FiniteTimeAction")
{
}

void QtScriptFiniteTimeAction::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Action *>());
	auto ctor = RegisterT<FiniteTimeAction, QtScriptFiniteTimeAction>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptFiniteTimeAction::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFiniteTimeAction::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFiniteTimeAction::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::FiniteTimeAction");
	return false;
}

cocos2d::FiniteTimeAction* QtScriptFiniteTimeAction::clone()
{
	auto __o = this->thiz<FiniteTimeAction *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptFiniteTimeAction::getDuration()
{
	auto __o = this->thiz<FiniteTimeAction *>();
	if (__o)
	{
		return __o->getDuration();
	}
	return static_cast<float>(0);
}

cocos2d::FiniteTimeAction* QtScriptFiniteTimeAction::reverse()
{
	auto __o = this->thiz<FiniteTimeAction *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptFiniteTimeAction::setDuration(float duration)
{
	auto __o = this->thiz<FiniteTimeAction *>();
	if (__o)
	{
		__o->setDuration(duration);
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptSpeed::QtScriptSpeed(QScriptEngine *engine, const QByteArray &className)
	: QtScriptAction(engine, className)
{
}

QtScriptSpeed::QtScriptSpeed(QScriptEngine *engine)
	: QtScriptSpeed(engine, "Speed")
{
}

void QtScriptSpeed::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Action *>());
	auto ctor = RegisterT<Speed, QtScriptSpeed>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSpeed::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSpeed::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSpeed::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSpeed::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Speed");
	return false;
}

cocos2d::Speed* QtScriptSpeed::clone()
{
	auto __o = this->thiz<Speed *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionInterval* QtScriptSpeed::getInnerAction()
{
	auto __o = this->thiz<Speed *>();
	if (__o)
	{
		return __o->getInnerAction();
	}
	return nullptr;
}

float QtScriptSpeed::getSpeed()
{
	auto __o = this->thiz<Speed *>();
	if (__o)
	{
		return __o->getSpeed();
	}
	return static_cast<float>(0);
}

bool QtScriptSpeed::initWithAction(cocos2d::ActionInterval* action, float speed)
{
	auto __o = this->thiz<Speed *>();
	if (__o)
	{
		return __o->initWithAction(action, speed);
	}
	return false;
}

cocos2d::Speed* QtScriptSpeed::reverse()
{
	auto __o = this->thiz<Speed *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptSpeed::setInnerAction(cocos2d::ActionInterval* action)
{
	auto __o = this->thiz<Speed *>();
	if (__o)
	{
		__o->setInnerAction(action);
	}
}

void QtScriptSpeed::setSpeed(float speed)
{
	auto __o = this->thiz<Speed *>();
	if (__o)
	{
		__o->setSpeed(speed);
	}
}

QScriptValue QtScriptSpeed::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(Speed::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Speed::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptFollow::QtScriptFollow(QScriptEngine *engine, const QByteArray &className)
	: QtScriptAction(engine, className)
{
}

QtScriptFollow::QtScriptFollow(QScriptEngine *engine)
	: QtScriptFollow(engine, "Follow")
{
}

void QtScriptFollow::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Action *>());
	auto ctor = RegisterT<Follow, QtScriptFollow>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFollow::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithOffset", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFollow::createWithOffset)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptFollow::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFollow::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFollow::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Follow");
	return false;
}

cocos2d::Follow* QtScriptFollow::clone()
{
	auto __o = this->thiz<Follow *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptFollow::initWithTarget(cocos2d::Node* followedNode)
{
	auto __o = this->thiz<Follow *>();
	if (__o)
	{
		return __o->initWithTarget(followedNode);
	}
	return false;
}

bool QtScriptFollow::initWithTarget(cocos2d::Node* followedNode, const cocos2d::Rect& rect)
{
	auto __o = this->thiz<Follow *>();
	if (__o)
	{
		return __o->initWithTarget(followedNode, rect);
	}
	return false;
}

bool QtScriptFollow::initWithTargetAndOffset(cocos2d::Node* followedNode, float xOffset, float yOffset)
{
	auto __o = this->thiz<Follow *>();
	if (__o)
	{
		return __o->initWithTargetAndOffset(followedNode, xOffset, yOffset);
	}
	return false;
}

bool QtScriptFollow::initWithTargetAndOffset(cocos2d::Node* followedNode, float xOffset, float yOffset, const cocos2d::Rect& rect)
{
	auto __o = this->thiz<Follow *>();
	if (__o)
	{
		return __o->initWithTargetAndOffset(followedNode, xOffset, yOffset, rect);
	}
	return false;
}

bool QtScriptFollow::isBoundarySet()
{
	auto __o = this->thiz<Follow *>();
	if (__o)
	{
		return __o->isBoundarySet();
	}
	return false;
}

cocos2d::Follow* QtScriptFollow::reverse()
{
	auto __o = this->thiz<Follow *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptFollow::setBoundarySet(bool value)
{
	auto __o = this->thiz<Follow *>();
	if (__o)
	{
		__o->setBoundarySet(value);
	}
}

QScriptValue QtScriptFollow::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Node*>(context->argument(0));
			return __e->toScriptValue(Follow::create(arg0));
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Node*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Rect>(context->argument(1));
			return __e->toScriptValue(Follow::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Follow::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptFollow::createWithOffset(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 3, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 3:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Node*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(Follow::createWithOffset(arg0, arg1, arg2));
		}
		case 4:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Node*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Rect>(context->argument(3));
			return __e->toScriptValue(Follow::createWithOffset(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Follow::createWithOffset");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptImage::QtScriptImage(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptImage::QtScriptImage(QScriptEngine *engine)
	: QtScriptImage(engine, "Image")
{
}

void QtScriptImage::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Image, QtScriptImage>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("setPNGPremultipliedAlphaEnabled", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptImage::setPNGPremultipliedAlphaEnabled)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("setPVRImagesHavePremultipliedAlpha", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptImage::setPVRImagesHavePremultipliedAlpha)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptImage::getBitPerPixel()
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return __o->getBitPerPixel();
	}
	return 0;
}

QByteArray QtScriptImage::getData()
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return QByteArray::fromRawData(reinterpret_cast<char*>(__o->getData()), int(__o->getDataLen()));
	}
	return QByteArray();
}

int QtScriptImage::getDataLen()
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return int(__o->getDataLen());
	}
	return 0;
}

QByteArray QtScriptImage::getFilePath()
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getFilePath());
	}
	return QByteArray();
}

int QtScriptImage::getFileType()
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return int(__o->getFileType());
	}
	return 0;
}

int QtScriptImage::getHeight()
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return __o->getHeight();
	}
	return 0;
}

int QtScriptImage::getNumberOfMipmaps()
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return __o->getNumberOfMipmaps();
	}
	return 0;
}

int QtScriptImage::getPixelFormat()
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return int(__o->getPixelFormat());
	}
	return 0;
}

int QtScriptImage::getWidth()
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return __o->getWidth();
	}
	return 0;
}

bool QtScriptImage::hasAlpha()
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return __o->hasAlpha();
	}
	return false;
}

bool QtScriptImage::hasPremultipliedAlpha()
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return __o->hasPremultipliedAlpha();
	}
	return false;
}

bool QtScriptImage::initWithImageData(const QByteArray& arg0)
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return __o->initWithImageData(reinterpret_cast<const unsigned char*>(arg0.data()), arg0.size());
	}
	return false;
}

bool QtScriptImage::initWithImageFile(const QByteArray& path)
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return __o->initWithImageFile(path.toStdString());
	}
	return false;
}

bool QtScriptImage::initWithRawData(const QByteArray& arg0, int arg1, int arg2, int arg3, bool arg4)
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return __o->initWithRawData(reinterpret_cast<const unsigned char*>(arg0.data()), arg0.size(), arg1, arg2, arg3, arg4);
	}
	return false;
}

bool QtScriptImage::isCompressed()
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return __o->isCompressed();
	}
	return false;
}

void QtScriptImage::premultiplyAlpha()
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		__o->premultiplyAlpha();
	}
}

void QtScriptImage::reversePremultipliedAlpha()
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		__o->reversePremultipliedAlpha();
	}
}

bool QtScriptImage::saveToFile(const QByteArray& filename)
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return __o->saveToFile(filename.toStdString());
	}
	return false;
}

bool QtScriptImage::saveToFile(const QByteArray& filename, bool isToRGB)
{
	auto __o = this->thiz<Image *>();
	if (__o)
	{
		return __o->saveToFile(filename.toStdString(), isToRGB);
	}
	return false;
}

QScriptValue QtScriptImage::setPNGPremultipliedAlphaEnabled(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<bool>(context->argument(0));
			Image::setPNGPremultipliedAlphaEnabled(arg0);
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Image::setPNGPremultipliedAlphaEnabled");
	return __e->uncaughtException();
}

QScriptValue QtScriptImage::setPVRImagesHavePremultipliedAlpha(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<bool>(context->argument(0));
			Image::setPVRImagesHavePremultipliedAlpha(arg0);
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Image::setPVRImagesHavePremultipliedAlpha");
	return __e->uncaughtException();
}

int QtScriptImage::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptImage::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptImage::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new Image();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Image constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptSpriteFrame::QtScriptSpriteFrame(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptSpriteFrame::QtScriptSpriteFrame(QScriptEngine *engine)
	: QtScriptSpriteFrame(engine, "SpriteFrame")
{
}

void QtScriptSpriteFrame::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<SpriteFrame, QtScriptSpriteFrame>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSpriteFrame::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTexture", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSpriteFrame::createWithTexture)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSpriteFrame::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSpriteFrame::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSpriteFrame::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::SpriteFrame");
	return false;
}

cocos2d::SpriteFrame* QtScriptSpriteFrame::clone()
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::Vec2 QtScriptSpriteFrame::getAnchorPoint()
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->getAnchorPoint();
	}
	return cocos2d::Vec2();
}

cocos2d::Rect QtScriptSpriteFrame::getCenterRect()
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->getCenterRect();
	}
	return cocos2d::Rect();
}

cocos2d::Vec2 QtScriptSpriteFrame::getOffset()
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->getOffset();
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptSpriteFrame::getOffsetInPixels()
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->getOffsetInPixels();
	}
	return cocos2d::Vec2();
}

cocos2d::Size QtScriptSpriteFrame::getOriginalSize()
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->getOriginalSize();
	}
	return cocos2d::Size();
}

cocos2d::Size QtScriptSpriteFrame::getOriginalSizeInPixels()
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->getOriginalSizeInPixels();
	}
	return cocos2d::Size();
}

cocos2d::Rect QtScriptSpriteFrame::getRect()
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->getRect();
	}
	return cocos2d::Rect();
}

cocos2d::Rect QtScriptSpriteFrame::getRectInPixels()
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->getRectInPixels();
	}
	return cocos2d::Rect();
}

cocos2d::Texture2D* QtScriptSpriteFrame::getTexture()
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->getTexture();
	}
	return nullptr;
}

bool QtScriptSpriteFrame::hasAnchorPoint()
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->hasAnchorPoint();
	}
	return false;
}

bool QtScriptSpriteFrame::hasCenterRect()
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->hasCenterRect();
	}
	return false;
}

bool QtScriptSpriteFrame::hasPolygonInfo()
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->hasPolygonInfo();
	}
	return false;
}

bool QtScriptSpriteFrame::initWithTexture(cocos2d::Texture2D* pobTexture, const cocos2d::Rect& rect)
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->initWithTexture(pobTexture, rect);
	}
	return false;
}

bool QtScriptSpriteFrame::initWithTexture(cocos2d::Texture2D* pobTexture, const cocos2d::Rect& rect, bool rotated, const cocos2d::Vec2& offset, const cocos2d::Size& originalSize)
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->initWithTexture(pobTexture, rect, rotated, offset, originalSize);
	}
	return false;
}

bool QtScriptSpriteFrame::initWithTextureFilename(const QByteArray& filename, const cocos2d::Rect& rect)
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->initWithTextureFilename(filename.toStdString(), rect);
	}
	return false;
}

bool QtScriptSpriteFrame::initWithTextureFilename(const QByteArray& filename, const cocos2d::Rect& rect, bool rotated, const cocos2d::Vec2& offset, const cocos2d::Size& originalSize)
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->initWithTextureFilename(filename.toStdString(), rect, rotated, offset, originalSize);
	}
	return false;
}

bool QtScriptSpriteFrame::isRotated()
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		return __o->isRotated();
	}
	return false;
}

void QtScriptSpriteFrame::setAnchorPoint(const cocos2d::Vec2& anchorPoint)
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		__o->setAnchorPoint(anchorPoint);
	}
}

void QtScriptSpriteFrame::setCenterRectInPixels(const cocos2d::Rect& centerRect)
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		__o->setCenterRectInPixels(centerRect);
	}
}

void QtScriptSpriteFrame::setOffset(const cocos2d::Vec2& offsets)
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		__o->setOffset(offsets);
	}
}

void QtScriptSpriteFrame::setOffsetInPixels(const cocos2d::Vec2& offsetInPixels)
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		__o->setOffsetInPixels(offsetInPixels);
	}
}

void QtScriptSpriteFrame::setOriginalSize(const cocos2d::Size& sizeInPixels)
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		__o->setOriginalSize(sizeInPixels);
	}
}

void QtScriptSpriteFrame::setOriginalSizeInPixels(const cocos2d::Size& sizeInPixels)
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		__o->setOriginalSizeInPixels(sizeInPixels);
	}
}

void QtScriptSpriteFrame::setRect(const cocos2d::Rect& rect)
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		__o->setRect(rect);
	}
}

void QtScriptSpriteFrame::setRectInPixels(const cocos2d::Rect& rectInPixels)
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		__o->setRectInPixels(rectInPixels);
	}
}

void QtScriptSpriteFrame::setRotated(bool rotated)
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		__o->setRotated(rotated);
	}
}

void QtScriptSpriteFrame::setTexture(cocos2d::Texture2D* pobTexture)
{
	auto __o = this->thiz<SpriteFrame *>();
	if (__o)
	{
		__o->setTexture(pobTexture);
	}
}

QScriptValue QtScriptSpriteFrame::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 5))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<cocos2d::Rect>(context->argument(1));
			return __e->toScriptValue(SpriteFrame::create(arg0, arg1));
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			break;
		}
		case 5:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<cocos2d::Rect>(context->argument(1));
			auto arg2 = qscriptvalue_cast<bool>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(3));
			auto arg4 = qscriptvalue_cast<cocos2d::Size>(context->argument(4));
			return __e->toScriptValue(SpriteFrame::create(arg0, arg1, arg2, arg3, arg4));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::SpriteFrame::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptSpriteFrame::createWithTexture(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 5))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Rect>(context->argument(1));
			return __e->toScriptValue(SpriteFrame::createWithTexture(arg0, arg1));
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			break;
		}
		case 5:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Rect>(context->argument(1));
			auto arg2 = qscriptvalue_cast<bool>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(3));
			auto arg4 = qscriptvalue_cast<cocos2d::Size>(context->argument(4));
			return __e->toScriptValue(SpriteFrame::createWithTexture(arg0, arg1, arg2, arg3, arg4));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::SpriteFrame::createWithTexture");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptAnimationFrame::QtScriptAnimationFrame(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptAnimationFrame::QtScriptAnimationFrame(QScriptEngine *engine)
	: QtScriptAnimationFrame(engine, "AnimationFrame")
{
}

void QtScriptAnimationFrame::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<AnimationFrame, QtScriptAnimationFrame>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAnimationFrame::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptAnimationFrame::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAnimationFrame::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptAnimationFrame::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::AnimationFrame");
	return false;
}

cocos2d::AnimationFrame* QtScriptAnimationFrame::clone()
{
	auto __o = this->thiz<AnimationFrame *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptAnimationFrame::getDelayUnits()
{
	auto __o = this->thiz<AnimationFrame *>();
	if (__o)
	{
		return __o->getDelayUnits();
	}
	return static_cast<float>(0);
}

cocos2d::SpriteFrame* QtScriptAnimationFrame::getSpriteFrame()
{
	auto __o = this->thiz<AnimationFrame *>();
	if (__o)
	{
		return __o->getSpriteFrame();
	}
	return nullptr;
}

bool QtScriptAnimationFrame::initWithSpriteFrame(cocos2d::SpriteFrame* arg0, float arg1)
{
	auto __o = this->thiz<AnimationFrame *>();
	if (__o)
	{
		return __o->initWithSpriteFrame(arg0, arg1, ValueMap());
	}
	return false;
}

void QtScriptAnimationFrame::setDelayUnits(float delayUnits)
{
	auto __o = this->thiz<AnimationFrame *>();
	if (__o)
	{
		__o->setDelayUnits(delayUnits);
	}
}

void QtScriptAnimationFrame::setSpriteFrame(cocos2d::SpriteFrame* frame)
{
	auto __o = this->thiz<AnimationFrame *>();
	if (__o)
	{
		__o->setSpriteFrame(frame);
	}
}

QScriptValue QtScriptAnimationFrame::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::SpriteFrame*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(bool(AnimationFrame::create(arg0, arg1, ValueMap())));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::AnimationFrame::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptAnimation::QtScriptAnimation(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptAnimation::QtScriptAnimation(QScriptEngine *engine)
	: QtScriptAnimation(engine, "Animation")
{
}

void QtScriptAnimation::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Animation, QtScriptAnimation>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAnimation::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithSpriteFrames", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAnimation::createWithSpriteFrames)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptAnimation::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAnimation::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptAnimation::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Animation");
	return false;
}

void QtScriptAnimation::addSpriteFrame(cocos2d::SpriteFrame* frame)
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		__o->addSpriteFrame(frame);
	}
}

void QtScriptAnimation::addSpriteFrameWithFile(const QByteArray& filename)
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		__o->addSpriteFrameWithFile(filename.toStdString());
	}
}

void QtScriptAnimation::addSpriteFrameWithTexture(cocos2d::Texture2D* pobTexture, const cocos2d::Rect& rect)
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		__o->addSpriteFrameWithTexture(pobTexture, rect);
	}
}

cocos2d::Animation* QtScriptAnimation::clone()
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptAnimation::getDelayPerUnit()
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		return __o->getDelayPerUnit();
	}
	return static_cast<float>(0);
}

float QtScriptAnimation::getDuration()
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		return __o->getDuration();
	}
	return static_cast<float>(0);
}

cocos2d::Vector<cocos2d::AnimationFrame *> QtScriptAnimation::getFrames()
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		return __o->getFrames();
	}
	return cocos2d::Vector<cocos2d::AnimationFrame *>();
}

unsigned int QtScriptAnimation::getLoops()
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		return __o->getLoops();
	}
	return static_cast<unsigned int>(0);
}

bool QtScriptAnimation::getRestoreOriginalFrame()
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		return __o->getRestoreOriginalFrame();
	}
	return false;
}

float QtScriptAnimation::getTotalDelayUnits()
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		return __o->getTotalDelayUnits();
	}
	return static_cast<float>(0);
}

bool QtScriptAnimation::init()
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		return __o->init();
	}
	return false;
}

bool QtScriptAnimation::initWithAnimationFrames(const cocos2d::Vector<cocos2d::AnimationFrame *>& arrayOfAnimationFrameNames, float delayPerUnit, unsigned int loops)
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		return __o->initWithAnimationFrames(arrayOfAnimationFrameNames, delayPerUnit, loops);
	}
	return false;
}

bool QtScriptAnimation::initWithSpriteFrames(const cocos2d::Vector<cocos2d::SpriteFrame *>& arrayOfSpriteFrameNames)
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		return __o->initWithSpriteFrames(arrayOfSpriteFrameNames);
	}
	return false;
}

bool QtScriptAnimation::initWithSpriteFrames(const cocos2d::Vector<cocos2d::SpriteFrame *>& arrayOfSpriteFrameNames, float delay)
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		return __o->initWithSpriteFrames(arrayOfSpriteFrameNames, delay);
	}
	return false;
}

bool QtScriptAnimation::initWithSpriteFrames(const cocos2d::Vector<cocos2d::SpriteFrame *>& arrayOfSpriteFrameNames, float delay, unsigned int loops)
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		return __o->initWithSpriteFrames(arrayOfSpriteFrameNames, delay, loops);
	}
	return false;
}

void QtScriptAnimation::setDelayPerUnit(float delayPerUnit)
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		__o->setDelayPerUnit(delayPerUnit);
	}
}

void QtScriptAnimation::setFrames(const cocos2d::Vector<cocos2d::AnimationFrame *>& frames)
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		__o->setFrames(frames);
	}
}

void QtScriptAnimation::setLoops(unsigned int loops)
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		__o->setLoops(loops);
	}
}

void QtScriptAnimation::setRestoreOriginalFrame(bool restoreOriginalFrame)
{
	auto __o = this->thiz<Animation *>();
	if (__o)
	{
		__o->setRestoreOriginalFrame(restoreOriginalFrame);
	}
}

QScriptValue QtScriptAnimation::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Animation::create());
		}
		case 1:
		{
			break;
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vector<cocos2d::AnimationFrame *>>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(Animation::create(arg0, arg1));
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vector<cocos2d::AnimationFrame *>>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<unsigned int>(context->argument(2));
			return __e->toScriptValue(Animation::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Animation::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptAnimation::createWithSpriteFrames(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vector<cocos2d::SpriteFrame *>>(context->argument(0));
			return __e->toScriptValue(Animation::createWithSpriteFrames(arg0));
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vector<cocos2d::SpriteFrame *>>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(Animation::createWithSpriteFrames(arg0, arg1));
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vector<cocos2d::SpriteFrame *>>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<unsigned int>(context->argument(2));
			return __e->toScriptValue(Animation::createWithSpriteFrames(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Animation::createWithSpriteFrames");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptActionInterval::QtScriptActionInterval(QScriptEngine *engine, const QByteArray &className)
	: QtScriptFiniteTimeAction(engine, className)
{
}

QtScriptActionInterval::QtScriptActionInterval(QScriptEngine *engine)
	: QtScriptActionInterval(engine, "ActionInterval")
{
}

void QtScriptActionInterval::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<FiniteTimeAction *>());
	auto ctor = RegisterT<ActionInterval, QtScriptActionInterval>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptActionInterval::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptActionInterval::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptActionInterval::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ActionInterval");
	return false;
}

cocos2d::ActionInterval* QtScriptActionInterval::clone()
{
	auto __o = this->thiz<ActionInterval *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptActionInterval::getAmplitudeRate()
{
	auto __o = this->thiz<ActionInterval *>();
	if (__o)
	{
		return __o->getAmplitudeRate();
	}
	return static_cast<float>(0);
}

float QtScriptActionInterval::getElapsed()
{
	auto __o = this->thiz<ActionInterval *>();
	if (__o)
	{
		return __o->getElapsed();
	}
	return static_cast<float>(0);
}

bool QtScriptActionInterval::initWithDuration(float d)
{
	auto __o = this->thiz<ActionInterval *>();
	if (__o)
	{
		return __o->initWithDuration(d);
	}
	return false;
}

cocos2d::ActionInterval* QtScriptActionInterval::reverse()
{
	auto __o = this->thiz<ActionInterval *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptActionInterval::setAmplitudeRate(float amp)
{
	auto __o = this->thiz<ActionInterval *>();
	if (__o)
	{
		__o->setAmplitudeRate(amp);
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptSequence::QtScriptSequence(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptSequence::QtScriptSequence(QScriptEngine *engine)
	: QtScriptSequence(engine, "Sequence")
{
}

void QtScriptSequence::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<Sequence, QtScriptSequence>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSequence::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTwoActions", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSequence::createWithTwoActions)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSequence::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSequence::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSequence::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Sequence");
	return false;
}

cocos2d::Sequence* QtScriptSequence::clone()
{
	auto __o = this->thiz<Sequence *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptSequence::init(const cocos2d::Vector<cocos2d::FiniteTimeAction *>& arrayOfActions)
{
	auto __o = this->thiz<Sequence *>();
	if (__o)
	{
		return __o->init(arrayOfActions);
	}
	return false;
}

bool QtScriptSequence::initWithTwoActions(cocos2d::FiniteTimeAction* pActionOne, cocos2d::FiniteTimeAction* pActionTwo)
{
	auto __o = this->thiz<Sequence *>();
	if (__o)
	{
		return __o->initWithTwoActions(pActionOne, pActionTwo);
	}
	return false;
}

cocos2d::Sequence* QtScriptSequence::reverse()
{
	auto __o = this->thiz<Sequence *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptSequence::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vector<cocos2d::FiniteTimeAction *>>(context->argument(0));
			return __e->toScriptValue(Sequence::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sequence::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptSequence::createWithTwoActions(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::FiniteTimeAction*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::FiniteTimeAction*>(context->argument(1));
			return __e->toScriptValue(Sequence::createWithTwoActions(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sequence::createWithTwoActions");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptRepeat::QtScriptRepeat(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptRepeat::QtScriptRepeat(QScriptEngine *engine)
	: QtScriptRepeat(engine, "Repeat")
{
}

void QtScriptRepeat::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<Repeat, QtScriptRepeat>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptRepeat::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptRepeat::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptRepeat::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptRepeat::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Repeat");
	return false;
}

cocos2d::Repeat* QtScriptRepeat::clone()
{
	auto __o = this->thiz<Repeat *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::FiniteTimeAction* QtScriptRepeat::getInnerAction()
{
	auto __o = this->thiz<Repeat *>();
	if (__o)
	{
		return __o->getInnerAction();
	}
	return nullptr;
}

bool QtScriptRepeat::initWithAction(cocos2d::FiniteTimeAction* pAction, unsigned int times)
{
	auto __o = this->thiz<Repeat *>();
	if (__o)
	{
		return __o->initWithAction(pAction, times);
	}
	return false;
}

cocos2d::Repeat* QtScriptRepeat::reverse()
{
	auto __o = this->thiz<Repeat *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptRepeat::setInnerAction(cocos2d::FiniteTimeAction* action)
{
	auto __o = this->thiz<Repeat *>();
	if (__o)
	{
		__o->setInnerAction(action);
	}
}

QScriptValue QtScriptRepeat::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::FiniteTimeAction*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<unsigned int>(context->argument(1));
			return __e->toScriptValue(Repeat::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Repeat::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptRepeatForever::QtScriptRepeatForever(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptRepeatForever::QtScriptRepeatForever(QScriptEngine *engine)
	: QtScriptRepeatForever(engine, "RepeatForever")
{
}

void QtScriptRepeatForever::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<RepeatForever, QtScriptRepeatForever>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptRepeatForever::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptRepeatForever::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptRepeatForever::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptRepeatForever::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::RepeatForever");
	return false;
}

cocos2d::RepeatForever* QtScriptRepeatForever::clone()
{
	auto __o = this->thiz<RepeatForever *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionInterval* QtScriptRepeatForever::getInnerAction()
{
	auto __o = this->thiz<RepeatForever *>();
	if (__o)
	{
		return __o->getInnerAction();
	}
	return nullptr;
}

bool QtScriptRepeatForever::initWithAction(cocos2d::ActionInterval* action)
{
	auto __o = this->thiz<RepeatForever *>();
	if (__o)
	{
		return __o->initWithAction(action);
	}
	return false;
}

cocos2d::RepeatForever* QtScriptRepeatForever::reverse()
{
	auto __o = this->thiz<RepeatForever *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptRepeatForever::setInnerAction(cocos2d::ActionInterval* action)
{
	auto __o = this->thiz<RepeatForever *>();
	if (__o)
	{
		__o->setInnerAction(action);
	}
}

QScriptValue QtScriptRepeatForever::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(RepeatForever::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::RepeatForever::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptSpawn::QtScriptSpawn(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptSpawn::QtScriptSpawn(QScriptEngine *engine)
	: QtScriptSpawn(engine, "Spawn")
{
}

void QtScriptSpawn::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<Spawn, QtScriptSpawn>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSpawn::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTwoActions", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSpawn::createWithTwoActions)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSpawn::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSpawn::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSpawn::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Spawn");
	return false;
}

cocos2d::Spawn* QtScriptSpawn::clone()
{
	auto __o = this->thiz<Spawn *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptSpawn::init(const cocos2d::Vector<cocos2d::FiniteTimeAction *>& arrayOfActions)
{
	auto __o = this->thiz<Spawn *>();
	if (__o)
	{
		return __o->init(arrayOfActions);
	}
	return false;
}

bool QtScriptSpawn::initWithTwoActions(cocos2d::FiniteTimeAction* action1, cocos2d::FiniteTimeAction* action2)
{
	auto __o = this->thiz<Spawn *>();
	if (__o)
	{
		return __o->initWithTwoActions(action1, action2);
	}
	return false;
}

cocos2d::Spawn* QtScriptSpawn::reverse()
{
	auto __o = this->thiz<Spawn *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptSpawn::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vector<cocos2d::FiniteTimeAction *>>(context->argument(0));
			return __e->toScriptValue(Spawn::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Spawn::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptSpawn::createWithTwoActions(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::FiniteTimeAction*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::FiniteTimeAction*>(context->argument(1));
			return __e->toScriptValue(Spawn::createWithTwoActions(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Spawn::createWithTwoActions");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptRotateTo::QtScriptRotateTo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptRotateTo::QtScriptRotateTo(QScriptEngine *engine)
	: QtScriptRotateTo(engine, "RotateTo")
{
}

void QtScriptRotateTo::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<RotateTo, QtScriptRotateTo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptRotateTo::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptRotateTo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptRotateTo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptRotateTo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::RotateTo");
	return false;
}

cocos2d::RotateTo* QtScriptRotateTo::clone()
{
	auto __o = this->thiz<RotateTo *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptRotateTo::initWithDuration(float duration, const cocos2d::Vec3& dstAngle3D)
{
	auto __o = this->thiz<RotateTo *>();
	if (__o)
	{
		return __o->initWithDuration(duration, dstAngle3D);
	}
	return false;
}

bool QtScriptRotateTo::initWithDuration(float duration, float dstAngleX, float dstAngleY)
{
	auto __o = this->thiz<RotateTo *>();
	if (__o)
	{
		return __o->initWithDuration(duration, dstAngleX, dstAngleY);
	}
	return false;
}

cocos2d::RotateTo* QtScriptRotateTo::reverse()
{
	auto __o = this->thiz<RotateTo *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptRotateTo::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(RotateTo::create(arg0, arg1));
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(RotateTo::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::RotateTo::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptRotateBy::QtScriptRotateBy(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptRotateBy::QtScriptRotateBy(QScriptEngine *engine)
	: QtScriptRotateBy(engine, "RotateBy")
{
}

void QtScriptRotateBy::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<RotateBy, QtScriptRotateBy>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptRotateBy::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptRotateBy::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptRotateBy::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptRotateBy::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::RotateBy");
	return false;
}

cocos2d::RotateBy* QtScriptRotateBy::clone()
{
	auto __o = this->thiz<RotateBy *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptRotateBy::initWithDuration(float duration, float deltaAngle)
{
	auto __o = this->thiz<RotateBy *>();
	if (__o)
	{
		return __o->initWithDuration(duration, deltaAngle);
	}
	return false;
}

bool QtScriptRotateBy::initWithDuration(float duration, float deltaAngleZ_X, float deltaAngleZ_Y)
{
	auto __o = this->thiz<RotateBy *>();
	if (__o)
	{
		return __o->initWithDuration(duration, deltaAngleZ_X, deltaAngleZ_Y);
	}
	return false;
}

cocos2d::RotateBy* QtScriptRotateBy::reverse()
{
	auto __o = this->thiz<RotateBy *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptRotateBy::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(RotateBy::create(arg0, arg1));
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(RotateBy::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::RotateBy::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptMoveBy::QtScriptMoveBy(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptMoveBy::QtScriptMoveBy(QScriptEngine *engine)
	: QtScriptMoveBy(engine, "MoveBy")
{
}

void QtScriptMoveBy::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<MoveBy, QtScriptMoveBy>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMoveBy::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptMoveBy::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMoveBy::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMoveBy::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::MoveBy");
	return false;
}

cocos2d::MoveBy* QtScriptMoveBy::clone()
{
	auto __o = this->thiz<MoveBy *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptMoveBy::initWithDuration(float duration, const cocos2d::Vec2& deltaPosition)
{
	auto __o = this->thiz<MoveBy *>();
	if (__o)
	{
		return __o->initWithDuration(duration, deltaPosition);
	}
	return false;
}

cocos2d::MoveBy* QtScriptMoveBy::reverse()
{
	auto __o = this->thiz<MoveBy *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptMoveBy::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(1));
			return __e->toScriptValue(MoveBy::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MoveBy::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptMoveTo::QtScriptMoveTo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptMoveBy(engine, className)
{
}

QtScriptMoveTo::QtScriptMoveTo(QScriptEngine *engine)
	: QtScriptMoveTo(engine, "MoveTo")
{
}

void QtScriptMoveTo::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<MoveBy *>());
	auto ctor = RegisterT<MoveTo, QtScriptMoveTo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMoveTo::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptMoveTo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMoveTo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMoveTo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::MoveTo");
	return false;
}

cocos2d::MoveTo* QtScriptMoveTo::clone()
{
	auto __o = this->thiz<MoveTo *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptMoveTo::initWithDuration(float duration, const cocos2d::Vec2& position)
{
	auto __o = this->thiz<MoveTo *>();
	if (__o)
	{
		return __o->initWithDuration(duration, position);
	}
	return false;
}

cocos2d::MoveTo* QtScriptMoveTo::reverse()
{
	auto __o = this->thiz<MoveTo *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptMoveTo::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(1));
			return __e->toScriptValue(MoveTo::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MoveTo::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptSkewTo::QtScriptSkewTo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptSkewTo::QtScriptSkewTo(QScriptEngine *engine)
	: QtScriptSkewTo(engine, "SkewTo")
{
}

void QtScriptSkewTo::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<SkewTo, QtScriptSkewTo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSkewTo::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSkewTo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSkewTo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSkewTo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::SkewTo");
	return false;
}

cocos2d::SkewTo* QtScriptSkewTo::clone()
{
	auto __o = this->thiz<SkewTo *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptSkewTo::initWithDuration(float t, float sx, float sy)
{
	auto __o = this->thiz<SkewTo *>();
	if (__o)
	{
		return __o->initWithDuration(t, sx, sy);
	}
	return false;
}

cocos2d::SkewTo* QtScriptSkewTo::reverse()
{
	auto __o = this->thiz<SkewTo *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptSkewTo::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 3, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 3:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(SkewTo::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::SkewTo::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptSkewBy::QtScriptSkewBy(QScriptEngine *engine, const QByteArray &className)
	: QtScriptSkewTo(engine, className)
{
}

QtScriptSkewBy::QtScriptSkewBy(QScriptEngine *engine)
	: QtScriptSkewBy(engine, "SkewBy")
{
}

void QtScriptSkewBy::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<SkewTo *>());
	auto ctor = RegisterT<SkewBy, QtScriptSkewBy>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSkewBy::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSkewBy::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSkewBy::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSkewBy::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::SkewBy");
	return false;
}

cocos2d::SkewBy* QtScriptSkewBy::clone()
{
	auto __o = this->thiz<SkewBy *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptSkewBy::initWithDuration(float t, float sx, float sy)
{
	auto __o = this->thiz<SkewBy *>();
	if (__o)
	{
		return __o->initWithDuration(t, sx, sy);
	}
	return false;
}

cocos2d::SkewBy* QtScriptSkewBy::reverse()
{
	auto __o = this->thiz<SkewBy *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptSkewBy::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 3, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 3:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(SkewBy::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::SkewBy::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptResizeTo::QtScriptResizeTo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptResizeTo::QtScriptResizeTo(QScriptEngine *engine)
	: QtScriptResizeTo(engine, "ResizeTo")
{
}

void QtScriptResizeTo::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<ResizeTo, QtScriptResizeTo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptResizeTo::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptResizeTo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptResizeTo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptResizeTo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ResizeTo");
	return false;
}

cocos2d::ResizeTo* QtScriptResizeTo::clone()
{
	auto __o = this->thiz<ResizeTo *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptResizeTo::initWithDuration(float duration, const cocos2d::Size& final_size)
{
	auto __o = this->thiz<ResizeTo *>();
	if (__o)
	{
		return __o->initWithDuration(duration, final_size);
	}
	return false;
}

QScriptValue QtScriptResizeTo::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			return __e->toScriptValue(ResizeTo::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ResizeTo::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptResizeBy::QtScriptResizeBy(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptResizeBy::QtScriptResizeBy(QScriptEngine *engine)
	: QtScriptResizeBy(engine, "ResizeBy")
{
}

void QtScriptResizeBy::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<ResizeBy, QtScriptResizeBy>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptResizeBy::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptResizeBy::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptResizeBy::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptResizeBy::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ResizeBy");
	return false;
}

cocos2d::ResizeBy* QtScriptResizeBy::clone()
{
	auto __o = this->thiz<ResizeBy *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptResizeBy::initWithDuration(float duration, const cocos2d::Size& deltaSize)
{
	auto __o = this->thiz<ResizeBy *>();
	if (__o)
	{
		return __o->initWithDuration(duration, deltaSize);
	}
	return false;
}

cocos2d::ResizeBy* QtScriptResizeBy::reverse()
{
	auto __o = this->thiz<ResizeBy *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptResizeBy::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			return __e->toScriptValue(ResizeBy::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ResizeBy::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptJumpBy::QtScriptJumpBy(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptJumpBy::QtScriptJumpBy(QScriptEngine *engine)
	: QtScriptJumpBy(engine, "JumpBy")
{
}

void QtScriptJumpBy::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<JumpBy, QtScriptJumpBy>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptJumpBy::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptJumpBy::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptJumpBy::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptJumpBy::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::JumpBy");
	return false;
}

cocos2d::JumpBy* QtScriptJumpBy::clone()
{
	auto __o = this->thiz<JumpBy *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptJumpBy::initWithDuration(float duration, const cocos2d::Vec2& position, float height, int jumps)
{
	auto __o = this->thiz<JumpBy *>();
	if (__o)
	{
		return __o->initWithDuration(duration, position, height, jumps);
	}
	return false;
}

cocos2d::JumpBy* QtScriptJumpBy::reverse()
{
	auto __o = this->thiz<JumpBy *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptJumpBy::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<int>(context->argument(3));
			return __e->toScriptValue(JumpBy::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::JumpBy::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptJumpTo::QtScriptJumpTo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptJumpBy(engine, className)
{
}

QtScriptJumpTo::QtScriptJumpTo(QScriptEngine *engine)
	: QtScriptJumpTo(engine, "JumpTo")
{
}

void QtScriptJumpTo::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<JumpBy *>());
	auto ctor = RegisterT<JumpTo, QtScriptJumpTo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptJumpTo::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptJumpTo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptJumpTo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptJumpTo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::JumpTo");
	return false;
}

cocos2d::JumpTo* QtScriptJumpTo::clone()
{
	auto __o = this->thiz<JumpTo *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptJumpTo::initWithDuration(float duration, const cocos2d::Vec2& position, float height, int jumps)
{
	auto __o = this->thiz<JumpTo *>();
	if (__o)
	{
		return __o->initWithDuration(duration, position, height, jumps);
	}
	return false;
}

cocos2d::JumpTo* QtScriptJumpTo::reverse()
{
	auto __o = this->thiz<JumpTo *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptJumpTo::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<int>(context->argument(3));
			return __e->toScriptValue(JumpTo::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::JumpTo::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptBezierConfig::QtScriptBezierConfig(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<_ccBezierConfig, false>(engine, className)
{
}

QtScriptBezierConfig::QtScriptBezierConfig(QScriptEngine *engine)
	: QtScriptBezierConfig(engine, "BezierConfig")
{
}

void QtScriptBezierConfig::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<_ccBezierConfig, QtScriptBezierConfig>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptBezierConfig::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptBezierConfig::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptBezierConfig::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::_ccBezierConfig constructor");
	return false;
}

cocos2d::Vec2 QtScriptBezierConfig::_public_field_get_controlPoint_1() const
{
	auto object = thiz<_ccBezierConfig *>();
	if (object)
	{
		return object->controlPoint_1;
	}
	return cocos2d::Vec2();
}

void QtScriptBezierConfig::_public_field_set_controlPoint_1(const cocos2d::Vec2& value)
{
	auto object = thiz<_ccBezierConfig *>();
	if (object)
	{
		object->controlPoint_1 = value;
	}
}

cocos2d::Vec2 QtScriptBezierConfig::_public_field_get_controlPoint_2() const
{
	auto object = thiz<_ccBezierConfig *>();
	if (object)
	{
		return object->controlPoint_2;
	}
	return cocos2d::Vec2();
}

void QtScriptBezierConfig::_public_field_set_controlPoint_2(const cocos2d::Vec2& value)
{
	auto object = thiz<_ccBezierConfig *>();
	if (object)
	{
		object->controlPoint_2 = value;
	}
}

cocos2d::Vec2 QtScriptBezierConfig::_public_field_get_endPosition() const
{
	auto object = thiz<_ccBezierConfig *>();
	if (object)
	{
		return object->endPosition;
	}
	return cocos2d::Vec2();
}

void QtScriptBezierConfig::_public_field_set_endPosition(const cocos2d::Vec2& value)
{
	auto object = thiz<_ccBezierConfig *>();
	if (object)
	{
		object->endPosition = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptBezierBy::QtScriptBezierBy(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptBezierBy::QtScriptBezierBy(QScriptEngine *engine)
	: QtScriptBezierBy(engine, "BezierBy")
{
}

void QtScriptBezierBy::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<BezierBy, QtScriptBezierBy>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptBezierBy::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptBezierBy::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptBezierBy::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptBezierBy::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::BezierBy");
	return false;
}

cocos2d::BezierBy* QtScriptBezierBy::clone()
{
	auto __o = this->thiz<BezierBy *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptBezierBy::initWithDuration(float t, const cocos2d::_ccBezierConfig& c)
{
	auto __o = this->thiz<BezierBy *>();
	if (__o)
	{
		return __o->initWithDuration(t, c);
	}
	return false;
}

cocos2d::BezierBy* QtScriptBezierBy::reverse()
{
	auto __o = this->thiz<BezierBy *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptBezierBy::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::_ccBezierConfig>(context->argument(1));
			return __e->toScriptValue(BezierBy::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::BezierBy::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptBezierTo::QtScriptBezierTo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBezierBy(engine, className)
{
}

QtScriptBezierTo::QtScriptBezierTo(QScriptEngine *engine)
	: QtScriptBezierTo(engine, "BezierTo")
{
}

void QtScriptBezierTo::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<BezierBy *>());
	auto ctor = RegisterT<BezierTo, QtScriptBezierTo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptBezierTo::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptBezierTo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptBezierTo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptBezierTo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::BezierTo");
	return false;
}

cocos2d::BezierTo* QtScriptBezierTo::clone()
{
	auto __o = this->thiz<BezierTo *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptBezierTo::initWithDuration(float t, const cocos2d::_ccBezierConfig& c)
{
	auto __o = this->thiz<BezierTo *>();
	if (__o)
	{
		return __o->initWithDuration(t, c);
	}
	return false;
}

cocos2d::BezierTo* QtScriptBezierTo::reverse()
{
	auto __o = this->thiz<BezierTo *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptBezierTo::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::_ccBezierConfig>(context->argument(1));
			return __e->toScriptValue(BezierTo::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::BezierTo::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptScaleTo::QtScriptScaleTo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptScaleTo::QtScriptScaleTo(QScriptEngine *engine)
	: QtScriptScaleTo(engine, "ScaleTo")
{
}

void QtScriptScaleTo::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<ScaleTo, QtScriptScaleTo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptScaleTo::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptScaleTo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptScaleTo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptScaleTo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ScaleTo");
	return false;
}

cocos2d::ScaleTo* QtScriptScaleTo::clone()
{
	auto __o = this->thiz<ScaleTo *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptScaleTo::initWithDuration(float duration, float s)
{
	auto __o = this->thiz<ScaleTo *>();
	if (__o)
	{
		return __o->initWithDuration(duration, s);
	}
	return false;
}

bool QtScriptScaleTo::initWithDuration(float duration, float sx, float sy)
{
	auto __o = this->thiz<ScaleTo *>();
	if (__o)
	{
		return __o->initWithDuration(duration, sx, sy);
	}
	return false;
}

bool QtScriptScaleTo::initWithDuration(float duration, float sx, float sy, float sz)
{
	auto __o = this->thiz<ScaleTo *>();
	if (__o)
	{
		return __o->initWithDuration(duration, sx, sy, sz);
	}
	return false;
}

cocos2d::ScaleTo* QtScriptScaleTo::reverse()
{
	auto __o = this->thiz<ScaleTo *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptScaleTo::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(ScaleTo::create(arg0, arg1));
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(ScaleTo::create(arg0, arg1, arg2));
		}
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			return __e->toScriptValue(ScaleTo::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ScaleTo::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptScaleBy::QtScriptScaleBy(QScriptEngine *engine, const QByteArray &className)
	: QtScriptScaleTo(engine, className)
{
}

QtScriptScaleBy::QtScriptScaleBy(QScriptEngine *engine)
	: QtScriptScaleBy(engine, "ScaleBy")
{
}

void QtScriptScaleBy::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ScaleTo *>());
	auto ctor = RegisterT<ScaleBy, QtScriptScaleBy>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptScaleBy::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptScaleBy::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptScaleBy::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptScaleBy::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ScaleBy");
	return false;
}

cocos2d::ScaleBy* QtScriptScaleBy::clone()
{
	auto __o = this->thiz<ScaleBy *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ScaleBy* QtScriptScaleBy::reverse()
{
	auto __o = this->thiz<ScaleBy *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptScaleBy::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(ScaleBy::create(arg0, arg1));
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(ScaleBy::create(arg0, arg1, arg2));
		}
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			return __e->toScriptValue(ScaleBy::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ScaleBy::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptBlink::QtScriptBlink(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptBlink::QtScriptBlink(QScriptEngine *engine)
	: QtScriptBlink(engine, "Blink")
{
}

void QtScriptBlink::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<Blink, QtScriptBlink>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptBlink::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptBlink::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptBlink::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptBlink::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Blink");
	return false;
}

cocos2d::Blink* QtScriptBlink::clone()
{
	auto __o = this->thiz<Blink *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptBlink::initWithDuration(float duration, int blinks)
{
	auto __o = this->thiz<Blink *>();
	if (__o)
	{
		return __o->initWithDuration(duration, blinks);
	}
	return false;
}

cocos2d::Blink* QtScriptBlink::reverse()
{
	auto __o = this->thiz<Blink *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptBlink::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<int>(context->argument(1));
			return __e->toScriptValue(Blink::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Blink::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptFadeTo::QtScriptFadeTo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptFadeTo::QtScriptFadeTo(QScriptEngine *engine)
	: QtScriptFadeTo(engine, "FadeTo")
{
}

void QtScriptFadeTo::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<FadeTo, QtScriptFadeTo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFadeTo::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptFadeTo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFadeTo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFadeTo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::FadeTo");
	return false;
}

cocos2d::FadeTo* QtScriptFadeTo::clone()
{
	auto __o = this->thiz<FadeTo *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptFadeTo::initWithDuration(float duration, quint8 opacity)
{
	auto __o = this->thiz<FadeTo *>();
	if (__o)
	{
		return __o->initWithDuration(duration, opacity);
	}
	return false;
}

cocos2d::FadeTo* QtScriptFadeTo::reverse()
{
	auto __o = this->thiz<FadeTo *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptFadeTo::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<quint8>(context->argument(1));
			return __e->toScriptValue(FadeTo::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FadeTo::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptFadeIn::QtScriptFadeIn(QScriptEngine *engine, const QByteArray &className)
	: QtScriptFadeTo(engine, className)
{
}

QtScriptFadeIn::QtScriptFadeIn(QScriptEngine *engine)
	: QtScriptFadeIn(engine, "FadeIn")
{
}

void QtScriptFadeIn::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<FadeTo *>());
	auto ctor = RegisterT<FadeIn, QtScriptFadeIn>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFadeIn::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptFadeIn::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFadeIn::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFadeIn::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::FadeIn");
	return false;
}

cocos2d::FadeIn* QtScriptFadeIn::clone()
{
	auto __o = this->thiz<FadeIn *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

void QtScriptFadeIn::setReverseAction(cocos2d::FadeTo* ac)
{
	auto __o = this->thiz<FadeIn *>();
	if (__o)
	{
		__o->setReverseAction(ac);
	}
}

QScriptValue QtScriptFadeIn::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			return __e->toScriptValue(FadeIn::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FadeIn::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptFadeOut::QtScriptFadeOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptFadeTo(engine, className)
{
}

QtScriptFadeOut::QtScriptFadeOut(QScriptEngine *engine)
	: QtScriptFadeOut(engine, "FadeOut")
{
}

void QtScriptFadeOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<FadeTo *>());
	auto ctor = RegisterT<FadeOut, QtScriptFadeOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFadeOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptFadeOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFadeOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFadeOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::FadeOut");
	return false;
}

cocos2d::FadeOut* QtScriptFadeOut::clone()
{
	auto __o = this->thiz<FadeOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

void QtScriptFadeOut::setReverseAction(cocos2d::FadeTo* ac)
{
	auto __o = this->thiz<FadeOut *>();
	if (__o)
	{
		__o->setReverseAction(ac);
	}
}

QScriptValue QtScriptFadeOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			return __e->toScriptValue(FadeOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FadeOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptTintTo::QtScriptTintTo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptTintTo::QtScriptTintTo(QScriptEngine *engine)
	: QtScriptTintTo(engine, "TintTo")
{
}

void QtScriptTintTo::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<TintTo, QtScriptTintTo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTintTo::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptTintTo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTintTo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTintTo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::TintTo");
	return false;
}

cocos2d::TintTo* QtScriptTintTo::clone()
{
	auto __o = this->thiz<TintTo *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptTintTo::initWithDuration(float duration, quint8 red, quint8 green, quint8 blue)
{
	auto __o = this->thiz<TintTo *>();
	if (__o)
	{
		return __o->initWithDuration(duration, red, green, blue);
	}
	return false;
}

cocos2d::TintTo* QtScriptTintTo::reverse()
{
	auto __o = this->thiz<TintTo *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptTintTo::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Color3B>(context->argument(1));
			return __e->toScriptValue(TintTo::create(arg0, arg1));
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<quint8>(context->argument(1));
			auto arg2 = qscriptvalue_cast<quint8>(context->argument(2));
			auto arg3 = qscriptvalue_cast<quint8>(context->argument(3));
			return __e->toScriptValue(TintTo::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::TintTo::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptTintBy::QtScriptTintBy(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptTintBy::QtScriptTintBy(QScriptEngine *engine)
	: QtScriptTintBy(engine, "TintBy")
{
}

void QtScriptTintBy::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<TintBy, QtScriptTintBy>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTintBy::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptTintBy::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTintBy::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTintBy::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::TintBy");
	return false;
}

cocos2d::TintBy* QtScriptTintBy::clone()
{
	auto __o = this->thiz<TintBy *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptTintBy::initWithDuration(float duration, qint16 deltaRed, qint16 deltaGreen, qint16 deltaBlue)
{
	auto __o = this->thiz<TintBy *>();
	if (__o)
	{
		return __o->initWithDuration(duration, deltaRed, deltaGreen, deltaBlue);
	}
	return false;
}

cocos2d::TintBy* QtScriptTintBy::reverse()
{
	auto __o = this->thiz<TintBy *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptTintBy::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<qint16>(context->argument(1));
			auto arg2 = qscriptvalue_cast<qint16>(context->argument(2));
			auto arg3 = qscriptvalue_cast<qint16>(context->argument(3));
			return __e->toScriptValue(TintBy::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::TintBy::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptDelayTime::QtScriptDelayTime(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptDelayTime::QtScriptDelayTime(QScriptEngine *engine)
	: QtScriptDelayTime(engine, "DelayTime")
{
}

void QtScriptDelayTime::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<DelayTime, QtScriptDelayTime>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptDelayTime::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptDelayTime::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptDelayTime::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptDelayTime::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::DelayTime");
	return false;
}

cocos2d::DelayTime* QtScriptDelayTime::clone()
{
	auto __o = this->thiz<DelayTime *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::DelayTime* QtScriptDelayTime::reverse()
{
	auto __o = this->thiz<DelayTime *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptDelayTime::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			return __e->toScriptValue(DelayTime::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::DelayTime::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptReverseTime::QtScriptReverseTime(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptReverseTime::QtScriptReverseTime(QScriptEngine *engine)
	: QtScriptReverseTime(engine, "ReverseTime")
{
}

void QtScriptReverseTime::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<ReverseTime, QtScriptReverseTime>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptReverseTime::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptReverseTime::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptReverseTime::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptReverseTime::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ReverseTime");
	return false;
}

cocos2d::ReverseTime* QtScriptReverseTime::clone()
{
	auto __o = this->thiz<ReverseTime *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptReverseTime::initWithAction(cocos2d::FiniteTimeAction* action)
{
	auto __o = this->thiz<ReverseTime *>();
	if (__o)
	{
		return __o->initWithAction(action);
	}
	return false;
}

cocos2d::ReverseTime* QtScriptReverseTime::reverse()
{
	auto __o = this->thiz<ReverseTime *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptReverseTime::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::FiniteTimeAction*>(context->argument(0));
			return __e->toScriptValue(ReverseTime::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ReverseTime::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptAnimate::QtScriptAnimate(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptAnimate::QtScriptAnimate(QScriptEngine *engine)
	: QtScriptAnimate(engine, "Animate")
{
}

void QtScriptAnimate::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<Animate, QtScriptAnimate>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAnimate::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptAnimate::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAnimate::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptAnimate::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Animate");
	return false;
}

cocos2d::Animate* QtScriptAnimate::clone()
{
	auto __o = this->thiz<Animate *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::Animation* QtScriptAnimate::getAnimation()
{
	auto __o = this->thiz<Animate *>();
	if (__o)
	{
		return __o->getAnimation();
	}
	return nullptr;
}

int QtScriptAnimate::getCurrentFrameIndex()
{
	auto __o = this->thiz<Animate *>();
	if (__o)
	{
		return __o->getCurrentFrameIndex();
	}
	return 0;
}

bool QtScriptAnimate::initWithAnimation(cocos2d::Animation* animation)
{
	auto __o = this->thiz<Animate *>();
	if (__o)
	{
		return __o->initWithAnimation(animation);
	}
	return false;
}

cocos2d::Animate* QtScriptAnimate::reverse()
{
	auto __o = this->thiz<Animate *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptAnimate::setAnimation(cocos2d::Animation* animation)
{
	auto __o = this->thiz<Animate *>();
	if (__o)
	{
		__o->setAnimation(animation);
	}
}

QScriptValue QtScriptAnimate::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Animation*>(context->argument(0));
			return __e->toScriptValue(Animate::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Animate::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptTargetedAction::QtScriptTargetedAction(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptTargetedAction::QtScriptTargetedAction(QScriptEngine *engine)
	: QtScriptTargetedAction(engine, "TargetedAction")
{
}

void QtScriptTargetedAction::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<TargetedAction, QtScriptTargetedAction>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTargetedAction::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptTargetedAction::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTargetedAction::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTargetedAction::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::TargetedAction");
	return false;
}

cocos2d::TargetedAction* QtScriptTargetedAction::clone()
{
	auto __o = this->thiz<TargetedAction *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::Node* QtScriptTargetedAction::getForcedTarget()
{
	auto __o = this->thiz<TargetedAction *>();
	if (__o)
	{
		return __o->getForcedTarget();
	}
	return nullptr;
}

bool QtScriptTargetedAction::initWithTarget(cocos2d::Node* target, cocos2d::FiniteTimeAction* action)
{
	auto __o = this->thiz<TargetedAction *>();
	if (__o)
	{
		return __o->initWithTarget(target, action);
	}
	return false;
}

cocos2d::TargetedAction* QtScriptTargetedAction::reverse()
{
	auto __o = this->thiz<TargetedAction *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptTargetedAction::setForcedTarget(cocos2d::Node* forcedTarget)
{
	auto __o = this->thiz<TargetedAction *>();
	if (__o)
	{
		__o->setForcedTarget(forcedTarget);
	}
}

QScriptValue QtScriptTargetedAction::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Node*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::FiniteTimeAction*>(context->argument(1));
			return __e->toScriptValue(TargetedAction::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::TargetedAction::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptActionFloat::QtScriptActionFloat(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptActionFloat::QtScriptActionFloat(QScriptEngine *engine)
	: QtScriptActionFloat(engine, "ActionFloat")
{
}

void QtScriptActionFloat::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<ActionFloat, QtScriptActionFloat>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptActionFloat::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptActionFloat::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptActionFloat::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptActionFloat::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ActionFloat");
	return false;
}

cocos2d::ActionFloat* QtScriptActionFloat::clone()
{
	auto __o = this->thiz<ActionFloat *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptActionFloat::initWithDuration(float duration, float from, float to, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<ActionFloat *>();
	if (__o)
	{
		return __o->initWithDuration(duration, from, to, !callback.isFunction() ? cocos2d::ActionFloat::ActionFloatCallback() : [=](float larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
	return false;
}

cocos2d::ActionFloat* QtScriptActionFloat::reverse()
{
	auto __o = this->thiz<ActionFloat *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptActionFloat::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto tmp_3 = context->argument(3);
			auto arg3 = !tmp_3.isFunction() ? cocos2d::ActionFloat::ActionFloatCallback() : [=](float larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	tmp_3.call(QScriptValue(), arguments);
};
			return __e->toScriptValue(ActionFloat::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ActionFloat::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptAnimate3D::QtScriptAnimate3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptAnimate3D::QtScriptAnimate3D(QScriptEngine *engine)
	: QtScriptAnimate3D(engine, "Animate3D")
{
}

void QtScriptAnimate3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<Animate3D, QtScriptAnimate3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAnimate3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithFrames", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAnimate3D::createWithFrames)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getTransitionTime", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAnimate3D::getTransitionTime)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("setTransitionTime", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAnimate3D::setTransitionTime)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptAnimate3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAnimate3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptAnimate3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Animate3D");
	return false;
}

cocos2d::Animate3D* QtScriptAnimate3D::clone()
{
	auto __o = this->thiz<Animate3D *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptAnimate3D::getOriginInterval()
{
	auto __o = this->thiz<Animate3D *>();
	if (__o)
	{
		return __o->getOriginInterval();
	}
	return static_cast<float>(0);
}

int QtScriptAnimate3D::getQuality()
{
	auto __o = this->thiz<Animate3D *>();
	if (__o)
	{
		return int(__o->getQuality());
	}
	return 0;
}

float QtScriptAnimate3D::getSpeed()
{
	auto __o = this->thiz<Animate3D *>();
	if (__o)
	{
		return __o->getSpeed();
	}
	return static_cast<float>(0);
}

float QtScriptAnimate3D::getWeight()
{
	auto __o = this->thiz<Animate3D *>();
	if (__o)
	{
		return __o->getWeight();
	}
	return static_cast<float>(0);
}

bool QtScriptAnimate3D::init(cocos2d::Animation3D* animation)
{
	auto __o = this->thiz<Animate3D *>();
	if (__o)
	{
		return __o->init(animation);
	}
	return false;
}

bool QtScriptAnimate3D::init(cocos2d::Animation3D* animation, float fromTime, float duration)
{
	auto __o = this->thiz<Animate3D *>();
	if (__o)
	{
		return __o->init(animation, fromTime, duration);
	}
	return false;
}

bool QtScriptAnimate3D::initWithFrames(cocos2d::Animation3D* animation, int startFrame, int endFrame, float frameRate)
{
	auto __o = this->thiz<Animate3D *>();
	if (__o)
	{
		return __o->initWithFrames(animation, startFrame, endFrame, frameRate);
	}
	return false;
}

void QtScriptAnimate3D::removeFromMap()
{
	auto __o = this->thiz<Animate3D *>();
	if (__o)
	{
		__o->removeFromMap();
	}
}

cocos2d::Animate3D* QtScriptAnimate3D::reverse()
{
	auto __o = this->thiz<Animate3D *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptAnimate3D::setOriginInterval(float interval)
{
	auto __o = this->thiz<Animate3D *>();
	if (__o)
	{
		__o->setOriginInterval(interval);
	}
}

void QtScriptAnimate3D::setQuality(int quality)
{
	auto __o = this->thiz<Animate3D *>();
	if (__o)
	{
		__o->setQuality(cocos2d::Animate3DQuality(quality));
	}
}

void QtScriptAnimate3D::setSpeed(float speed)
{
	auto __o = this->thiz<Animate3D *>();
	if (__o)
	{
		__o->setSpeed(speed);
	}
}

void QtScriptAnimate3D::setWeight(float weight)
{
	auto __o = this->thiz<Animate3D *>();
	if (__o)
	{
		__o->setWeight(weight);
	}
}

QScriptValue QtScriptAnimate3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Animation3D*>(context->argument(0));
			return __e->toScriptValue(Animate3D::create(arg0));
		}
		case 2:
		{
			break;
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Animation3D*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(Animate3D::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Animate3D::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptAnimate3D::createWithFrames(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 3, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 3:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Animation3D*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<int>(context->argument(1));
			auto arg2 = qscriptvalue_cast<int>(context->argument(2));
			return __e->toScriptValue(Animate3D::createWithFrames(arg0, arg1, arg2));
		}
		case 4:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Animation3D*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<int>(context->argument(1));
			auto arg2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			return __e->toScriptValue(Animate3D::createWithFrames(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Animate3D::createWithFrames");
	return __e->uncaughtException();
}

QScriptValue QtScriptAnimate3D::getTransitionTime(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Animate3D::getTransitionTime());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Animate3D::getTransitionTime");
	return __e->uncaughtException();
}

QScriptValue QtScriptAnimate3D::setTransitionTime(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			Animate3D::setTransitionTime(arg0);
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Animate3D::setTransitionTime");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptConfiguration::QtScriptConfiguration(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptConfiguration::QtScriptConfiguration(QScriptEngine *engine)
	: QtScriptConfiguration(engine, "Configuration")
{
}

void QtScriptConfiguration::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Configuration, QtScriptConfiguration>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("destroyInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptConfiguration::destroyInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptConfiguration::getInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptConfiguration::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptConfiguration::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptConfiguration::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Configuration");
	return false;
}

bool QtScriptConfiguration::checkForGLExtension(const QByteArray& searchName)
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->checkForGLExtension(searchName.toStdString());
	}
	return false;
}

void QtScriptConfiguration::gatherGPUInfo()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		__o->gatherGPUInfo();
	}
}

int QtScriptConfiguration::getAnimate3DQuality()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return int(__o->getAnimate3DQuality());
	}
	return 0;
}

QByteArray QtScriptConfiguration::getInfo()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getInfo());
	}
	return QByteArray();
}

int QtScriptConfiguration::getMaxAttributes()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->getMaxAttributes();
	}
	return 0;
}

int QtScriptConfiguration::getMaxModelviewStackDepth()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->getMaxModelviewStackDepth();
	}
	return 0;
}

int QtScriptConfiguration::getMaxSupportDirLightInShader()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->getMaxSupportDirLightInShader();
	}
	return 0;
}

int QtScriptConfiguration::getMaxSupportPointLightInShader()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->getMaxSupportPointLightInShader();
	}
	return 0;
}

int QtScriptConfiguration::getMaxSupportSpotLightInShader()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->getMaxSupportSpotLightInShader();
	}
	return 0;
}

int QtScriptConfiguration::getMaxTextureSize()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->getMaxTextureSize();
	}
	return 0;
}

int QtScriptConfiguration::getMaxTextureUnits()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->getMaxTextureUnits();
	}
	return 0;
}

cocos2d::Value QtScriptConfiguration::getValue(const QByteArray& key)
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->getValue(key.toStdString());
	}
	return cocos2d::Value();
}

cocos2d::Value QtScriptConfiguration::getValue(const QByteArray& key, const cocos2d::Value& defaultValue)
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->getValue(key.toStdString(), defaultValue);
	}
	return cocos2d::Value();
}

bool QtScriptConfiguration::init()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->init();
	}
	return false;
}

void QtScriptConfiguration::loadConfigFile(const QByteArray& filename)
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		__o->loadConfigFile(filename.toStdString());
	}
}

void QtScriptConfiguration::setValue(const QByteArray& key, const cocos2d::Value& value)
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		__o->setValue(key.toStdString(), value);
	}
}

bool QtScriptConfiguration::supportsATITC()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->supportsATITC();
	}
	return false;
}

bool QtScriptConfiguration::supportsBGRA8888()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->supportsBGRA8888();
	}
	return false;
}

bool QtScriptConfiguration::supportsDiscardFramebuffer()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->supportsDiscardFramebuffer();
	}
	return false;
}

bool QtScriptConfiguration::supportsETC()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->supportsETC();
	}
	return false;
}

bool QtScriptConfiguration::supportsMapBuffer()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->supportsMapBuffer();
	}
	return false;
}

bool QtScriptConfiguration::supportsNPOT()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->supportsNPOT();
	}
	return false;
}

bool QtScriptConfiguration::supportsOESDepth24()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->supportsOESDepth24();
	}
	return false;
}

bool QtScriptConfiguration::supportsOESPackedDepthStencil()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->supportsOESPackedDepthStencil();
	}
	return false;
}

bool QtScriptConfiguration::supportsPVRTC()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->supportsPVRTC();
	}
	return false;
}

bool QtScriptConfiguration::supportsS3TC()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->supportsS3TC();
	}
	return false;
}

bool QtScriptConfiguration::supportsShareableVAO()
{
	auto __o = this->thiz<Configuration *>();
	if (__o)
	{
		return __o->supportsShareableVAO();
	}
	return false;
}

QScriptValue QtScriptConfiguration::destroyInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			Configuration::destroyInstance();
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Configuration::destroyInstance");
	return __e->uncaughtException();
}

QScriptValue QtScriptConfiguration::getInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Configuration::getInstance());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Configuration::getInstance");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptData::QtScriptData(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Data, false>(engine, className)
{
}

QtScriptData::QtScriptData(QScriptEngine *engine)
	: QtScriptData(engine, "Data")
{
}

void QtScriptData::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<Data, QtScriptData>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

void QtScriptData::clear()
{
	auto __o = this->thiz<Data *>();
	if (__o)
	{
		__o->clear();
	}
}

int QtScriptData::copy(const QByteArray& arg0)
{
	auto __o = this->thiz<Data *>();
	if (__o)
	{
		return int(__o->copy(reinterpret_cast<const unsigned char*>(arg0.data()), arg0.size()));
	}
	return 0;
}

QByteArray QtScriptData::getBytes()
{
	auto __o = this->thiz<Data *>();
	if (__o)
	{
		return QByteArray::fromRawData(reinterpret_cast<char*>(__o->getBytes()), int(__o->getSize()));
	}
	return QByteArray();
}

int QtScriptData::getSize()
{
	auto __o = this->thiz<Data *>();
	if (__o)
	{
		return int(__o->getSize());
	}
	return 0;
}

bool QtScriptData::isNull()
{
	auto __o = this->thiz<Data *>();
	if (__o)
	{
		return __o->isNull();
	}
	return false;
}

void QtScriptData::set(const cocos2d::Data& other)
{
	auto __o = this->thiz<Data *>();
	if (__o)
	{
		__o->operator=(other);
	}
}

int QtScriptData::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptData::constructorArgumentCountMax() const
{
	return 1;
}

bool QtScriptData::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Data>(context->argument(0));
			out = Data(arg0);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Data constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptFileUtils::QtScriptFileUtils(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<FileUtils *, false>(engine, className)
{
}

QtScriptFileUtils::QtScriptFileUtils(QScriptEngine *engine)
	: QtScriptFileUtils(engine, "FileUtils")
{
}

void QtScriptFileUtils::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	QScriptValue inherit;
	auto ctor = RegisterT<FileUtils, QtScriptFileUtils>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("destroyInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFileUtils::destroyInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFileUtils::getInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptFileUtils::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFileUtils::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFileUtils::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::FileUtils");
	return false;
}

void QtScriptFileUtils::addSearchPath(const QByteArray& path)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->addSearchPath(path.toStdString());
	}
}

void QtScriptFileUtils::addSearchPath(const QByteArray& path, const bool front)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->addSearchPath(path.toStdString(), front);
	}
}

void QtScriptFileUtils::addSearchResolutionsOrder(const QByteArray& order)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->addSearchResolutionsOrder(order.toStdString());
	}
}

void QtScriptFileUtils::addSearchResolutionsOrder(const QByteArray& order, const bool front)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->addSearchResolutionsOrder(order.toStdString(), front);
	}
}

bool QtScriptFileUtils::createDirectory(const QByteArray& dirPath)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->createDirectory(dirPath.toStdString());
	}
	return false;
}

void QtScriptFileUtils::createDirectory(const QByteArray& dirPath, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->createDirectory(dirPath.toStdString(), !callback.isFunction() ? std::function<void (bool)>() : [=](bool larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

QByteArray QtScriptFileUtils::fullPathForFilename(const QByteArray& filename)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->fullPathForFilename(filename.toStdString()));
	}
	return QByteArray();
}

QByteArray QtScriptFileUtils::fullPathFromRelativeFile(const QByteArray& filename, const QByteArray& relativeFile)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->fullPathFromRelativeFile(filename.toStdString(), relativeFile.toStdString()));
	}
	return QByteArray();
}

cocos2d::Data QtScriptFileUtils::getDataFromFile(const QByteArray& filename)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->getDataFromFile(filename.toStdString());
	}
	return cocos2d::Data();
}

void QtScriptFileUtils::getDataFromFile(const QByteArray& filename, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->getDataFromFile(filename.toStdString(), !callback.isFunction() ? std::function<void (cocos2d::Data)>() : [=](cocos2d::Data larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

QByteArray QtScriptFileUtils::getDefaultResourceRootPath()
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getDefaultResourceRootPath());
	}
	return QByteArray();
}

cocos2d::Data QtScriptFileUtils::getFileDataFromZip(const QByteArray& zipFilePath, const QByteArray& filename)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->getFileDataFromZip(zipFilePath.toStdString(), filename.toStdString());
	}
	return cocos2d::Data();
}

QByteArray QtScriptFileUtils::getFileExtension(const QByteArray& filePath)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getFileExtension(filePath.toStdString()));
	}
	return QByteArray();
}

long QtScriptFileUtils::getFileSize(const QByteArray& filepath)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->getFileSize(filepath.toStdString());
	}
	return static_cast<long>(0);
}

void QtScriptFileUtils::getFileSize(const QByteArray& filepath, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->getFileSize(filepath.toStdString(), !callback.isFunction() ? std::function<void (long)>() : [=](long larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

std::vector<std::string> QtScriptFileUtils::getOriginalSearchPaths()
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->getOriginalSearchPaths();
	}
	return std::vector<std::string>();
}

std::vector<std::string> QtScriptFileUtils::getSearchPaths()
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->getSearchPaths();
	}
	return std::vector<std::string>();
}

std::vector<std::string> QtScriptFileUtils::getSearchResolutionsOrder()
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->getSearchResolutionsOrder();
	}
	return std::vector<std::string>();
}

QByteArray QtScriptFileUtils::getStringFromFile(const QByteArray& filename)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getStringFromFile(filename.toStdString()));
	}
	return QByteArray();
}

void QtScriptFileUtils::getStringFromFile(const QByteArray& path, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->getStringFromFile(path.toStdString(), !callback.isFunction() ? std::function<void (std::string)>() : [=](std::string larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(QByteArray::fromStdString(larg0));
	callback.call(QScriptValue(), arguments);
});
	}
}

QByteArray QtScriptFileUtils::getWritablePath()
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getWritablePath());
	}
	return QByteArray();
}

bool QtScriptFileUtils::isAbsolutePath(const QByteArray& path)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->isAbsolutePath(path.toStdString());
	}
	return false;
}

bool QtScriptFileUtils::isDirectoryExist(const QByteArray& dirPath)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->isDirectoryExist(dirPath.toStdString());
	}
	return false;
}

void QtScriptFileUtils::isDirectoryExist(const QByteArray& fullPath, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->isDirectoryExist(fullPath.toStdString(), !callback.isFunction() ? std::function<void (bool)>() : [=](bool larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

bool QtScriptFileUtils::isFileExist(const QByteArray& filename)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->isFileExist(filename.toStdString());
	}
	return false;
}

void QtScriptFileUtils::isFileExist(const QByteArray& filename, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->isFileExist(filename.toStdString(), !callback.isFunction() ? std::function<void (bool)>() : [=](bool larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

bool QtScriptFileUtils::isPopupNotify()
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->isPopupNotify();
	}
	return false;
}

std::vector<std::string> QtScriptFileUtils::listFiles(const QByteArray& dirPath)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->listFiles(dirPath.toStdString());
	}
	return std::vector<std::string>();
}

void QtScriptFileUtils::listFilesAsync(const QByteArray& dirPath, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->listFilesAsync(dirPath.toStdString(), !callback.isFunction() ? std::function<void (std::vector<std::string>)>() : [=](std::vector<std::string> larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

void QtScriptFileUtils::listFilesRecursively(const QByteArray& dirPath, std::vector<std::string>* files)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->listFilesRecursively(dirPath.toStdString(), files);
	}
}

void QtScriptFileUtils::listFilesRecursivelyAsync(const QByteArray& dirPath, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->listFilesRecursivelyAsync(dirPath.toStdString(), !callback.isFunction() ? std::function<void (std::vector<std::string>)>() : [=](std::vector<std::string> larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

void QtScriptFileUtils::loadFilenameLookupDictionaryFromFile(const QByteArray& filename)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->loadFilenameLookupDictionaryFromFile(filename.toStdString());
	}
}

void QtScriptFileUtils::purgeCachedEntries()
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->purgeCachedEntries();
	}
}

bool QtScriptFileUtils::removeDirectory(const QByteArray& dirPath)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->removeDirectory(dirPath.toStdString());
	}
	return false;
}

void QtScriptFileUtils::removeDirectory(const QByteArray& dirPath, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->removeDirectory(dirPath.toStdString(), !callback.isFunction() ? std::function<void (bool)>() : [=](bool larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

bool QtScriptFileUtils::removeFile(const QByteArray& filepath)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->removeFile(filepath.toStdString());
	}
	return false;
}

void QtScriptFileUtils::removeFile(const QByteArray& filepath, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->removeFile(filepath.toStdString(), !callback.isFunction() ? std::function<void (bool)>() : [=](bool larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

bool QtScriptFileUtils::renameFile(const QByteArray& oldfullpath, const QByteArray& newfullpath)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->renameFile(oldfullpath.toStdString(), newfullpath.toStdString());
	}
	return false;
}

bool QtScriptFileUtils::renameFile(const QByteArray& path, const QByteArray& oldname, const QByteArray& name)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->renameFile(path.toStdString(), oldname.toStdString(), name.toStdString());
	}
	return false;
}

void QtScriptFileUtils::renameFile(const QByteArray& path, const QByteArray& oldname, const QByteArray& name, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->renameFile(path.toStdString(), oldname.toStdString(), name.toStdString(), !callback.isFunction() ? std::function<void (bool)>() : [=](bool larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

void QtScriptFileUtils::setDefaultResourceRootPath(const QByteArray& path)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->setDefaultResourceRootPath(path.toStdString());
	}
}

void QtScriptFileUtils::setPopupNotify(bool notify)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->setPopupNotify(notify);
	}
}

void QtScriptFileUtils::setSearchPaths(const std::vector<std::string>& searchPaths)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->setSearchPaths(searchPaths);
	}
}

void QtScriptFileUtils::setSearchResolutionsOrder(const std::vector<std::string>& searchResolutionsOrder)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->setSearchResolutionsOrder(searchResolutionsOrder);
	}
}

void QtScriptFileUtils::setWritablePath(const QByteArray& writablePath)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->setWritablePath(writablePath.toStdString());
	}
}

bool QtScriptFileUtils::writeDataToFile(const cocos2d::Data& data, const QByteArray& fullPath)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->writeDataToFile(data, fullPath.toStdString());
	}
	return false;
}

void QtScriptFileUtils::writeDataToFile(cocos2d::Data data, const QByteArray& fullPath, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->writeDataToFile(data, fullPath.toStdString(), !callback.isFunction() ? std::function<void (bool)>() : [=](bool larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

bool QtScriptFileUtils::writeStringToFile(const QByteArray& dataStr, const QByteArray& fullPath)
{
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		return __o->writeStringToFile(dataStr.toStdString(), fullPath.toStdString());
	}
	return false;
}

void QtScriptFileUtils::writeStringToFile(QByteArray dataStr, const QByteArray& fullPath, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<FileUtils *>();
	if (__o)
	{
		__o->writeStringToFile(dataStr.toStdString(), fullPath.toStdString(), !callback.isFunction() ? std::function<void (bool)>() : [=](bool larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

QScriptValue QtScriptFileUtils::destroyInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			FileUtils::destroyInstance();
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FileUtils::destroyInstance");
	return __e->uncaughtException();
}

QScriptValue QtScriptFileUtils::getInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(FileUtils::getInstance());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FileUtils::getInstance");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptZipFile::QtScriptZipFile(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<ZipFile *, false>(engine, className)
{
}

QtScriptZipFile::QtScriptZipFile(QScriptEngine *engine)
	: QtScriptZipFile(engine, "ZipFile")
{
}

void QtScriptZipFile::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<ZipFile, QtScriptZipFile>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

bool QtScriptZipFile::fileExists(const QByteArray& fileName)
{
	auto __o = this->thiz<ZipFile *>();
	if (__o)
	{
		return __o->fileExists(fileName.toStdString());
	}
	return false;
}

cocos2d::Data QtScriptZipFile::getFileData(const QByteArray& fileName)
{
	auto __o = this->thiz<ZipFile *>();
	if (__o)
	{
		return __o->getFileData(fileName.toStdString());
	}
	return cocos2d::Data();
}

QByteArray QtScriptZipFile::getFirstFilename()
{
	auto __o = this->thiz<ZipFile *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getFirstFilename());
	}
	return QByteArray();
}

QByteArray QtScriptZipFile::getNextFilename()
{
	auto __o = this->thiz<ZipFile *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getNextFilename());
	}
	return QByteArray();
}

bool QtScriptZipFile::initWithBuffer(const QByteArray& arg0)
{
	auto __o = this->thiz<ZipFile *>();
	if (__o)
	{
		return __o->initWithBuffer(arg0.data(), size_t(arg0.length()));
	}
	return false;
}

std::vector<std::string> QtScriptZipFile::listFiles(const QByteArray& pathname)
{
	auto __o = this->thiz<ZipFile *>();
	if (__o)
	{
		return __o->listFiles(pathname.toStdString());
	}
	return std::vector<std::string>();
}

bool QtScriptZipFile::setFilter(const QByteArray& filter)
{
	auto __o = this->thiz<ZipFile *>();
	if (__o)
	{
		return __o->setFilter(filter.toStdString());
	}
	return false;
}

int QtScriptZipFile::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptZipFile::constructorArgumentCountMax() const
{
	return 2;
}

bool QtScriptZipFile::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new ZipFile();
			ok = true;
			break;
		}
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			out = new ZipFile(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			out = new ZipFile(arg0, arg1);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::ZipFile constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptMathUtil::QtScriptMathUtil(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<MathUtil, false>(engine, className)
{
}

QtScriptMathUtil::QtScriptMathUtil(QScriptEngine *engine)
	: QtScriptMathUtil(engine, "MathUtil")
{
}

void QtScriptMathUtil::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	QScriptValue inherit;
	auto ctor = RegisterT<MathUtil, QtScriptMathUtil>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("lerp", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMathUtil::lerp)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("smoothed", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMathUtil::smoothed)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptMathUtil::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMathUtil::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMathUtil::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::MathUtil constructor");
	return false;
}

QScriptValue QtScriptMathUtil::lerp(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 3, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 3:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(MathUtil::lerp(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MathUtil::lerp");
	return __e->uncaughtException();
}

QScriptValue QtScriptMathUtil::smoothed(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 5))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			return __e->toScriptValue(MathUtil::smoothed(arg0, arg1, arg2, arg3));
		}
		case 5:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			auto arg4 = qscriptvalue_cast<float>(context->argument(4));
			return __e->toScriptValue(MathUtil::smoothed(arg0, arg1, arg2, arg3, arg4));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MathUtil::smoothed");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptActionCamera::QtScriptActionCamera(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptActionCamera::QtScriptActionCamera(QScriptEngine *engine)
	: QtScriptActionCamera(engine, "ActionCamera")
{
}

void QtScriptActionCamera::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<ActionCamera, QtScriptActionCamera>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptActionCamera::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptActionCamera::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptActionCamera::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ActionCamera");
	return false;
}

cocos2d::ActionCamera* QtScriptActionCamera::clone()
{
	auto __o = this->thiz<ActionCamera *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::Vec3 QtScriptActionCamera::getCenter()
{
	auto __o = this->thiz<ActionCamera *>();
	if (__o)
	{
		return __o->getCenter();
	}
	return cocos2d::Vec3();
}

cocos2d::Vec3 QtScriptActionCamera::getEye()
{
	auto __o = this->thiz<ActionCamera *>();
	if (__o)
	{
		return __o->getEye();
	}
	return cocos2d::Vec3();
}

cocos2d::Vec3 QtScriptActionCamera::getUp()
{
	auto __o = this->thiz<ActionCamera *>();
	if (__o)
	{
		return __o->getUp();
	}
	return cocos2d::Vec3();
}

cocos2d::ActionCamera* QtScriptActionCamera::reverse()
{
	auto __o = this->thiz<ActionCamera *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptActionCamera::setCenter(const cocos2d::Vec3& center)
{
	auto __o = this->thiz<ActionCamera *>();
	if (__o)
	{
		__o->setCenter(center);
	}
}

void QtScriptActionCamera::setEye(const cocos2d::Vec3& eye)
{
	auto __o = this->thiz<ActionCamera *>();
	if (__o)
	{
		__o->setEye(eye);
	}
}

void QtScriptActionCamera::setEye(float x, float y, float z)
{
	auto __o = this->thiz<ActionCamera *>();
	if (__o)
	{
		__o->setEye(x, y, z);
	}
}

void QtScriptActionCamera::setUp(const cocos2d::Vec3& up)
{
	auto __o = this->thiz<ActionCamera *>();
	if (__o)
	{
		__o->setUp(up);
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptSphericalRadius::QtScriptSphericalRadius(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<SphericalRadius, false>(engine, className)
{
}

QtScriptSphericalRadius::QtScriptSphericalRadius(QScriptEngine *engine)
	: QtScriptSphericalRadius(engine, "SphericalRadius")
{
}

void QtScriptSphericalRadius::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<SphericalRadius, QtScriptSphericalRadius>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptSphericalRadius::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSphericalRadius::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSphericalRadius::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::SphericalRadius constructor");
	return false;
}

float QtScriptSphericalRadius::_public_field_get_azimuth() const
{
	auto object = thiz<SphericalRadius *>();
	if (object)
	{
		return object->azimuth;
	}
	return static_cast<float>(0);
}

void QtScriptSphericalRadius::_public_field_set_azimuth(float value)
{
	auto object = thiz<SphericalRadius *>();
	if (object)
	{
		object->azimuth = value;
	}
}

float QtScriptSphericalRadius::_public_field_get_radius() const
{
	auto object = thiz<SphericalRadius *>();
	if (object)
	{
		return object->radius;
	}
	return static_cast<float>(0);
}

void QtScriptSphericalRadius::_public_field_set_radius(float value)
{
	auto object = thiz<SphericalRadius *>();
	if (object)
	{
		object->radius = value;
	}
}

float QtScriptSphericalRadius::_public_field_get_zenith() const
{
	auto object = thiz<SphericalRadius *>();
	if (object)
	{
		return object->zenith;
	}
	return static_cast<float>(0);
}

void QtScriptSphericalRadius::_public_field_set_zenith(float value)
{
	auto object = thiz<SphericalRadius *>();
	if (object)
	{
		object->zenith = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptOrbitCamera::QtScriptOrbitCamera(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionCamera(engine, className)
{
}

QtScriptOrbitCamera::QtScriptOrbitCamera(QScriptEngine *engine)
	: QtScriptOrbitCamera(engine, "OrbitCamera")
{
}

void QtScriptOrbitCamera::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionCamera *>());
	auto ctor = RegisterT<OrbitCamera, QtScriptOrbitCamera>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptOrbitCamera::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptOrbitCamera::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptOrbitCamera::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptOrbitCamera::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::OrbitCamera");
	return false;
}

cocos2d::OrbitCamera* QtScriptOrbitCamera::clone()
{
	auto __o = this->thiz<OrbitCamera *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::SphericalRadius QtScriptOrbitCamera::getSphericalRadius()
{
	auto __o = this->thiz<OrbitCamera *>();
	if (__o)
	{
		return __o->getSphericalRadius();
	}
	return cocos2d::SphericalRadius();
}

bool QtScriptOrbitCamera::initWithDuration(float t, float radius, float deltaRadius, float angleZ, float deltaAngleZ, float angleX, float deltaAngleX)
{
	auto __o = this->thiz<OrbitCamera *>();
	if (__o)
	{
		return __o->initWithDuration(t, radius, deltaRadius, angleZ, deltaAngleZ, angleX, deltaAngleX);
	}
	return false;
}

QScriptValue QtScriptOrbitCamera::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 7, 7))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 7:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			auto arg4 = qscriptvalue_cast<float>(context->argument(4));
			auto arg5 = qscriptvalue_cast<float>(context->argument(5));
			auto arg6 = qscriptvalue_cast<float>(context->argument(6));
			return __e->toScriptValue(OrbitCamera::create(arg0, arg1, arg2, arg3, arg4, arg5, arg6));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::OrbitCamera::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptPointArray::QtScriptPointArray(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptPointArray::QtScriptPointArray(QScriptEngine *engine)
	: QtScriptPointArray(engine, "PointArray")
{
}

void QtScriptPointArray::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<PointArray, QtScriptPointArray>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptPointArray::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptPointArray::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptPointArray::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptPointArray::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::PointArray");
	return false;
}

void QtScriptPointArray::append(const cocos2d::Vec2& controlPoint)
{
	auto __o = this->thiz<PointArray *>();
	if (__o)
	{
		__o->addControlPoint(controlPoint);
	}
}

cocos2d::Vec2 QtScriptPointArray::at(int index)
{
	auto __o = this->thiz<PointArray *>();
	if (__o)
	{
		return __o->getControlPointAtIndex(index);
	}
	return cocos2d::Vec2();
}

cocos2d::PointArray* QtScriptPointArray::clone()
{
	auto __o = this->thiz<PointArray *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

int QtScriptPointArray::count()
{
	auto __o = this->thiz<PointArray *>();
	if (__o)
	{
		return int(__o->count());
	}
	return 0;
}

bool QtScriptPointArray::initWithCapacity(int capacity)
{
	auto __o = this->thiz<PointArray *>();
	if (__o)
	{
		return __o->initWithCapacity(capacity);
	}
	return false;
}

void QtScriptPointArray::insert(const cocos2d::Vec2& controlPoint, int index)
{
	auto __o = this->thiz<PointArray *>();
	if (__o)
	{
		__o->insertControlPoint(controlPoint, index);
	}
}

void QtScriptPointArray::remove(int index)
{
	auto __o = this->thiz<PointArray *>();
	if (__o)
	{
		__o->removeControlPointAtIndex(index);
	}
}

void QtScriptPointArray::replace(const cocos2d::Vec2& controlPoint, int index)
{
	auto __o = this->thiz<PointArray *>();
	if (__o)
	{
		__o->replaceControlPoint(controlPoint, index);
	}
}

cocos2d::PointArray* QtScriptPointArray::reverse()
{
	auto __o = this->thiz<PointArray *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptPointArray::reverseInline()
{
	auto __o = this->thiz<PointArray *>();
	if (__o)
	{
		__o->reverseInline();
	}
}

QScriptValue QtScriptPointArray::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			return __e->toScriptValue(PointArray::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::PointArray::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptCardinalSplineTo::QtScriptCardinalSplineTo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptCardinalSplineTo::QtScriptCardinalSplineTo(QScriptEngine *engine)
	: QtScriptCardinalSplineTo(engine, "CardinalSplineTo")
{
}

void QtScriptCardinalSplineTo::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<CardinalSplineTo, QtScriptCardinalSplineTo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCardinalSplineTo::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptCardinalSplineTo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptCardinalSplineTo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptCardinalSplineTo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::CardinalSplineTo");
	return false;
}

cocos2d::CardinalSplineTo* QtScriptCardinalSplineTo::clone()
{
	auto __o = this->thiz<CardinalSplineTo *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::PointArray* QtScriptCardinalSplineTo::getPoints()
{
	auto __o = this->thiz<CardinalSplineTo *>();
	if (__o)
	{
		return __o->getPoints();
	}
	return nullptr;
}

bool QtScriptCardinalSplineTo::initWithDuration(float duration, cocos2d::PointArray* points, float tension)
{
	auto __o = this->thiz<CardinalSplineTo *>();
	if (__o)
	{
		return __o->initWithDuration(duration, points, tension);
	}
	return false;
}

cocos2d::CardinalSplineTo* QtScriptCardinalSplineTo::reverse()
{
	auto __o = this->thiz<CardinalSplineTo *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptCardinalSplineTo::setPoints(cocos2d::PointArray* points)
{
	auto __o = this->thiz<CardinalSplineTo *>();
	if (__o)
	{
		__o->setPoints(points);
	}
}

void QtScriptCardinalSplineTo::updatePosition(const cocos2d::Vec2& newPos)
{
	auto __o = this->thiz<CardinalSplineTo *>();
	if (__o)
	{
		__o->updatePosition(newPos);
	}
}

QScriptValue QtScriptCardinalSplineTo::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 3, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 3:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::PointArray*>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(CardinalSplineTo::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::CardinalSplineTo::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptCardinalSplineBy::QtScriptCardinalSplineBy(QScriptEngine *engine, const QByteArray &className)
	: QtScriptCardinalSplineTo(engine, className)
{
}

QtScriptCardinalSplineBy::QtScriptCardinalSplineBy(QScriptEngine *engine)
	: QtScriptCardinalSplineBy(engine, "CardinalSplineBy")
{
}

void QtScriptCardinalSplineBy::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<CardinalSplineTo *>());
	auto ctor = RegisterT<CardinalSplineBy, QtScriptCardinalSplineBy>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCardinalSplineBy::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptCardinalSplineBy::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptCardinalSplineBy::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptCardinalSplineBy::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::CardinalSplineBy");
	return false;
}

cocos2d::CardinalSplineBy* QtScriptCardinalSplineBy::clone()
{
	auto __o = this->thiz<CardinalSplineBy *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::CardinalSplineBy* QtScriptCardinalSplineBy::reverse()
{
	auto __o = this->thiz<CardinalSplineBy *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptCardinalSplineBy::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 3, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 3:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::PointArray*>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(CardinalSplineBy::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::CardinalSplineBy::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptCatmullRomTo::QtScriptCatmullRomTo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptCardinalSplineTo(engine, className)
{
}

QtScriptCatmullRomTo::QtScriptCatmullRomTo(QScriptEngine *engine)
	: QtScriptCatmullRomTo(engine, "CatmullRomTo")
{
}

void QtScriptCatmullRomTo::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<CardinalSplineTo *>());
	auto ctor = RegisterT<CatmullRomTo, QtScriptCatmullRomTo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCatmullRomTo::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptCatmullRomTo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptCatmullRomTo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptCatmullRomTo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::CatmullRomTo");
	return false;
}

cocos2d::CatmullRomTo* QtScriptCatmullRomTo::clone()
{
	auto __o = this->thiz<CatmullRomTo *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptCatmullRomTo::initWithDuration(float dt, cocos2d::PointArray* points)
{
	auto __o = this->thiz<CatmullRomTo *>();
	if (__o)
	{
		return __o->initWithDuration(dt, points);
	}
	return false;
}

cocos2d::CatmullRomTo* QtScriptCatmullRomTo::reverse()
{
	auto __o = this->thiz<CatmullRomTo *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptCatmullRomTo::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::PointArray*>(context->argument(1));
			return __e->toScriptValue(CatmullRomTo::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::CatmullRomTo::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptCatmullRomBy::QtScriptCatmullRomBy(QScriptEngine *engine, const QByteArray &className)
	: QtScriptCardinalSplineBy(engine, className)
{
}

QtScriptCatmullRomBy::QtScriptCatmullRomBy(QScriptEngine *engine)
	: QtScriptCatmullRomBy(engine, "CatmullRomBy")
{
}

void QtScriptCatmullRomBy::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<CardinalSplineBy *>());
	auto ctor = RegisterT<CatmullRomBy, QtScriptCatmullRomBy>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCatmullRomBy::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptCatmullRomBy::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptCatmullRomBy::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptCatmullRomBy::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::CatmullRomBy");
	return false;
}

cocos2d::CatmullRomBy* QtScriptCatmullRomBy::clone()
{
	auto __o = this->thiz<CatmullRomBy *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptCatmullRomBy::initWithDuration(float dt, cocos2d::PointArray* points)
{
	auto __o = this->thiz<CatmullRomBy *>();
	if (__o)
	{
		return __o->initWithDuration(dt, points);
	}
	return false;
}

cocos2d::CatmullRomBy* QtScriptCatmullRomBy::reverse()
{
	auto __o = this->thiz<CatmullRomBy *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptCatmullRomBy::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::PointArray*>(context->argument(1));
			return __e->toScriptValue(CatmullRomBy::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::CatmullRomBy::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptActionEase::QtScriptActionEase(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptActionEase::QtScriptActionEase(QScriptEngine *engine)
	: QtScriptActionEase(engine, "ActionEase")
{
}

void QtScriptActionEase::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<ActionEase, QtScriptActionEase>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptActionEase::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptActionEase::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptActionEase::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ActionEase");
	return false;
}

cocos2d::ActionInterval* QtScriptActionEase::getInnerAction()
{
	auto __o = this->thiz<ActionEase *>();
	if (__o)
	{
		return __o->getInnerAction();
	}
	return nullptr;
}

bool QtScriptActionEase::initWithAction(cocos2d::ActionInterval* action)
{
	auto __o = this->thiz<ActionEase *>();
	if (__o)
	{
		return __o->initWithAction(action);
	}
	return false;
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseRateAction::QtScriptEaseRateAction(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseRateAction::QtScriptEaseRateAction(QScriptEngine *engine)
	: QtScriptEaseRateAction(engine, "EaseRateAction")
{
}

void QtScriptEaseRateAction::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseRateAction, QtScriptEaseRateAction>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseRateAction::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseRateAction::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseRateAction::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseRateAction::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseRateAction");
	return false;
}

float QtScriptEaseRateAction::getRate()
{
	auto __o = this->thiz<EaseRateAction *>();
	if (__o)
	{
		return __o->getRate();
	}
	return static_cast<float>(0);
}

bool QtScriptEaseRateAction::initWithAction(cocos2d::ActionInterval* pAction, float fRate)
{
	auto __o = this->thiz<EaseRateAction *>();
	if (__o)
	{
		return __o->initWithAction(pAction, fRate);
	}
	return false;
}

void QtScriptEaseRateAction::setRate(float rate)
{
	auto __o = this->thiz<EaseRateAction *>();
	if (__o)
	{
		__o->setRate(rate);
	}
}

QScriptValue QtScriptEaseRateAction::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(EaseRateAction::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseRateAction::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseExponentialIn::QtScriptEaseExponentialIn(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseExponentialIn::QtScriptEaseExponentialIn(QScriptEngine *engine)
	: QtScriptEaseExponentialIn(engine, "EaseExponentialIn")
{
}

void QtScriptEaseExponentialIn::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseExponentialIn, QtScriptEaseExponentialIn>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseExponentialIn::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseExponentialIn::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseExponentialIn::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseExponentialIn::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseExponentialIn");
	return false;
}

cocos2d::EaseExponentialIn* QtScriptEaseExponentialIn::clone()
{
	auto __o = this->thiz<EaseExponentialIn *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseExponentialIn::reverse()
{
	auto __o = this->thiz<EaseExponentialIn *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseExponentialIn::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseExponentialIn::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseExponentialIn::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseExponentialOut::QtScriptEaseExponentialOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseExponentialOut::QtScriptEaseExponentialOut(QScriptEngine *engine)
	: QtScriptEaseExponentialOut(engine, "EaseExponentialOut")
{
}

void QtScriptEaseExponentialOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseExponentialOut, QtScriptEaseExponentialOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseExponentialOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseExponentialOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseExponentialOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseExponentialOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseExponentialOut");
	return false;
}

cocos2d::EaseExponentialOut* QtScriptEaseExponentialOut::clone()
{
	auto __o = this->thiz<EaseExponentialOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseExponentialOut::reverse()
{
	auto __o = this->thiz<EaseExponentialOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseExponentialOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseExponentialOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseExponentialOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseExponentialInOut::QtScriptEaseExponentialInOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseExponentialInOut::QtScriptEaseExponentialInOut(QScriptEngine *engine)
	: QtScriptEaseExponentialInOut(engine, "EaseExponentialInOut")
{
}

void QtScriptEaseExponentialInOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseExponentialInOut, QtScriptEaseExponentialInOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseExponentialInOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseExponentialInOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseExponentialInOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseExponentialInOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseExponentialInOut");
	return false;
}

cocos2d::EaseExponentialInOut* QtScriptEaseExponentialInOut::clone()
{
	auto __o = this->thiz<EaseExponentialInOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseExponentialInOut::reverse()
{
	auto __o = this->thiz<EaseExponentialInOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseExponentialInOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseExponentialInOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseExponentialInOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseSineIn::QtScriptEaseSineIn(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseSineIn::QtScriptEaseSineIn(QScriptEngine *engine)
	: QtScriptEaseSineIn(engine, "EaseSineIn")
{
}

void QtScriptEaseSineIn::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseSineIn, QtScriptEaseSineIn>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseSineIn::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseSineIn::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseSineIn::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseSineIn::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseSineIn");
	return false;
}

cocos2d::EaseSineIn* QtScriptEaseSineIn::clone()
{
	auto __o = this->thiz<EaseSineIn *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseSineIn::reverse()
{
	auto __o = this->thiz<EaseSineIn *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseSineIn::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseSineIn::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseSineIn::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseSineOut::QtScriptEaseSineOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseSineOut::QtScriptEaseSineOut(QScriptEngine *engine)
	: QtScriptEaseSineOut(engine, "EaseSineOut")
{
}

void QtScriptEaseSineOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseSineOut, QtScriptEaseSineOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseSineOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseSineOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseSineOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseSineOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseSineOut");
	return false;
}

cocos2d::EaseSineOut* QtScriptEaseSineOut::clone()
{
	auto __o = this->thiz<EaseSineOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseSineOut::reverse()
{
	auto __o = this->thiz<EaseSineOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseSineOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseSineOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseSineOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseSineInOut::QtScriptEaseSineInOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseSineInOut::QtScriptEaseSineInOut(QScriptEngine *engine)
	: QtScriptEaseSineInOut(engine, "EaseSineInOut")
{
}

void QtScriptEaseSineInOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseSineInOut, QtScriptEaseSineInOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseSineInOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseSineInOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseSineInOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseSineInOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseSineInOut");
	return false;
}

cocos2d::EaseSineInOut* QtScriptEaseSineInOut::clone()
{
	auto __o = this->thiz<EaseSineInOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseSineInOut::reverse()
{
	auto __o = this->thiz<EaseSineInOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseSineInOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseSineInOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseSineInOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseBounce::QtScriptEaseBounce(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseBounce::QtScriptEaseBounce(QScriptEngine *engine)
	: QtScriptEaseBounce(engine, "EaseBounce")
{
}

void QtScriptEaseBounce::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseBounce, QtScriptEaseBounce>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptEaseBounce::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseBounce::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseBounce::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseBounce");
	return false;
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseBounceIn::QtScriptEaseBounceIn(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseBounceIn::QtScriptEaseBounceIn(QScriptEngine *engine)
	: QtScriptEaseBounceIn(engine, "EaseBounceIn")
{
}

void QtScriptEaseBounceIn::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseBounceIn, QtScriptEaseBounceIn>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseBounceIn::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseBounceIn::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseBounceIn::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseBounceIn::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseBounceIn");
	return false;
}

cocos2d::EaseBounceIn* QtScriptEaseBounceIn::clone()
{
	auto __o = this->thiz<EaseBounceIn *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseBounceIn::reverse()
{
	auto __o = this->thiz<EaseBounceIn *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseBounceIn::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseBounceIn::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseBounceIn::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseBounceOut::QtScriptEaseBounceOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseBounceOut::QtScriptEaseBounceOut(QScriptEngine *engine)
	: QtScriptEaseBounceOut(engine, "EaseBounceOut")
{
}

void QtScriptEaseBounceOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseBounceOut, QtScriptEaseBounceOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseBounceOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseBounceOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseBounceOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseBounceOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseBounceOut");
	return false;
}

cocos2d::EaseBounceOut* QtScriptEaseBounceOut::clone()
{
	auto __o = this->thiz<EaseBounceOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseBounceOut::reverse()
{
	auto __o = this->thiz<EaseBounceOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseBounceOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseBounceOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseBounceOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseBounceInOut::QtScriptEaseBounceInOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseBounceInOut::QtScriptEaseBounceInOut(QScriptEngine *engine)
	: QtScriptEaseBounceInOut(engine, "EaseBounceInOut")
{
}

void QtScriptEaseBounceInOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseBounceInOut, QtScriptEaseBounceInOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseBounceInOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseBounceInOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseBounceInOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseBounceInOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseBounceInOut");
	return false;
}

cocos2d::EaseBounceInOut* QtScriptEaseBounceInOut::clone()
{
	auto __o = this->thiz<EaseBounceInOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseBounceInOut::reverse()
{
	auto __o = this->thiz<EaseBounceInOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseBounceInOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseBounceInOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseBounceInOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseBackIn::QtScriptEaseBackIn(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseBackIn::QtScriptEaseBackIn(QScriptEngine *engine)
	: QtScriptEaseBackIn(engine, "EaseBackIn")
{
}

void QtScriptEaseBackIn::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseBackIn, QtScriptEaseBackIn>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseBackIn::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseBackIn::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseBackIn::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseBackIn::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseBackIn");
	return false;
}

cocos2d::EaseBackIn* QtScriptEaseBackIn::clone()
{
	auto __o = this->thiz<EaseBackIn *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseBackIn::reverse()
{
	auto __o = this->thiz<EaseBackIn *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseBackIn::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseBackIn::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseBackIn::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseBackOut::QtScriptEaseBackOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseBackOut::QtScriptEaseBackOut(QScriptEngine *engine)
	: QtScriptEaseBackOut(engine, "EaseBackOut")
{
}

void QtScriptEaseBackOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseBackOut, QtScriptEaseBackOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseBackOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseBackOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseBackOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseBackOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseBackOut");
	return false;
}

cocos2d::EaseBackOut* QtScriptEaseBackOut::clone()
{
	auto __o = this->thiz<EaseBackOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseBackOut::reverse()
{
	auto __o = this->thiz<EaseBackOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseBackOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseBackOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseBackOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseBackInOut::QtScriptEaseBackInOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseBackInOut::QtScriptEaseBackInOut(QScriptEngine *engine)
	: QtScriptEaseBackInOut(engine, "EaseBackInOut")
{
}

void QtScriptEaseBackInOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseBackInOut, QtScriptEaseBackInOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseBackInOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseBackInOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseBackInOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseBackInOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseBackInOut");
	return false;
}

cocos2d::EaseBackInOut* QtScriptEaseBackInOut::clone()
{
	auto __o = this->thiz<EaseBackInOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseBackInOut::reverse()
{
	auto __o = this->thiz<EaseBackInOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseBackInOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseBackInOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseBackInOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseQuadraticActionIn::QtScriptEaseQuadraticActionIn(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseQuadraticActionIn::QtScriptEaseQuadraticActionIn(QScriptEngine *engine)
	: QtScriptEaseQuadraticActionIn(engine, "EaseQuadraticActionIn")
{
}

void QtScriptEaseQuadraticActionIn::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseQuadraticActionIn, QtScriptEaseQuadraticActionIn>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseQuadraticActionIn::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseQuadraticActionIn::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseQuadraticActionIn::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseQuadraticActionIn::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseQuadraticActionIn");
	return false;
}

cocos2d::EaseQuadraticActionIn* QtScriptEaseQuadraticActionIn::clone()
{
	auto __o = this->thiz<EaseQuadraticActionIn *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseQuadraticActionIn::reverse()
{
	auto __o = this->thiz<EaseQuadraticActionIn *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseQuadraticActionIn::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseQuadraticActionIn::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseQuadraticActionIn::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseQuadraticActionOut::QtScriptEaseQuadraticActionOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseQuadraticActionOut::QtScriptEaseQuadraticActionOut(QScriptEngine *engine)
	: QtScriptEaseQuadraticActionOut(engine, "EaseQuadraticActionOut")
{
}

void QtScriptEaseQuadraticActionOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseQuadraticActionOut, QtScriptEaseQuadraticActionOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseQuadraticActionOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseQuadraticActionOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseQuadraticActionOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseQuadraticActionOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseQuadraticActionOut");
	return false;
}

cocos2d::EaseQuadraticActionOut* QtScriptEaseQuadraticActionOut::clone()
{
	auto __o = this->thiz<EaseQuadraticActionOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseQuadraticActionOut::reverse()
{
	auto __o = this->thiz<EaseQuadraticActionOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseQuadraticActionOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseQuadraticActionOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseQuadraticActionOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseQuadraticActionInOut::QtScriptEaseQuadraticActionInOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseQuadraticActionInOut::QtScriptEaseQuadraticActionInOut(QScriptEngine *engine)
	: QtScriptEaseQuadraticActionInOut(engine, "EaseQuadraticActionInOut")
{
}

void QtScriptEaseQuadraticActionInOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseQuadraticActionInOut, QtScriptEaseQuadraticActionInOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseQuadraticActionInOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseQuadraticActionInOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseQuadraticActionInOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseQuadraticActionInOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseQuadraticActionInOut");
	return false;
}

cocos2d::EaseQuadraticActionInOut* QtScriptEaseQuadraticActionInOut::clone()
{
	auto __o = this->thiz<EaseQuadraticActionInOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseQuadraticActionInOut::reverse()
{
	auto __o = this->thiz<EaseQuadraticActionInOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseQuadraticActionInOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseQuadraticActionInOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseQuadraticActionInOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseQuarticActionIn::QtScriptEaseQuarticActionIn(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseQuarticActionIn::QtScriptEaseQuarticActionIn(QScriptEngine *engine)
	: QtScriptEaseQuarticActionIn(engine, "EaseQuarticActionIn")
{
}

void QtScriptEaseQuarticActionIn::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseQuarticActionIn, QtScriptEaseQuarticActionIn>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseQuarticActionIn::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseQuarticActionIn::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseQuarticActionIn::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseQuarticActionIn::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseQuarticActionIn");
	return false;
}

cocos2d::EaseQuarticActionIn* QtScriptEaseQuarticActionIn::clone()
{
	auto __o = this->thiz<EaseQuarticActionIn *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseQuarticActionIn::reverse()
{
	auto __o = this->thiz<EaseQuarticActionIn *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseQuarticActionIn::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseQuarticActionIn::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseQuarticActionIn::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseQuarticActionOut::QtScriptEaseQuarticActionOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseQuarticActionOut::QtScriptEaseQuarticActionOut(QScriptEngine *engine)
	: QtScriptEaseQuarticActionOut(engine, "EaseQuarticActionOut")
{
}

void QtScriptEaseQuarticActionOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseQuarticActionOut, QtScriptEaseQuarticActionOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseQuarticActionOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseQuarticActionOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseQuarticActionOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseQuarticActionOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseQuarticActionOut");
	return false;
}

cocos2d::EaseQuarticActionOut* QtScriptEaseQuarticActionOut::clone()
{
	auto __o = this->thiz<EaseQuarticActionOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseQuarticActionOut::reverse()
{
	auto __o = this->thiz<EaseQuarticActionOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseQuarticActionOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseQuarticActionOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseQuarticActionOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseQuarticActionInOut::QtScriptEaseQuarticActionInOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseQuarticActionInOut::QtScriptEaseQuarticActionInOut(QScriptEngine *engine)
	: QtScriptEaseQuarticActionInOut(engine, "EaseQuarticActionInOut")
{
}

void QtScriptEaseQuarticActionInOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseQuarticActionInOut, QtScriptEaseQuarticActionInOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseQuarticActionInOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseQuarticActionInOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseQuarticActionInOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseQuarticActionInOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseQuarticActionInOut");
	return false;
}

cocos2d::EaseQuarticActionInOut* QtScriptEaseQuarticActionInOut::clone()
{
	auto __o = this->thiz<EaseQuarticActionInOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseQuarticActionInOut::reverse()
{
	auto __o = this->thiz<EaseQuarticActionInOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseQuarticActionInOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseQuarticActionInOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseQuarticActionInOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseQuinticActionIn::QtScriptEaseQuinticActionIn(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseQuinticActionIn::QtScriptEaseQuinticActionIn(QScriptEngine *engine)
	: QtScriptEaseQuinticActionIn(engine, "EaseQuinticActionIn")
{
}

void QtScriptEaseQuinticActionIn::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseQuinticActionIn, QtScriptEaseQuinticActionIn>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseQuinticActionIn::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseQuinticActionIn::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseQuinticActionIn::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseQuinticActionIn::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseQuinticActionIn");
	return false;
}

cocos2d::EaseQuinticActionIn* QtScriptEaseQuinticActionIn::clone()
{
	auto __o = this->thiz<EaseQuinticActionIn *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseQuinticActionIn::reverse()
{
	auto __o = this->thiz<EaseQuinticActionIn *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseQuinticActionIn::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseQuinticActionIn::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseQuinticActionIn::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseQuinticActionOut::QtScriptEaseQuinticActionOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseQuinticActionOut::QtScriptEaseQuinticActionOut(QScriptEngine *engine)
	: QtScriptEaseQuinticActionOut(engine, "EaseQuinticActionOut")
{
}

void QtScriptEaseQuinticActionOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseQuinticActionOut, QtScriptEaseQuinticActionOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseQuinticActionOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseQuinticActionOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseQuinticActionOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseQuinticActionOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseQuinticActionOut");
	return false;
}

cocos2d::EaseQuinticActionOut* QtScriptEaseQuinticActionOut::clone()
{
	auto __o = this->thiz<EaseQuinticActionOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseQuinticActionOut::reverse()
{
	auto __o = this->thiz<EaseQuinticActionOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseQuinticActionOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseQuinticActionOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseQuinticActionOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseQuinticActionInOut::QtScriptEaseQuinticActionInOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseQuinticActionInOut::QtScriptEaseQuinticActionInOut(QScriptEngine *engine)
	: QtScriptEaseQuinticActionInOut(engine, "EaseQuinticActionInOut")
{
}

void QtScriptEaseQuinticActionInOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseQuinticActionInOut, QtScriptEaseQuinticActionInOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseQuinticActionInOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseQuinticActionInOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseQuinticActionInOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseQuinticActionInOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseQuinticActionInOut");
	return false;
}

cocos2d::EaseQuinticActionInOut* QtScriptEaseQuinticActionInOut::clone()
{
	auto __o = this->thiz<EaseQuinticActionInOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseQuinticActionInOut::reverse()
{
	auto __o = this->thiz<EaseQuinticActionInOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseQuinticActionInOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseQuinticActionInOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseQuinticActionInOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseCircleActionIn::QtScriptEaseCircleActionIn(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseCircleActionIn::QtScriptEaseCircleActionIn(QScriptEngine *engine)
	: QtScriptEaseCircleActionIn(engine, "EaseCircleActionIn")
{
}

void QtScriptEaseCircleActionIn::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseCircleActionIn, QtScriptEaseCircleActionIn>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseCircleActionIn::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseCircleActionIn::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseCircleActionIn::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseCircleActionIn::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseCircleActionIn");
	return false;
}

cocos2d::EaseCircleActionIn* QtScriptEaseCircleActionIn::clone()
{
	auto __o = this->thiz<EaseCircleActionIn *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseCircleActionIn::reverse()
{
	auto __o = this->thiz<EaseCircleActionIn *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseCircleActionIn::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseCircleActionIn::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseCircleActionIn::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseCircleActionOut::QtScriptEaseCircleActionOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseCircleActionOut::QtScriptEaseCircleActionOut(QScriptEngine *engine)
	: QtScriptEaseCircleActionOut(engine, "EaseCircleActionOut")
{
}

void QtScriptEaseCircleActionOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseCircleActionOut, QtScriptEaseCircleActionOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseCircleActionOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseCircleActionOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseCircleActionOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseCircleActionOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseCircleActionOut");
	return false;
}

cocos2d::EaseCircleActionOut* QtScriptEaseCircleActionOut::clone()
{
	auto __o = this->thiz<EaseCircleActionOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseCircleActionOut::reverse()
{
	auto __o = this->thiz<EaseCircleActionOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseCircleActionOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseCircleActionOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseCircleActionOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseCircleActionInOut::QtScriptEaseCircleActionInOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseCircleActionInOut::QtScriptEaseCircleActionInOut(QScriptEngine *engine)
	: QtScriptEaseCircleActionInOut(engine, "EaseCircleActionInOut")
{
}

void QtScriptEaseCircleActionInOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseCircleActionInOut, QtScriptEaseCircleActionInOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseCircleActionInOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseCircleActionInOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseCircleActionInOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseCircleActionInOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseCircleActionInOut");
	return false;
}

cocos2d::EaseCircleActionInOut* QtScriptEaseCircleActionInOut::clone()
{
	auto __o = this->thiz<EaseCircleActionInOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseCircleActionInOut::reverse()
{
	auto __o = this->thiz<EaseCircleActionInOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseCircleActionInOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseCircleActionInOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseCircleActionInOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseCubicActionIn::QtScriptEaseCubicActionIn(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseCubicActionIn::QtScriptEaseCubicActionIn(QScriptEngine *engine)
	: QtScriptEaseCubicActionIn(engine, "EaseCubicActionIn")
{
}

void QtScriptEaseCubicActionIn::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseCubicActionIn, QtScriptEaseCubicActionIn>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseCubicActionIn::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseCubicActionIn::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseCubicActionIn::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseCubicActionIn::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseCubicActionIn");
	return false;
}

cocos2d::EaseCubicActionIn* QtScriptEaseCubicActionIn::clone()
{
	auto __o = this->thiz<EaseCubicActionIn *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseCubicActionIn::reverse()
{
	auto __o = this->thiz<EaseCubicActionIn *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseCubicActionIn::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseCubicActionIn::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseCubicActionIn::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseCubicActionOut::QtScriptEaseCubicActionOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseCubicActionOut::QtScriptEaseCubicActionOut(QScriptEngine *engine)
	: QtScriptEaseCubicActionOut(engine, "EaseCubicActionOut")
{
}

void QtScriptEaseCubicActionOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseCubicActionOut, QtScriptEaseCubicActionOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseCubicActionOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseCubicActionOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseCubicActionOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseCubicActionOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseCubicActionOut");
	return false;
}

cocos2d::EaseCubicActionOut* QtScriptEaseCubicActionOut::clone()
{
	auto __o = this->thiz<EaseCubicActionOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseCubicActionOut::reverse()
{
	auto __o = this->thiz<EaseCubicActionOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseCubicActionOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseCubicActionOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseCubicActionOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseCubicActionInOut::QtScriptEaseCubicActionInOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseCubicActionInOut::QtScriptEaseCubicActionInOut(QScriptEngine *engine)
	: QtScriptEaseCubicActionInOut(engine, "EaseCubicActionInOut")
{
}

void QtScriptEaseCubicActionInOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseCubicActionInOut, QtScriptEaseCubicActionInOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseCubicActionInOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseCubicActionInOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseCubicActionInOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseCubicActionInOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseCubicActionInOut");
	return false;
}

cocos2d::EaseCubicActionInOut* QtScriptEaseCubicActionInOut::clone()
{
	auto __o = this->thiz<EaseCubicActionInOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionEase* QtScriptEaseCubicActionInOut::reverse()
{
	auto __o = this->thiz<EaseCubicActionInOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseCubicActionInOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseCubicActionInOut::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseCubicActionInOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseIn::QtScriptEaseIn(QScriptEngine *engine, const QByteArray &className)
	: QtScriptEaseRateAction(engine, className)
{
}

QtScriptEaseIn::QtScriptEaseIn(QScriptEngine *engine)
	: QtScriptEaseIn(engine, "EaseIn")
{
}

void QtScriptEaseIn::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<EaseRateAction *>());
	auto ctor = RegisterT<EaseIn, QtScriptEaseIn>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseIn::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseIn::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseIn::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseIn::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseIn");
	return false;
}

cocos2d::EaseIn* QtScriptEaseIn::clone()
{
	auto __o = this->thiz<EaseIn *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::EaseRateAction* QtScriptEaseIn::reverse()
{
	auto __o = this->thiz<EaseIn *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseIn::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(EaseIn::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseIn::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseOut::QtScriptEaseOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptEaseRateAction(engine, className)
{
}

QtScriptEaseOut::QtScriptEaseOut(QScriptEngine *engine)
	: QtScriptEaseOut(engine, "EaseOut")
{
}

void QtScriptEaseOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<EaseRateAction *>());
	auto ctor = RegisterT<EaseOut, QtScriptEaseOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseOut");
	return false;
}

cocos2d::EaseOut* QtScriptEaseOut::clone()
{
	auto __o = this->thiz<EaseOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::EaseRateAction* QtScriptEaseOut::reverse()
{
	auto __o = this->thiz<EaseOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(EaseOut::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseInOut::QtScriptEaseInOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptEaseRateAction(engine, className)
{
}

QtScriptEaseInOut::QtScriptEaseInOut(QScriptEngine *engine)
	: QtScriptEaseInOut(engine, "EaseInOut")
{
}

void QtScriptEaseInOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<EaseRateAction *>());
	auto ctor = RegisterT<EaseInOut, QtScriptEaseInOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseInOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseInOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseInOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseInOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseInOut");
	return false;
}

cocos2d::EaseInOut* QtScriptEaseInOut::clone()
{
	auto __o = this->thiz<EaseInOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::EaseRateAction* QtScriptEaseInOut::reverse()
{
	auto __o = this->thiz<EaseInOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseInOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(EaseInOut::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseInOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseElastic::QtScriptEaseElastic(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseElastic::QtScriptEaseElastic(QScriptEngine *engine)
	: QtScriptEaseElastic(engine, "EaseElastic")
{
}

void QtScriptEaseElastic::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseElastic, QtScriptEaseElastic>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptEaseElastic::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseElastic::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseElastic::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseElastic");
	return false;
}

float QtScriptEaseElastic::getPeriod()
{
	auto __o = this->thiz<EaseElastic *>();
	if (__o)
	{
		return __o->getPeriod();
	}
	return static_cast<float>(0);
}

bool QtScriptEaseElastic::initWithAction(cocos2d::ActionInterval* action)
{
	auto __o = this->thiz<EaseElastic *>();
	if (__o)
	{
		return __o->initWithAction(action);
	}
	return false;
}

bool QtScriptEaseElastic::initWithAction(cocos2d::ActionInterval* action, float period)
{
	auto __o = this->thiz<EaseElastic *>();
	if (__o)
	{
		return __o->initWithAction(action, period);
	}
	return false;
}

void QtScriptEaseElastic::setPeriod(float fPeriod)
{
	auto __o = this->thiz<EaseElastic *>();
	if (__o)
	{
		__o->setPeriod(fPeriod);
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseElasticIn::QtScriptEaseElasticIn(QScriptEngine *engine, const QByteArray &className)
	: QtScriptEaseElastic(engine, className)
{
}

QtScriptEaseElasticIn::QtScriptEaseElasticIn(QScriptEngine *engine)
	: QtScriptEaseElasticIn(engine, "EaseElasticIn")
{
}

void QtScriptEaseElasticIn::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<EaseElastic *>());
	auto ctor = RegisterT<EaseElasticIn, QtScriptEaseElasticIn>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseElasticIn::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseElasticIn::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseElasticIn::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseElasticIn::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseElasticIn");
	return false;
}

cocos2d::EaseElasticIn* QtScriptEaseElasticIn::clone()
{
	auto __o = this->thiz<EaseElasticIn *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::EaseElastic* QtScriptEaseElasticIn::reverse()
{
	auto __o = this->thiz<EaseElasticIn *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseElasticIn::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseElasticIn::create(arg0));
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(EaseElasticIn::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseElasticIn::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseElasticOut::QtScriptEaseElasticOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptEaseElastic(engine, className)
{
}

QtScriptEaseElasticOut::QtScriptEaseElasticOut(QScriptEngine *engine)
	: QtScriptEaseElasticOut(engine, "EaseElasticOut")
{
}

void QtScriptEaseElasticOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<EaseElastic *>());
	auto ctor = RegisterT<EaseElasticOut, QtScriptEaseElasticOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseElasticOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseElasticOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseElasticOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseElasticOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseElasticOut");
	return false;
}

cocos2d::EaseElasticOut* QtScriptEaseElasticOut::clone()
{
	auto __o = this->thiz<EaseElasticOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::EaseElastic* QtScriptEaseElasticOut::reverse()
{
	auto __o = this->thiz<EaseElasticOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseElasticOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseElasticOut::create(arg0));
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(EaseElasticOut::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseElasticOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseElasticInOut::QtScriptEaseElasticInOut(QScriptEngine *engine, const QByteArray &className)
	: QtScriptEaseElastic(engine, className)
{
}

QtScriptEaseElasticInOut::QtScriptEaseElasticInOut(QScriptEngine *engine)
	: QtScriptEaseElasticInOut(engine, "EaseElasticInOut")
{
}

void QtScriptEaseElasticInOut::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<EaseElastic *>());
	auto ctor = RegisterT<EaseElasticInOut, QtScriptEaseElasticInOut>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseElasticInOut::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseElasticInOut::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseElasticInOut::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseElasticInOut::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseElasticInOut");
	return false;
}

cocos2d::EaseElasticInOut* QtScriptEaseElasticInOut::clone()
{
	auto __o = this->thiz<EaseElasticInOut *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::EaseElastic* QtScriptEaseElasticInOut::reverse()
{
	auto __o = this->thiz<EaseElasticInOut *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptEaseElasticInOut::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseElasticInOut::create(arg0));
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(EaseElasticInOut::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseElasticInOut::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptEaseBezierAction::QtScriptEaseBezierAction(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionEase(engine, className)
{
}

QtScriptEaseBezierAction::QtScriptEaseBezierAction(QScriptEngine *engine)
	: QtScriptEaseBezierAction(engine, "EaseBezierAction")
{
}

void QtScriptEaseBezierAction::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionEase *>());
	auto ctor = RegisterT<EaseBezierAction, QtScriptEaseBezierAction>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptEaseBezierAction::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptEaseBezierAction::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptEaseBezierAction::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptEaseBezierAction::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::EaseBezierAction");
	return false;
}

cocos2d::EaseBezierAction* QtScriptEaseBezierAction::clone()
{
	auto __o = this->thiz<EaseBezierAction *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::EaseBezierAction* QtScriptEaseBezierAction::reverse()
{
	auto __o = this->thiz<EaseBezierAction *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptEaseBezierAction::setBezierParamer(float p0, float p1, float p2, float p3)
{
	auto __o = this->thiz<EaseBezierAction *>();
	if (__o)
	{
		__o->setBezierParamer(p0, p1, p2, p3);
	}
}

QScriptValue QtScriptEaseBezierAction::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::ActionInterval*>(context->argument(0));
			return __e->toScriptValue(EaseBezierAction::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::EaseBezierAction::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptActionInstant::QtScriptActionInstant(QScriptEngine *engine, const QByteArray &className)
	: QtScriptFiniteTimeAction(engine, className)
{
}

QtScriptActionInstant::QtScriptActionInstant(QScriptEngine *engine)
	: QtScriptActionInstant(engine, "ActionInstant")
{
}

void QtScriptActionInstant::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<FiniteTimeAction *>());
	auto ctor = RegisterT<ActionInstant, QtScriptActionInstant>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptActionInstant::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptActionInstant::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptActionInstant::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ActionInstant");
	return false;
}

cocos2d::ActionInstant* QtScriptActionInstant::clone()
{
	auto __o = this->thiz<ActionInstant *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ActionInstant* QtScriptActionInstant::reverse()
{
	auto __o = this->thiz<ActionInstant *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

} // end of cocos2d

namespace cocos2d {
QtScriptShow::QtScriptShow(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInstant(engine, className)
{
}

QtScriptShow::QtScriptShow(QScriptEngine *engine)
	: QtScriptShow(engine, "Show")
{
}

void QtScriptShow::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInstant *>());
	auto ctor = RegisterT<Show, QtScriptShow>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptShow::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptShow::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptShow::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptShow::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Show");
	return false;
}

cocos2d::Show* QtScriptShow::clone()
{
	auto __o = this->thiz<Show *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

QScriptValue QtScriptShow::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Show::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Show::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptHide::QtScriptHide(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInstant(engine, className)
{
}

QtScriptHide::QtScriptHide(QScriptEngine *engine)
	: QtScriptHide(engine, "Hide")
{
}

void QtScriptHide::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInstant *>());
	auto ctor = RegisterT<Hide, QtScriptHide>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptHide::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptHide::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptHide::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptHide::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Hide");
	return false;
}

cocos2d::Hide* QtScriptHide::clone()
{
	auto __o = this->thiz<Hide *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

QScriptValue QtScriptHide::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Hide::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Hide::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptToggleVisibility::QtScriptToggleVisibility(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInstant(engine, className)
{
}

QtScriptToggleVisibility::QtScriptToggleVisibility(QScriptEngine *engine)
	: QtScriptToggleVisibility(engine, "ToggleVisibility")
{
}

void QtScriptToggleVisibility::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInstant *>());
	auto ctor = RegisterT<ToggleVisibility, QtScriptToggleVisibility>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptToggleVisibility::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptToggleVisibility::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptToggleVisibility::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptToggleVisibility::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ToggleVisibility");
	return false;
}

cocos2d::ToggleVisibility* QtScriptToggleVisibility::clone()
{
	auto __o = this->thiz<ToggleVisibility *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::ToggleVisibility* QtScriptToggleVisibility::reverse()
{
	auto __o = this->thiz<ToggleVisibility *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptToggleVisibility::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ToggleVisibility::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ToggleVisibility::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptRemoveSelf::QtScriptRemoveSelf(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInstant(engine, className)
{
}

QtScriptRemoveSelf::QtScriptRemoveSelf(QScriptEngine *engine)
	: QtScriptRemoveSelf(engine, "RemoveSelf")
{
}

void QtScriptRemoveSelf::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInstant *>());
	auto ctor = RegisterT<RemoveSelf, QtScriptRemoveSelf>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptRemoveSelf::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptRemoveSelf::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptRemoveSelf::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptRemoveSelf::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::RemoveSelf");
	return false;
}

cocos2d::RemoveSelf* QtScriptRemoveSelf::clone()
{
	auto __o = this->thiz<RemoveSelf *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptRemoveSelf::init(bool isNeedCleanUp)
{
	auto __o = this->thiz<RemoveSelf *>();
	if (__o)
	{
		return __o->init(isNeedCleanUp);
	}
	return false;
}

cocos2d::RemoveSelf* QtScriptRemoveSelf::reverse()
{
	auto __o = this->thiz<RemoveSelf *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptRemoveSelf::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(RemoveSelf::create());
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<bool>(context->argument(0));
			return __e->toScriptValue(RemoveSelf::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::RemoveSelf::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptFlipX::QtScriptFlipX(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInstant(engine, className)
{
}

QtScriptFlipX::QtScriptFlipX(QScriptEngine *engine)
	: QtScriptFlipX(engine, "FlipX")
{
}

void QtScriptFlipX::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInstant *>());
	auto ctor = RegisterT<FlipX, QtScriptFlipX>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFlipX::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptFlipX::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFlipX::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFlipX::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::FlipX");
	return false;
}

cocos2d::FlipX* QtScriptFlipX::clone()
{
	auto __o = this->thiz<FlipX *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptFlipX::initWithFlipX(bool x)
{
	auto __o = this->thiz<FlipX *>();
	if (__o)
	{
		return __o->initWithFlipX(x);
	}
	return false;
}

cocos2d::FlipX* QtScriptFlipX::reverse()
{
	auto __o = this->thiz<FlipX *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptFlipX::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<bool>(context->argument(0));
			return __e->toScriptValue(FlipX::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FlipX::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptFlipY::QtScriptFlipY(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInstant(engine, className)
{
}

QtScriptFlipY::QtScriptFlipY(QScriptEngine *engine)
	: QtScriptFlipY(engine, "FlipY")
{
}

void QtScriptFlipY::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInstant *>());
	auto ctor = RegisterT<FlipY, QtScriptFlipY>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFlipY::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptFlipY::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFlipY::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFlipY::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::FlipY");
	return false;
}

cocos2d::FlipY* QtScriptFlipY::clone()
{
	auto __o = this->thiz<FlipY *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptFlipY::initWithFlipY(bool y)
{
	auto __o = this->thiz<FlipY *>();
	if (__o)
	{
		return __o->initWithFlipY(y);
	}
	return false;
}

cocos2d::FlipY* QtScriptFlipY::reverse()
{
	auto __o = this->thiz<FlipY *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptFlipY::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<bool>(context->argument(0));
			return __e->toScriptValue(FlipY::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FlipY::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptPlace::QtScriptPlace(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInstant(engine, className)
{
}

QtScriptPlace::QtScriptPlace(QScriptEngine *engine)
	: QtScriptPlace(engine, "Place")
{
}

void QtScriptPlace::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInstant *>());
	auto ctor = RegisterT<Place, QtScriptPlace>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptPlace::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptPlace::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptPlace::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptPlace::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Place");
	return false;
}

cocos2d::Place* QtScriptPlace::clone()
{
	auto __o = this->thiz<Place *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptPlace::initWithPosition(const cocos2d::Vec2& pos)
{
	auto __o = this->thiz<Place *>();
	if (__o)
	{
		return __o->initWithPosition(pos);
	}
	return false;
}

cocos2d::Place* QtScriptPlace::reverse()
{
	auto __o = this->thiz<Place *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptPlace::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(0));
			return __e->toScriptValue(Place::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Place::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptCallFunc::QtScriptCallFunc(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInstant(engine, className)
{
}

QtScriptCallFunc::QtScriptCallFunc(QScriptEngine *engine)
	: QtScriptCallFunc(engine, "CallFunc")
{
}

void QtScriptCallFunc::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInstant *>());
	auto ctor = RegisterT<CallFunc, QtScriptCallFunc>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCallFunc::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptCallFunc::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptCallFunc::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptCallFunc::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::CallFunc");
	return false;
}

cocos2d::CallFunc* QtScriptCallFunc::clone()
{
	auto __o = this->thiz<CallFunc *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

void QtScriptCallFunc::execute()
{
	auto __o = this->thiz<CallFunc *>();
	if (__o)
	{
		__o->execute();
	}
}

bool QtScriptCallFunc::initWithFunction(QScriptValue func)
{
	auto __e = this->engine();
	auto __o = this->thiz<CallFunc *>();
	if (__o)
	{
		return __o->initWithFunction(!func.isFunction() ? std::function<void ()>() : [=]() mutable -> void
{
	QScriptValueList arguments;
	func.call(QScriptValue(), arguments);
});
	}
	return false;
}

cocos2d::CallFunc* QtScriptCallFunc::reverse()
{
	auto __o = this->thiz<CallFunc *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptCallFunc::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = context->argument(0);
			auto arg0 = !tmp_0.isFunction() ? std::function<void ()>() : [=]() mutable -> void
{
	QScriptValueList arguments;
	tmp_0.call(QScriptValue(), arguments);
};
			return __e->toScriptValue(CallFunc::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::CallFunc::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptCallFuncN::QtScriptCallFuncN(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInstant(engine, className)
{
}

QtScriptCallFuncN::QtScriptCallFuncN(QScriptEngine *engine)
	: QtScriptCallFuncN(engine, "CallFuncN")
{
}

void QtScriptCallFuncN::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInstant *>());
	auto ctor = RegisterT<CallFuncN, QtScriptCallFuncN>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCallFuncN::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptCallFuncN::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptCallFuncN::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptCallFuncN::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::CallFuncN");
	return false;
}

cocos2d::CallFuncN* QtScriptCallFuncN::clone()
{
	auto __o = this->thiz<CallFuncN *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

void QtScriptCallFuncN::execute()
{
	auto __o = this->thiz<CallFuncN *>();
	if (__o)
	{
		__o->execute();
	}
}

bool QtScriptCallFuncN::initWithFunction(QScriptValue func)
{
	auto __e = this->engine();
	auto __o = this->thiz<CallFuncN *>();
	if (__o)
	{
		return __o->initWithFunction(!func.isFunction() ? std::function<void (cocos2d::Node *)>() : [=](cocos2d::Node* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	func.call(QScriptValue(), arguments);
});
	}
	return false;
}

cocos2d::CallFuncN* QtScriptCallFuncN::reverse()
{
	auto __o = this->thiz<CallFuncN *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptCallFuncN::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = context->argument(0);
			auto arg0 = !tmp_0.isFunction() ? std::function<void (cocos2d::Node *)>() : [=](cocos2d::Node* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	tmp_0.call(QScriptValue(), arguments);
};
			return __e->toScriptValue(CallFuncN::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::CallFuncN::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptGridAction::QtScriptGridAction(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptGridAction::QtScriptGridAction(QScriptEngine *engine)
	: QtScriptGridAction(engine, "GridAction")
{
}

void QtScriptGridAction::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<GridAction, QtScriptGridAction>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptGridAction::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptGridAction::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptGridAction::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::GridAction");
	return false;
}

cocos2d::GridAction* QtScriptGridAction::clone()
{
	auto __o = this->thiz<GridAction *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::GridBase* QtScriptGridAction::getGrid()
{
	auto __o = this->thiz<GridAction *>();
	if (__o)
	{
		return __o->getGrid();
	}
	return nullptr;
}

bool QtScriptGridAction::initWithDuration(float duration, const cocos2d::Size& gridSize)
{
	auto __o = this->thiz<GridAction *>();
	if (__o)
	{
		return __o->initWithDuration(duration, gridSize);
	}
	return false;
}

cocos2d::GridAction* QtScriptGridAction::reverse()
{
	auto __o = this->thiz<GridAction *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

} // end of cocos2d

namespace cocos2d {
QtScriptGrid3DAction::QtScriptGrid3DAction(QScriptEngine *engine, const QByteArray &className)
	: QtScriptGridAction(engine, className)
{
}

QtScriptGrid3DAction::QtScriptGrid3DAction(QScriptEngine *engine)
	: QtScriptGrid3DAction(engine, "Grid3DAction")
{
}

void QtScriptGrid3DAction::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<GridAction *>());
	auto ctor = RegisterT<Grid3DAction, QtScriptGrid3DAction>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptGrid3DAction::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptGrid3DAction::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptGrid3DAction::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Grid3DAction");
	return false;
}

cocos2d::Grid3DAction* QtScriptGrid3DAction::clone()
{
	auto __o = this->thiz<Grid3DAction *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::Rect QtScriptGrid3DAction::getGridRect()
{
	auto __o = this->thiz<Grid3DAction *>();
	if (__o)
	{
		return __o->getGridRect();
	}
	return cocos2d::Rect();
}

cocos2d::Vec3 QtScriptGrid3DAction::getOriginalVertex(const cocos2d::Vec2& position)
{
	auto __o = this->thiz<Grid3DAction *>();
	if (__o)
	{
		return __o->getOriginalVertex(position);
	}
	return cocos2d::Vec3();
}

cocos2d::Vec3 QtScriptGrid3DAction::getVertex(const cocos2d::Vec2& position)
{
	auto __o = this->thiz<Grid3DAction *>();
	if (__o)
	{
		return __o->getVertex(position);
	}
	return cocos2d::Vec3();
}

void QtScriptGrid3DAction::setVertex(const cocos2d::Vec2& position, const cocos2d::Vec3& vertex)
{
	auto __o = this->thiz<Grid3DAction *>();
	if (__o)
	{
		__o->setVertex(position, vertex);
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptTiledGrid3DAction::QtScriptTiledGrid3DAction(QScriptEngine *engine, const QByteArray &className)
	: QtScriptGridAction(engine, className)
{
}

QtScriptTiledGrid3DAction::QtScriptTiledGrid3DAction(QScriptEngine *engine)
	: QtScriptTiledGrid3DAction(engine, "TiledGrid3DAction")
{
}

void QtScriptTiledGrid3DAction::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<GridAction *>());
	auto ctor = RegisterT<TiledGrid3DAction, QtScriptTiledGrid3DAction>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTiledGrid3DAction::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptTiledGrid3DAction::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTiledGrid3DAction::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTiledGrid3DAction::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::TiledGrid3DAction");
	return false;
}

cocos2d::TiledGrid3DAction* QtScriptTiledGrid3DAction::clone()
{
	auto __o = this->thiz<TiledGrid3DAction *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::Quad3 QtScriptTiledGrid3DAction::getOriginalTile(const cocos2d::Vec2& position)
{
	auto __o = this->thiz<TiledGrid3DAction *>();
	if (__o)
	{
		return __o->getOriginalTile(position);
	}
	return cocos2d::Quad3();
}

cocos2d::Quad3 QtScriptTiledGrid3DAction::getTile(const cocos2d::Vec2& position)
{
	auto __o = this->thiz<TiledGrid3DAction *>();
	if (__o)
	{
		return __o->getTile(position);
	}
	return cocos2d::Quad3();
}

void QtScriptTiledGrid3DAction::setTile(const cocos2d::Vec2& position, const cocos2d::Quad3& coords)
{
	auto __o = this->thiz<TiledGrid3DAction *>();
	if (__o)
	{
		__o->setTile(position, coords);
	}
}

QScriptValue QtScriptTiledGrid3DAction::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			return __e->toScriptValue(TiledGrid3DAction::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::TiledGrid3DAction::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptAccelDeccelAmplitude::QtScriptAccelDeccelAmplitude(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptAccelDeccelAmplitude::QtScriptAccelDeccelAmplitude(QScriptEngine *engine)
	: QtScriptAccelDeccelAmplitude(engine, "AccelDeccelAmplitude")
{
}

void QtScriptAccelDeccelAmplitude::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<AccelDeccelAmplitude, QtScriptAccelDeccelAmplitude>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAccelDeccelAmplitude::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptAccelDeccelAmplitude::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAccelDeccelAmplitude::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptAccelDeccelAmplitude::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::AccelDeccelAmplitude");
	return false;
}

cocos2d::AccelDeccelAmplitude* QtScriptAccelDeccelAmplitude::clone()
{
	auto __o = this->thiz<AccelDeccelAmplitude *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptAccelDeccelAmplitude::getRate()
{
	auto __o = this->thiz<AccelDeccelAmplitude *>();
	if (__o)
	{
		return __o->getRate();
	}
	return static_cast<float>(0);
}

bool QtScriptAccelDeccelAmplitude::initWithAction(cocos2d::Action* action, float duration)
{
	auto __o = this->thiz<AccelDeccelAmplitude *>();
	if (__o)
	{
		return __o->initWithAction(action, duration);
	}
	return false;
}

cocos2d::AccelDeccelAmplitude* QtScriptAccelDeccelAmplitude::reverse()
{
	auto __o = this->thiz<AccelDeccelAmplitude *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptAccelDeccelAmplitude::setRate(float rate)
{
	auto __o = this->thiz<AccelDeccelAmplitude *>();
	if (__o)
	{
		__o->setRate(rate);
	}
}

QScriptValue QtScriptAccelDeccelAmplitude::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Action*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(AccelDeccelAmplitude::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::AccelDeccelAmplitude::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptAccelAmplitude::QtScriptAccelAmplitude(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptAccelAmplitude::QtScriptAccelAmplitude(QScriptEngine *engine)
	: QtScriptAccelAmplitude(engine, "AccelAmplitude")
{
}

void QtScriptAccelAmplitude::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<AccelAmplitude, QtScriptAccelAmplitude>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAccelAmplitude::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptAccelAmplitude::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAccelAmplitude::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptAccelAmplitude::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::AccelAmplitude");
	return false;
}

cocos2d::AccelAmplitude* QtScriptAccelAmplitude::clone()
{
	auto __o = this->thiz<AccelAmplitude *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptAccelAmplitude::getRate()
{
	auto __o = this->thiz<AccelAmplitude *>();
	if (__o)
	{
		return __o->getRate();
	}
	return static_cast<float>(0);
}

bool QtScriptAccelAmplitude::initWithAction(cocos2d::Action* action, float duration)
{
	auto __o = this->thiz<AccelAmplitude *>();
	if (__o)
	{
		return __o->initWithAction(action, duration);
	}
	return false;
}

cocos2d::AccelAmplitude* QtScriptAccelAmplitude::reverse()
{
	auto __o = this->thiz<AccelAmplitude *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptAccelAmplitude::setRate(float rate)
{
	auto __o = this->thiz<AccelAmplitude *>();
	if (__o)
	{
		__o->setRate(rate);
	}
}

QScriptValue QtScriptAccelAmplitude::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Action*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(AccelAmplitude::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::AccelAmplitude::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptDeccelAmplitude::QtScriptDeccelAmplitude(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptDeccelAmplitude::QtScriptDeccelAmplitude(QScriptEngine *engine)
	: QtScriptDeccelAmplitude(engine, "DeccelAmplitude")
{
}

void QtScriptDeccelAmplitude::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<DeccelAmplitude, QtScriptDeccelAmplitude>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptDeccelAmplitude::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptDeccelAmplitude::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptDeccelAmplitude::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptDeccelAmplitude::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::DeccelAmplitude");
	return false;
}

cocos2d::DeccelAmplitude* QtScriptDeccelAmplitude::clone()
{
	auto __o = this->thiz<DeccelAmplitude *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptDeccelAmplitude::getRate()
{
	auto __o = this->thiz<DeccelAmplitude *>();
	if (__o)
	{
		return __o->getRate();
	}
	return static_cast<float>(0);
}

bool QtScriptDeccelAmplitude::initWithAction(cocos2d::Action* action, float duration)
{
	auto __o = this->thiz<DeccelAmplitude *>();
	if (__o)
	{
		return __o->initWithAction(action, duration);
	}
	return false;
}

cocos2d::DeccelAmplitude* QtScriptDeccelAmplitude::reverse()
{
	auto __o = this->thiz<DeccelAmplitude *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

void QtScriptDeccelAmplitude::setRate(float rate)
{
	auto __o = this->thiz<DeccelAmplitude *>();
	if (__o)
	{
		__o->setRate(rate);
	}
}

QScriptValue QtScriptDeccelAmplitude::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Action*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(DeccelAmplitude::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::DeccelAmplitude::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptStopGrid::QtScriptStopGrid(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInstant(engine, className)
{
}

QtScriptStopGrid::QtScriptStopGrid(QScriptEngine *engine)
	: QtScriptStopGrid(engine, "StopGrid")
{
}

void QtScriptStopGrid::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInstant *>());
	auto ctor = RegisterT<StopGrid, QtScriptStopGrid>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptStopGrid::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptStopGrid::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptStopGrid::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptStopGrid::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::StopGrid");
	return false;
}

cocos2d::StopGrid* QtScriptStopGrid::clone()
{
	auto __o = this->thiz<StopGrid *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::StopGrid* QtScriptStopGrid::reverse()
{
	auto __o = this->thiz<StopGrid *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptStopGrid::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(StopGrid::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::StopGrid::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptReuseGrid::QtScriptReuseGrid(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInstant(engine, className)
{
}

QtScriptReuseGrid::QtScriptReuseGrid(QScriptEngine *engine)
	: QtScriptReuseGrid(engine, "ReuseGrid")
{
}

void QtScriptReuseGrid::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInstant *>());
	auto ctor = RegisterT<ReuseGrid, QtScriptReuseGrid>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptReuseGrid::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptReuseGrid::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptReuseGrid::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptReuseGrid::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ReuseGrid");
	return false;
}

cocos2d::ReuseGrid* QtScriptReuseGrid::clone()
{
	auto __o = this->thiz<ReuseGrid *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptReuseGrid::initWithTimes(int times)
{
	auto __o = this->thiz<ReuseGrid *>();
	if (__o)
	{
		return __o->initWithTimes(times);
	}
	return false;
}

cocos2d::ReuseGrid* QtScriptReuseGrid::reverse()
{
	auto __o = this->thiz<ReuseGrid *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptReuseGrid::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			return __e->toScriptValue(ReuseGrid::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ReuseGrid::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptWaves3D::QtScriptWaves3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptGrid3DAction(engine, className)
{
}

QtScriptWaves3D::QtScriptWaves3D(QScriptEngine *engine)
	: QtScriptWaves3D(engine, "Waves3D")
{
}

void QtScriptWaves3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Grid3DAction *>());
	auto ctor = RegisterT<Waves3D, QtScriptWaves3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptWaves3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptWaves3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptWaves3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptWaves3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Waves3D");
	return false;
}

cocos2d::Waves3D* QtScriptWaves3D::clone()
{
	auto __o = this->thiz<Waves3D *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptWaves3D::getAmplitude()
{
	auto __o = this->thiz<Waves3D *>();
	if (__o)
	{
		return __o->getAmplitude();
	}
	return static_cast<float>(0);
}

float QtScriptWaves3D::getAmplitudeRate()
{
	auto __o = this->thiz<Waves3D *>();
	if (__o)
	{
		return __o->getAmplitudeRate();
	}
	return static_cast<float>(0);
}

bool QtScriptWaves3D::initWithDuration(float duration, const cocos2d::Size& gridSize, unsigned int waves, float amplitude)
{
	auto __o = this->thiz<Waves3D *>();
	if (__o)
	{
		return __o->initWithDuration(duration, gridSize, waves, amplitude);
	}
	return false;
}

void QtScriptWaves3D::setAmplitude(float amplitude)
{
	auto __o = this->thiz<Waves3D *>();
	if (__o)
	{
		__o->setAmplitude(amplitude);
	}
}

void QtScriptWaves3D::setAmplitudeRate(float amplitudeRate)
{
	auto __o = this->thiz<Waves3D *>();
	if (__o)
	{
		__o->setAmplitudeRate(amplitudeRate);
	}
}

QScriptValue QtScriptWaves3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			auto arg2 = qscriptvalue_cast<unsigned int>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			return __e->toScriptValue(Waves3D::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Waves3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptFlipX3D::QtScriptFlipX3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptGrid3DAction(engine, className)
{
}

QtScriptFlipX3D::QtScriptFlipX3D(QScriptEngine *engine)
	: QtScriptFlipX3D(engine, "FlipX3D")
{
}

void QtScriptFlipX3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Grid3DAction *>());
	auto ctor = RegisterT<FlipX3D, QtScriptFlipX3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFlipX3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptFlipX3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFlipX3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFlipX3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::FlipX3D");
	return false;
}

cocos2d::FlipX3D* QtScriptFlipX3D::clone()
{
	auto __o = this->thiz<FlipX3D *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptFlipX3D::initWithDuration(float duration)
{
	auto __o = this->thiz<FlipX3D *>();
	if (__o)
	{
		return __o->initWithDuration(duration);
	}
	return false;
}

bool QtScriptFlipX3D::initWithSize(const cocos2d::Size& gridSize, float duration)
{
	auto __o = this->thiz<FlipX3D *>();
	if (__o)
	{
		return __o->initWithSize(gridSize, duration);
	}
	return false;
}

QScriptValue QtScriptFlipX3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			return __e->toScriptValue(FlipX3D::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FlipX3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptFlipY3D::QtScriptFlipY3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptFlipX3D(engine, className)
{
}

QtScriptFlipY3D::QtScriptFlipY3D(QScriptEngine *engine)
	: QtScriptFlipY3D(engine, "FlipY3D")
{
}

void QtScriptFlipY3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<FlipX3D *>());
	auto ctor = RegisterT<FlipY3D, QtScriptFlipY3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFlipY3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptFlipY3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFlipY3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFlipY3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::FlipY3D");
	return false;
}

cocos2d::FlipY3D* QtScriptFlipY3D::clone()
{
	auto __o = this->thiz<FlipY3D *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

QScriptValue QtScriptFlipY3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			return __e->toScriptValue(FlipY3D::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FlipY3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptLens3D::QtScriptLens3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptGrid3DAction(engine, className)
{
}

QtScriptLens3D::QtScriptLens3D(QScriptEngine *engine)
	: QtScriptLens3D(engine, "Lens3D")
{
}

void QtScriptLens3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Grid3DAction *>());
	auto ctor = RegisterT<Lens3D, QtScriptLens3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptLens3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptLens3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptLens3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptLens3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Lens3D");
	return false;
}

cocos2d::Lens3D* QtScriptLens3D::clone()
{
	auto __o = this->thiz<Lens3D *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptLens3D::getLensEffect()
{
	auto __o = this->thiz<Lens3D *>();
	if (__o)
	{
		return __o->getLensEffect();
	}
	return static_cast<float>(0);
}

cocos2d::Vec2 QtScriptLens3D::getPosition()
{
	auto __o = this->thiz<Lens3D *>();
	if (__o)
	{
		return __o->getPosition();
	}
	return cocos2d::Vec2();
}

bool QtScriptLens3D::initWithDuration(float duration, const cocos2d::Size& gridSize, const cocos2d::Vec2& position, float radius)
{
	auto __o = this->thiz<Lens3D *>();
	if (__o)
	{
		return __o->initWithDuration(duration, gridSize, position, radius);
	}
	return false;
}

void QtScriptLens3D::setConcave(bool concave)
{
	auto __o = this->thiz<Lens3D *>();
	if (__o)
	{
		__o->setConcave(concave);
	}
}

void QtScriptLens3D::setLensEffect(float lensEffect)
{
	auto __o = this->thiz<Lens3D *>();
	if (__o)
	{
		__o->setLensEffect(lensEffect);
	}
}

void QtScriptLens3D::setPosition(const cocos2d::Vec2& position)
{
	auto __o = this->thiz<Lens3D *>();
	if (__o)
	{
		__o->setPosition(position);
	}
}

QScriptValue QtScriptLens3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			return __e->toScriptValue(Lens3D::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Lens3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptRipple3D::QtScriptRipple3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptGrid3DAction(engine, className)
{
}

QtScriptRipple3D::QtScriptRipple3D(QScriptEngine *engine)
	: QtScriptRipple3D(engine, "Ripple3D")
{
}

void QtScriptRipple3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Grid3DAction *>());
	auto ctor = RegisterT<Ripple3D, QtScriptRipple3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptRipple3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptRipple3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptRipple3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptRipple3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Ripple3D");
	return false;
}

cocos2d::Ripple3D* QtScriptRipple3D::clone()
{
	auto __o = this->thiz<Ripple3D *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptRipple3D::getAmplitude()
{
	auto __o = this->thiz<Ripple3D *>();
	if (__o)
	{
		return __o->getAmplitude();
	}
	return static_cast<float>(0);
}

float QtScriptRipple3D::getAmplitudeRate()
{
	auto __o = this->thiz<Ripple3D *>();
	if (__o)
	{
		return __o->getAmplitudeRate();
	}
	return static_cast<float>(0);
}

cocos2d::Vec2 QtScriptRipple3D::getPosition()
{
	auto __o = this->thiz<Ripple3D *>();
	if (__o)
	{
		return __o->getPosition();
	}
	return cocos2d::Vec2();
}

bool QtScriptRipple3D::initWithDuration(float duration, const cocos2d::Size& gridSize, const cocos2d::Vec2& position, float radius, unsigned int waves, float amplitude)
{
	auto __o = this->thiz<Ripple3D *>();
	if (__o)
	{
		return __o->initWithDuration(duration, gridSize, position, radius, waves, amplitude);
	}
	return false;
}

void QtScriptRipple3D::setAmplitude(float fAmplitude)
{
	auto __o = this->thiz<Ripple3D *>();
	if (__o)
	{
		__o->setAmplitude(fAmplitude);
	}
}

void QtScriptRipple3D::setAmplitudeRate(float fAmplitudeRate)
{
	auto __o = this->thiz<Ripple3D *>();
	if (__o)
	{
		__o->setAmplitudeRate(fAmplitudeRate);
	}
}

void QtScriptRipple3D::setPosition(const cocos2d::Vec2& position)
{
	auto __o = this->thiz<Ripple3D *>();
	if (__o)
	{
		__o->setPosition(position);
	}
}

QScriptValue QtScriptRipple3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 6, 6))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 6:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			auto arg4 = qscriptvalue_cast<unsigned int>(context->argument(4));
			auto arg5 = qscriptvalue_cast<float>(context->argument(5));
			return __e->toScriptValue(Ripple3D::create(arg0, arg1, arg2, arg3, arg4, arg5));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Ripple3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptShaky3D::QtScriptShaky3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptGrid3DAction(engine, className)
{
}

QtScriptShaky3D::QtScriptShaky3D(QScriptEngine *engine)
	: QtScriptShaky3D(engine, "Shaky3D")
{
}

void QtScriptShaky3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Grid3DAction *>());
	auto ctor = RegisterT<Shaky3D, QtScriptShaky3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptShaky3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptShaky3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptShaky3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptShaky3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Shaky3D");
	return false;
}

cocos2d::Shaky3D* QtScriptShaky3D::clone()
{
	auto __o = this->thiz<Shaky3D *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptShaky3D::initWithDuration(float duration, const cocos2d::Size& gridSize, int range, bool shakeZ)
{
	auto __o = this->thiz<Shaky3D *>();
	if (__o)
	{
		return __o->initWithDuration(duration, gridSize, range, shakeZ);
	}
	return false;
}

QScriptValue QtScriptShaky3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			auto arg2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg3 = qscriptvalue_cast<bool>(context->argument(3));
			return __e->toScriptValue(Shaky3D::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Shaky3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptLiquid::QtScriptLiquid(QScriptEngine *engine, const QByteArray &className)
	: QtScriptGrid3DAction(engine, className)
{
}

QtScriptLiquid::QtScriptLiquid(QScriptEngine *engine)
	: QtScriptLiquid(engine, "Liquid")
{
}

void QtScriptLiquid::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Grid3DAction *>());
	auto ctor = RegisterT<Liquid, QtScriptLiquid>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptLiquid::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptLiquid::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptLiquid::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptLiquid::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Liquid");
	return false;
}

cocos2d::Liquid* QtScriptLiquid::clone()
{
	auto __o = this->thiz<Liquid *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptLiquid::getAmplitude()
{
	auto __o = this->thiz<Liquid *>();
	if (__o)
	{
		return __o->getAmplitude();
	}
	return static_cast<float>(0);
}

float QtScriptLiquid::getAmplitudeRate()
{
	auto __o = this->thiz<Liquid *>();
	if (__o)
	{
		return __o->getAmplitudeRate();
	}
	return static_cast<float>(0);
}

bool QtScriptLiquid::initWithDuration(float duration, const cocos2d::Size& gridSize, unsigned int waves, float amplitude)
{
	auto __o = this->thiz<Liquid *>();
	if (__o)
	{
		return __o->initWithDuration(duration, gridSize, waves, amplitude);
	}
	return false;
}

void QtScriptLiquid::setAmplitude(float amplitude)
{
	auto __o = this->thiz<Liquid *>();
	if (__o)
	{
		__o->setAmplitude(amplitude);
	}
}

void QtScriptLiquid::setAmplitudeRate(float amplitudeRate)
{
	auto __o = this->thiz<Liquid *>();
	if (__o)
	{
		__o->setAmplitudeRate(amplitudeRate);
	}
}

QScriptValue QtScriptLiquid::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			auto arg2 = qscriptvalue_cast<unsigned int>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			return __e->toScriptValue(Liquid::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Liquid::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptWaves::QtScriptWaves(QScriptEngine *engine, const QByteArray &className)
	: QtScriptGrid3DAction(engine, className)
{
}

QtScriptWaves::QtScriptWaves(QScriptEngine *engine)
	: QtScriptWaves(engine, "Waves")
{
}

void QtScriptWaves::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Grid3DAction *>());
	auto ctor = RegisterT<Waves, QtScriptWaves>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptWaves::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptWaves::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptWaves::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptWaves::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Waves");
	return false;
}

cocos2d::Waves* QtScriptWaves::clone()
{
	auto __o = this->thiz<Waves *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptWaves::getAmplitude()
{
	auto __o = this->thiz<Waves *>();
	if (__o)
	{
		return __o->getAmplitude();
	}
	return static_cast<float>(0);
}

float QtScriptWaves::getAmplitudeRate()
{
	auto __o = this->thiz<Waves *>();
	if (__o)
	{
		return __o->getAmplitudeRate();
	}
	return static_cast<float>(0);
}

bool QtScriptWaves::initWithDuration(float duration, const cocos2d::Size& gridSize, unsigned int waves, float amplitude, bool horizontal, bool vertical)
{
	auto __o = this->thiz<Waves *>();
	if (__o)
	{
		return __o->initWithDuration(duration, gridSize, waves, amplitude, horizontal, vertical);
	}
	return false;
}

void QtScriptWaves::setAmplitude(float amplitude)
{
	auto __o = this->thiz<Waves *>();
	if (__o)
	{
		__o->setAmplitude(amplitude);
	}
}

void QtScriptWaves::setAmplitudeRate(float amplitudeRate)
{
	auto __o = this->thiz<Waves *>();
	if (__o)
	{
		__o->setAmplitudeRate(amplitudeRate);
	}
}

QScriptValue QtScriptWaves::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 6, 6))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 6:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			auto arg2 = qscriptvalue_cast<unsigned int>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			auto arg4 = qscriptvalue_cast<bool>(context->argument(4));
			auto arg5 = qscriptvalue_cast<bool>(context->argument(5));
			return __e->toScriptValue(Waves::create(arg0, arg1, arg2, arg3, arg4, arg5));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Waves::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptTwirl::QtScriptTwirl(QScriptEngine *engine, const QByteArray &className)
	: QtScriptGrid3DAction(engine, className)
{
}

QtScriptTwirl::QtScriptTwirl(QScriptEngine *engine)
	: QtScriptTwirl(engine, "Twirl")
{
}

void QtScriptTwirl::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Grid3DAction *>());
	auto ctor = RegisterT<Twirl, QtScriptTwirl>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTwirl::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptTwirl::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTwirl::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTwirl::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Twirl");
	return false;
}

cocos2d::Twirl* QtScriptTwirl::clone()
{
	auto __o = this->thiz<Twirl *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptTwirl::getAmplitude()
{
	auto __o = this->thiz<Twirl *>();
	if (__o)
	{
		return __o->getAmplitude();
	}
	return static_cast<float>(0);
}

float QtScriptTwirl::getAmplitudeRate()
{
	auto __o = this->thiz<Twirl *>();
	if (__o)
	{
		return __o->getAmplitudeRate();
	}
	return static_cast<float>(0);
}

cocos2d::Vec2 QtScriptTwirl::getPosition()
{
	auto __o = this->thiz<Twirl *>();
	if (__o)
	{
		return __o->getPosition();
	}
	return cocos2d::Vec2();
}

bool QtScriptTwirl::initWithDuration(float duration, const cocos2d::Size& gridSize, const cocos2d::Vec2& position, unsigned int twirls, float amplitude)
{
	auto __o = this->thiz<Twirl *>();
	if (__o)
	{
		return __o->initWithDuration(duration, gridSize, position, twirls, amplitude);
	}
	return false;
}

void QtScriptTwirl::setAmplitude(float amplitude)
{
	auto __o = this->thiz<Twirl *>();
	if (__o)
	{
		__o->setAmplitude(amplitude);
	}
}

void QtScriptTwirl::setAmplitudeRate(float amplitudeRate)
{
	auto __o = this->thiz<Twirl *>();
	if (__o)
	{
		__o->setAmplitudeRate(amplitudeRate);
	}
}

void QtScriptTwirl::setPosition(const cocos2d::Vec2& position)
{
	auto __o = this->thiz<Twirl *>();
	if (__o)
	{
		__o->setPosition(position);
	}
}

QScriptValue QtScriptTwirl::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 5, 5))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 5:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(2));
			auto arg3 = qscriptvalue_cast<unsigned int>(context->argument(3));
			auto arg4 = qscriptvalue_cast<float>(context->argument(4));
			return __e->toScriptValue(Twirl::create(arg0, arg1, arg2, arg3, arg4));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Twirl::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptActionManager::QtScriptActionManager(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptActionManager::QtScriptActionManager(QScriptEngine *engine)
	: QtScriptActionManager(engine, "ActionManager")
{
}

void QtScriptActionManager::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<ActionManager, QtScriptActionManager>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

void QtScriptActionManager::addAction(cocos2d::Action* action, cocos2d::Node* target, bool paused)
{
	auto __o = this->thiz<ActionManager *>();
	if (__o)
	{
		__o->addAction(action, target, paused);
	}
}

cocos2d::Action* QtScriptActionManager::getActionByTag(int tag, const cocos2d::Node* target)
{
	auto __o = this->thiz<ActionManager *>();
	if (__o)
	{
		return __o->getActionByTag(tag, target);
	}
	return nullptr;
}

int QtScriptActionManager::getNumberOfRunningActions()
{
	auto __o = this->thiz<ActionManager *>();
	if (__o)
	{
		return int(__o->getNumberOfRunningActions());
	}
	return 0;
}

int QtScriptActionManager::getNumberOfRunningActionsInTarget(const cocos2d::Node* target)
{
	auto __o = this->thiz<ActionManager *>();
	if (__o)
	{
		return int(__o->getNumberOfRunningActionsInTarget(target));
	}
	return 0;
}

unsigned QtScriptActionManager::getNumberOfRunningActionsInTargetByTag(const cocos2d::Node* target, int tag)
{
	auto __o = this->thiz<ActionManager *>();
	if (__o)
	{
		return unsigned(__o->getNumberOfRunningActionsInTargetByTag(target, tag));
	}
	return static_cast<unsigned>(0);
}

cocos2d::Vector<cocos2d::Node *> QtScriptActionManager::pauseAllRunningActions()
{
	auto __o = this->thiz<ActionManager *>();
	if (__o)
	{
		return __o->pauseAllRunningActions();
	}
	return cocos2d::Vector<cocos2d::Node *>();
}

void QtScriptActionManager::pauseTarget(cocos2d::Node* target)
{
	auto __o = this->thiz<ActionManager *>();
	if (__o)
	{
		__o->pauseTarget(target);
	}
}

void QtScriptActionManager::removeAction(cocos2d::Action* action)
{
	auto __o = this->thiz<ActionManager *>();
	if (__o)
	{
		__o->removeAction(action);
	}
}

void QtScriptActionManager::removeActionByTag(int tag, cocos2d::Node* target)
{
	auto __o = this->thiz<ActionManager *>();
	if (__o)
	{
		__o->removeActionByTag(tag, target);
	}
}

void QtScriptActionManager::removeActionsByFlags(unsigned int flags, cocos2d::Node* target)
{
	auto __o = this->thiz<ActionManager *>();
	if (__o)
	{
		__o->removeActionsByFlags(flags, target);
	}
}

void QtScriptActionManager::removeAllActions()
{
	auto __o = this->thiz<ActionManager *>();
	if (__o)
	{
		__o->removeAllActions();
	}
}

void QtScriptActionManager::removeAllActionsByTag(int tag, cocos2d::Node* target)
{
	auto __o = this->thiz<ActionManager *>();
	if (__o)
	{
		__o->removeAllActionsByTag(tag, target);
	}
}

void QtScriptActionManager::removeAllActionsFromTarget(cocos2d::Node* target)
{
	auto __o = this->thiz<ActionManager *>();
	if (__o)
	{
		__o->removeAllActionsFromTarget(target);
	}
}

void QtScriptActionManager::resumeTarget(cocos2d::Node* target)
{
	auto __o = this->thiz<ActionManager *>();
	if (__o)
	{
		__o->resumeTarget(target);
	}
}

void QtScriptActionManager::resumeTargets(const cocos2d::Vector<cocos2d::Node *>& targetsToResume)
{
	auto __o = this->thiz<ActionManager *>();
	if (__o)
	{
		__o->resumeTargets(targetsToResume);
	}
}

int QtScriptActionManager::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptActionManager::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptActionManager::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new ActionManager();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::ActionManager constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptPageTurn3D::QtScriptPageTurn3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptGrid3DAction(engine, className)
{
}

QtScriptPageTurn3D::QtScriptPageTurn3D(QScriptEngine *engine)
	: QtScriptPageTurn3D(engine, "PageTurn3D")
{
}

void QtScriptPageTurn3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Grid3DAction *>());
	auto ctor = RegisterT<PageTurn3D, QtScriptPageTurn3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptPageTurn3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptPageTurn3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptPageTurn3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptPageTurn3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::PageTurn3D");
	return false;
}

cocos2d::PageTurn3D* QtScriptPageTurn3D::clone()
{
	auto __o = this->thiz<PageTurn3D *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

QScriptValue QtScriptPageTurn3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			return __e->toScriptValue(PageTurn3D::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::PageTurn3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptProgressTo::QtScriptProgressTo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptProgressTo::QtScriptProgressTo(QScriptEngine *engine)
	: QtScriptProgressTo(engine, "ProgressTo")
{
}

void QtScriptProgressTo::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<ProgressTo, QtScriptProgressTo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptProgressTo::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptProgressTo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptProgressTo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptProgressTo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ProgressTo");
	return false;
}

cocos2d::ProgressTo* QtScriptProgressTo::clone()
{
	auto __o = this->thiz<ProgressTo *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptProgressTo::initWithDuration(float duration, float percent)
{
	auto __o = this->thiz<ProgressTo *>();
	if (__o)
	{
		return __o->initWithDuration(duration, percent);
	}
	return false;
}

cocos2d::ProgressTo* QtScriptProgressTo::reverse()
{
	auto __o = this->thiz<ProgressTo *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptProgressTo::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(ProgressTo::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ProgressTo::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptProgressFromTo::QtScriptProgressFromTo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptProgressFromTo::QtScriptProgressFromTo(QScriptEngine *engine)
	: QtScriptProgressFromTo(engine, "ProgressFromTo")
{
}

void QtScriptProgressFromTo::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<ProgressFromTo, QtScriptProgressFromTo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptProgressFromTo::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptProgressFromTo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptProgressFromTo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptProgressFromTo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ProgressFromTo");
	return false;
}

cocos2d::ProgressFromTo* QtScriptProgressFromTo::clone()
{
	auto __o = this->thiz<ProgressFromTo *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptProgressFromTo::initWithDuration(float duration, float fromPercentage, float toPercentage)
{
	auto __o = this->thiz<ProgressFromTo *>();
	if (__o)
	{
		return __o->initWithDuration(duration, fromPercentage, toPercentage);
	}
	return false;
}

cocos2d::ProgressFromTo* QtScriptProgressFromTo::reverse()
{
	auto __o = this->thiz<ProgressFromTo *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptProgressFromTo::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 3, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 3:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(ProgressFromTo::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ProgressFromTo::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptShakyTiles3D::QtScriptShakyTiles3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptTiledGrid3DAction(engine, className)
{
}

QtScriptShakyTiles3D::QtScriptShakyTiles3D(QScriptEngine *engine)
	: QtScriptShakyTiles3D(engine, "ShakyTiles3D")
{
}

void QtScriptShakyTiles3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<TiledGrid3DAction *>());
	auto ctor = RegisterT<ShakyTiles3D, QtScriptShakyTiles3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptShakyTiles3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptShakyTiles3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptShakyTiles3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptShakyTiles3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ShakyTiles3D");
	return false;
}

cocos2d::ShakyTiles3D* QtScriptShakyTiles3D::clone()
{
	auto __o = this->thiz<ShakyTiles3D *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptShakyTiles3D::initWithDuration(float duration, const cocos2d::Size& gridSize, int range, bool shakeZ)
{
	auto __o = this->thiz<ShakyTiles3D *>();
	if (__o)
	{
		return __o->initWithDuration(duration, gridSize, range, shakeZ);
	}
	return false;
}

QScriptValue QtScriptShakyTiles3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			auto arg2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg3 = qscriptvalue_cast<bool>(context->argument(3));
			return __e->toScriptValue(ShakyTiles3D::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ShakyTiles3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptShatteredTiles3D::QtScriptShatteredTiles3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptTiledGrid3DAction(engine, className)
{
}

QtScriptShatteredTiles3D::QtScriptShatteredTiles3D(QScriptEngine *engine)
	: QtScriptShatteredTiles3D(engine, "ShatteredTiles3D")
{
}

void QtScriptShatteredTiles3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<TiledGrid3DAction *>());
	auto ctor = RegisterT<ShatteredTiles3D, QtScriptShatteredTiles3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptShatteredTiles3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptShatteredTiles3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptShatteredTiles3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptShatteredTiles3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ShatteredTiles3D");
	return false;
}

cocos2d::ShatteredTiles3D* QtScriptShatteredTiles3D::clone()
{
	auto __o = this->thiz<ShatteredTiles3D *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptShatteredTiles3D::initWithDuration(float duration, const cocos2d::Size& gridSize, int range, bool shatterZ)
{
	auto __o = this->thiz<ShatteredTiles3D *>();
	if (__o)
	{
		return __o->initWithDuration(duration, gridSize, range, shatterZ);
	}
	return false;
}

QScriptValue QtScriptShatteredTiles3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			auto arg2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg3 = qscriptvalue_cast<bool>(context->argument(3));
			return __e->toScriptValue(ShatteredTiles3D::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ShatteredTiles3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptShuffleTiles::QtScriptShuffleTiles(QScriptEngine *engine, const QByteArray &className)
	: QtScriptTiledGrid3DAction(engine, className)
{
}

QtScriptShuffleTiles::QtScriptShuffleTiles(QScriptEngine *engine)
	: QtScriptShuffleTiles(engine, "ShuffleTiles")
{
}

void QtScriptShuffleTiles::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<TiledGrid3DAction *>());
	auto ctor = RegisterT<ShuffleTiles, QtScriptShuffleTiles>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptShuffleTiles::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptShuffleTiles::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptShuffleTiles::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptShuffleTiles::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ShuffleTiles");
	return false;
}

cocos2d::ShuffleTiles* QtScriptShuffleTiles::clone()
{
	auto __o = this->thiz<ShuffleTiles *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

cocos2d::Size QtScriptShuffleTiles::getDelta(const cocos2d::Size& pos)
{
	auto __o = this->thiz<ShuffleTiles *>();
	if (__o)
	{
		return __o->getDelta(pos);
	}
	return cocos2d::Size();
}

bool QtScriptShuffleTiles::initWithDuration(float duration, const cocos2d::Size& gridSize, unsigned int seed)
{
	auto __o = this->thiz<ShuffleTiles *>();
	if (__o)
	{
		return __o->initWithDuration(duration, gridSize, seed);
	}
	return false;
}

void QtScriptShuffleTiles::placeTile(const cocos2d::Vec2& pos, cocos2d::Tile* t)
{
	auto __o = this->thiz<ShuffleTiles *>();
	if (__o)
	{
		__o->placeTile(pos, t);
	}
}

QScriptValue QtScriptShuffleTiles::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 3, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 3:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			auto arg2 = qscriptvalue_cast<unsigned int>(context->argument(2));
			return __e->toScriptValue(ShuffleTiles::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ShuffleTiles::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptFadeOutTRTiles::QtScriptFadeOutTRTiles(QScriptEngine *engine, const QByteArray &className)
	: QtScriptTiledGrid3DAction(engine, className)
{
}

QtScriptFadeOutTRTiles::QtScriptFadeOutTRTiles(QScriptEngine *engine)
	: QtScriptFadeOutTRTiles(engine, "FadeOutTRTiles")
{
}

void QtScriptFadeOutTRTiles::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<TiledGrid3DAction *>());
	auto ctor = RegisterT<FadeOutTRTiles, QtScriptFadeOutTRTiles>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFadeOutTRTiles::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptFadeOutTRTiles::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFadeOutTRTiles::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFadeOutTRTiles::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::FadeOutTRTiles");
	return false;
}

cocos2d::FadeOutTRTiles* QtScriptFadeOutTRTiles::clone()
{
	auto __o = this->thiz<FadeOutTRTiles *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptFadeOutTRTiles::testFunc(const cocos2d::Size& pos, float time)
{
	auto __o = this->thiz<FadeOutTRTiles *>();
	if (__o)
	{
		return __o->testFunc(pos, time);
	}
	return static_cast<float>(0);
}

void QtScriptFadeOutTRTiles::transformTile(const cocos2d::Vec2& pos, float distance)
{
	auto __o = this->thiz<FadeOutTRTiles *>();
	if (__o)
	{
		__o->transformTile(pos, distance);
	}
}

void QtScriptFadeOutTRTiles::turnOffTile(const cocos2d::Vec2& pos)
{
	auto __o = this->thiz<FadeOutTRTiles *>();
	if (__o)
	{
		__o->turnOffTile(pos);
	}
}

void QtScriptFadeOutTRTiles::turnOnTile(const cocos2d::Vec2& pos)
{
	auto __o = this->thiz<FadeOutTRTiles *>();
	if (__o)
	{
		__o->turnOnTile(pos);
	}
}

QScriptValue QtScriptFadeOutTRTiles::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			return __e->toScriptValue(FadeOutTRTiles::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FadeOutTRTiles::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptFadeOutBLTiles::QtScriptFadeOutBLTiles(QScriptEngine *engine, const QByteArray &className)
	: QtScriptFadeOutTRTiles(engine, className)
{
}

QtScriptFadeOutBLTiles::QtScriptFadeOutBLTiles(QScriptEngine *engine)
	: QtScriptFadeOutBLTiles(engine, "FadeOutBLTiles")
{
}

void QtScriptFadeOutBLTiles::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<FadeOutTRTiles *>());
	auto ctor = RegisterT<FadeOutBLTiles, QtScriptFadeOutBLTiles>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFadeOutBLTiles::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptFadeOutBLTiles::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFadeOutBLTiles::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFadeOutBLTiles::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::FadeOutBLTiles");
	return false;
}

cocos2d::FadeOutBLTiles* QtScriptFadeOutBLTiles::clone()
{
	auto __o = this->thiz<FadeOutBLTiles *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

QScriptValue QtScriptFadeOutBLTiles::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			return __e->toScriptValue(FadeOutBLTiles::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FadeOutBLTiles::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptFadeOutUpTiles::QtScriptFadeOutUpTiles(QScriptEngine *engine, const QByteArray &className)
	: QtScriptFadeOutTRTiles(engine, className)
{
}

QtScriptFadeOutUpTiles::QtScriptFadeOutUpTiles(QScriptEngine *engine)
	: QtScriptFadeOutUpTiles(engine, "FadeOutUpTiles")
{
}

void QtScriptFadeOutUpTiles::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<FadeOutTRTiles *>());
	auto ctor = RegisterT<FadeOutUpTiles, QtScriptFadeOutUpTiles>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFadeOutUpTiles::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptFadeOutUpTiles::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFadeOutUpTiles::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFadeOutUpTiles::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::FadeOutUpTiles");
	return false;
}

cocos2d::FadeOutUpTiles* QtScriptFadeOutUpTiles::clone()
{
	auto __o = this->thiz<FadeOutUpTiles *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

QScriptValue QtScriptFadeOutUpTiles::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			return __e->toScriptValue(FadeOutUpTiles::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FadeOutUpTiles::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptFadeOutDownTiles::QtScriptFadeOutDownTiles(QScriptEngine *engine, const QByteArray &className)
	: QtScriptFadeOutUpTiles(engine, className)
{
}

QtScriptFadeOutDownTiles::QtScriptFadeOutDownTiles(QScriptEngine *engine)
	: QtScriptFadeOutDownTiles(engine, "FadeOutDownTiles")
{
}

void QtScriptFadeOutDownTiles::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<FadeOutUpTiles *>());
	auto ctor = RegisterT<FadeOutDownTiles, QtScriptFadeOutDownTiles>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFadeOutDownTiles::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptFadeOutDownTiles::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFadeOutDownTiles::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFadeOutDownTiles::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::FadeOutDownTiles");
	return false;
}

cocos2d::FadeOutDownTiles* QtScriptFadeOutDownTiles::clone()
{
	auto __o = this->thiz<FadeOutDownTiles *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

QScriptValue QtScriptFadeOutDownTiles::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			return __e->toScriptValue(FadeOutDownTiles::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FadeOutDownTiles::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptTurnOffTiles::QtScriptTurnOffTiles(QScriptEngine *engine, const QByteArray &className)
	: QtScriptTiledGrid3DAction(engine, className)
{
}

QtScriptTurnOffTiles::QtScriptTurnOffTiles(QScriptEngine *engine)
	: QtScriptTurnOffTiles(engine, "TurnOffTiles")
{
}

void QtScriptTurnOffTiles::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<TiledGrid3DAction *>());
	auto ctor = RegisterT<TurnOffTiles, QtScriptTurnOffTiles>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTurnOffTiles::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptTurnOffTiles::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTurnOffTiles::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTurnOffTiles::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::TurnOffTiles");
	return false;
}

cocos2d::TurnOffTiles* QtScriptTurnOffTiles::clone()
{
	auto __o = this->thiz<TurnOffTiles *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptTurnOffTiles::initWithDuration(float duration, const cocos2d::Size& gridSize, unsigned int seed)
{
	auto __o = this->thiz<TurnOffTiles *>();
	if (__o)
	{
		return __o->initWithDuration(duration, gridSize, seed);
	}
	return false;
}

void QtScriptTurnOffTiles::turnOffTile(const cocos2d::Vec2& pos)
{
	auto __o = this->thiz<TurnOffTiles *>();
	if (__o)
	{
		__o->turnOffTile(pos);
	}
}

void QtScriptTurnOffTiles::turnOnTile(const cocos2d::Vec2& pos)
{
	auto __o = this->thiz<TurnOffTiles *>();
	if (__o)
	{
		__o->turnOnTile(pos);
	}
}

QScriptValue QtScriptTurnOffTiles::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			return __e->toScriptValue(TurnOffTiles::create(arg0, arg1));
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			auto arg2 = qscriptvalue_cast<unsigned int>(context->argument(2));
			return __e->toScriptValue(TurnOffTiles::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::TurnOffTiles::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptWavesTiles3D::QtScriptWavesTiles3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptTiledGrid3DAction(engine, className)
{
}

QtScriptWavesTiles3D::QtScriptWavesTiles3D(QScriptEngine *engine)
	: QtScriptWavesTiles3D(engine, "WavesTiles3D")
{
}

void QtScriptWavesTiles3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<TiledGrid3DAction *>());
	auto ctor = RegisterT<WavesTiles3D, QtScriptWavesTiles3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptWavesTiles3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptWavesTiles3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptWavesTiles3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptWavesTiles3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::WavesTiles3D");
	return false;
}

cocos2d::WavesTiles3D* QtScriptWavesTiles3D::clone()
{
	auto __o = this->thiz<WavesTiles3D *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptWavesTiles3D::getAmplitude()
{
	auto __o = this->thiz<WavesTiles3D *>();
	if (__o)
	{
		return __o->getAmplitude();
	}
	return static_cast<float>(0);
}

float QtScriptWavesTiles3D::getAmplitudeRate()
{
	auto __o = this->thiz<WavesTiles3D *>();
	if (__o)
	{
		return __o->getAmplitudeRate();
	}
	return static_cast<float>(0);
}

bool QtScriptWavesTiles3D::initWithDuration(float duration, const cocos2d::Size& gridSize, unsigned int waves, float amplitude)
{
	auto __o = this->thiz<WavesTiles3D *>();
	if (__o)
	{
		return __o->initWithDuration(duration, gridSize, waves, amplitude);
	}
	return false;
}

void QtScriptWavesTiles3D::setAmplitude(float amplitude)
{
	auto __o = this->thiz<WavesTiles3D *>();
	if (__o)
	{
		__o->setAmplitude(amplitude);
	}
}

void QtScriptWavesTiles3D::setAmplitudeRate(float amplitudeRate)
{
	auto __o = this->thiz<WavesTiles3D *>();
	if (__o)
	{
		__o->setAmplitudeRate(amplitudeRate);
	}
}

QScriptValue QtScriptWavesTiles3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			auto arg2 = qscriptvalue_cast<unsigned int>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			return __e->toScriptValue(WavesTiles3D::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::WavesTiles3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptJumpTiles3D::QtScriptJumpTiles3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptTiledGrid3DAction(engine, className)
{
}

QtScriptJumpTiles3D::QtScriptJumpTiles3D(QScriptEngine *engine)
	: QtScriptJumpTiles3D(engine, "JumpTiles3D")
{
}

void QtScriptJumpTiles3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<TiledGrid3DAction *>());
	auto ctor = RegisterT<JumpTiles3D, QtScriptJumpTiles3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptJumpTiles3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptJumpTiles3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptJumpTiles3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptJumpTiles3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::JumpTiles3D");
	return false;
}

cocos2d::JumpTiles3D* QtScriptJumpTiles3D::clone()
{
	auto __o = this->thiz<JumpTiles3D *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

float QtScriptJumpTiles3D::getAmplitude()
{
	auto __o = this->thiz<JumpTiles3D *>();
	if (__o)
	{
		return __o->getAmplitude();
	}
	return static_cast<float>(0);
}

float QtScriptJumpTiles3D::getAmplitudeRate()
{
	auto __o = this->thiz<JumpTiles3D *>();
	if (__o)
	{
		return __o->getAmplitudeRate();
	}
	return static_cast<float>(0);
}

bool QtScriptJumpTiles3D::initWithDuration(float duration, const cocos2d::Size& gridSize, unsigned int numberOfJumps, float amplitude)
{
	auto __o = this->thiz<JumpTiles3D *>();
	if (__o)
	{
		return __o->initWithDuration(duration, gridSize, numberOfJumps, amplitude);
	}
	return false;
}

void QtScriptJumpTiles3D::setAmplitude(float amplitude)
{
	auto __o = this->thiz<JumpTiles3D *>();
	if (__o)
	{
		__o->setAmplitude(amplitude);
	}
}

void QtScriptJumpTiles3D::setAmplitudeRate(float amplitudeRate)
{
	auto __o = this->thiz<JumpTiles3D *>();
	if (__o)
	{
		__o->setAmplitudeRate(amplitudeRate);
	}
}

QScriptValue QtScriptJumpTiles3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Size>(context->argument(1));
			auto arg2 = qscriptvalue_cast<unsigned int>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			return __e->toScriptValue(JumpTiles3D::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::JumpTiles3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptSplitRows::QtScriptSplitRows(QScriptEngine *engine, const QByteArray &className)
	: QtScriptTiledGrid3DAction(engine, className)
{
}

QtScriptSplitRows::QtScriptSplitRows(QScriptEngine *engine)
	: QtScriptSplitRows(engine, "SplitRows")
{
}

void QtScriptSplitRows::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<TiledGrid3DAction *>());
	auto ctor = RegisterT<SplitRows, QtScriptSplitRows>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSplitRows::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSplitRows::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSplitRows::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSplitRows::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::SplitRows");
	return false;
}

cocos2d::SplitRows* QtScriptSplitRows::clone()
{
	auto __o = this->thiz<SplitRows *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptSplitRows::initWithDuration(float duration, unsigned int rows)
{
	auto __o = this->thiz<SplitRows *>();
	if (__o)
	{
		return __o->initWithDuration(duration, rows);
	}
	return false;
}

QScriptValue QtScriptSplitRows::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<unsigned int>(context->argument(1));
			return __e->toScriptValue(SplitRows::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::SplitRows::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptSplitCols::QtScriptSplitCols(QScriptEngine *engine, const QByteArray &className)
	: QtScriptTiledGrid3DAction(engine, className)
{
}

QtScriptSplitCols::QtScriptSplitCols(QScriptEngine *engine)
	: QtScriptSplitCols(engine, "SplitCols")
{
}

void QtScriptSplitCols::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<TiledGrid3DAction *>());
	auto ctor = RegisterT<SplitCols, QtScriptSplitCols>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSplitCols::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSplitCols::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSplitCols::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSplitCols::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::SplitCols");
	return false;
}

cocos2d::SplitCols* QtScriptSplitCols::clone()
{
	auto __o = this->thiz<SplitCols *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptSplitCols::initWithDuration(float duration, unsigned int cols)
{
	auto __o = this->thiz<SplitCols *>();
	if (__o)
	{
		return __o->initWithDuration(duration, cols);
	}
	return false;
}

QScriptValue QtScriptSplitCols::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<unsigned int>(context->argument(1));
			return __e->toScriptValue(SplitCols::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::SplitCols::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptActionTween::QtScriptActionTween(QScriptEngine *engine, const QByteArray &className)
	: QtScriptActionInterval(engine, className)
{
}

QtScriptActionTween::QtScriptActionTween(QScriptEngine *engine)
	: QtScriptActionTween(engine, "ActionTween")
{
}

void QtScriptActionTween::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ActionInterval *>());
	auto ctor = RegisterT<ActionTween, QtScriptActionTween>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptActionTween::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptActionTween::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptActionTween::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptActionTween::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ActionTween");
	return false;
}

cocos2d::ActionTween* QtScriptActionTween::clone()
{
	auto __o = this->thiz<ActionTween *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

bool QtScriptActionTween::initWithDuration(float duration, const QByteArray& key, float from, float to)
{
	auto __o = this->thiz<ActionTween *>();
	if (__o)
	{
		return __o->initWithDuration(duration, key.toStdString(), from, to);
	}
	return false;
}

cocos2d::ActionTween* QtScriptActionTween::reverse()
{
	auto __o = this->thiz<ActionTween *>();
	if (__o)
	{
		return __o->reverse();
	}
	return nullptr;
}

QScriptValue QtScriptActionTween::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			return __e->toScriptValue(ActionTween::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ActionTween::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptAtlasNode::QtScriptAtlasNode(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptAtlasNode::QtScriptAtlasNode(QScriptEngine *engine)
	: QtScriptAtlasNode(engine, "AtlasNode")
{
}

void QtScriptAtlasNode::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<AtlasNode, QtScriptAtlasNode>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAtlasNode::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptAtlasNode::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAtlasNode::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptAtlasNode::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::AtlasNode");
	return false;
}

cocos2d::BlendFunc QtScriptAtlasNode::getBlendFunc()
{
	auto __o = this->thiz<AtlasNode *>();
	if (__o)
	{
		return __o->getBlendFunc();
	}
	return cocos2d::BlendFunc();
}

unsigned QtScriptAtlasNode::getQuadsToDraw()
{
	auto __o = this->thiz<AtlasNode *>();
	if (__o)
	{
		return unsigned(__o->getQuadsToDraw());
	}
	return static_cast<unsigned>(0);
}

cocos2d::Texture2D* QtScriptAtlasNode::getTexture()
{
	auto __o = this->thiz<AtlasNode *>();
	if (__o)
	{
		return __o->getTexture();
	}
	return nullptr;
}

cocos2d::TextureAtlas* QtScriptAtlasNode::getTextureAtlas()
{
	auto __o = this->thiz<AtlasNode *>();
	if (__o)
	{
		return __o->getTextureAtlas();
	}
	return nullptr;
}

bool QtScriptAtlasNode::initWithTexture(cocos2d::Texture2D* texture, int tileWidth, int tileHeight, int itemsToRender)
{
	auto __o = this->thiz<AtlasNode *>();
	if (__o)
	{
		return __o->initWithTexture(texture, tileWidth, tileHeight, itemsToRender);
	}
	return false;
}

bool QtScriptAtlasNode::initWithTileFile(const QByteArray& tile, int tileWidth, int tileHeight, int itemsToRender)
{
	auto __o = this->thiz<AtlasNode *>();
	if (__o)
	{
		return __o->initWithTileFile(tile.toStdString(), tileWidth, tileHeight, itemsToRender);
	}
	return false;
}

void QtScriptAtlasNode::setBlendFunc(const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<AtlasNode *>();
	if (__o)
	{
		__o->setBlendFunc(blendFunc);
	}
}

void QtScriptAtlasNode::setQuadsToDraw(int quadsToDraw)
{
	auto __o = this->thiz<AtlasNode *>();
	if (__o)
	{
		__o->setQuadsToDraw(quadsToDraw);
	}
}

void QtScriptAtlasNode::setTexture(cocos2d::Texture2D* texture)
{
	auto __o = this->thiz<AtlasNode *>();
	if (__o)
	{
		__o->setTexture(texture);
	}
}

void QtScriptAtlasNode::setTextureAtlas(cocos2d::TextureAtlas* textureAtlas)
{
	auto __o = this->thiz<AtlasNode *>();
	if (__o)
	{
		__o->setTextureAtlas(textureAtlas);
	}
}

void QtScriptAtlasNode::updateAtlasValues()
{
	auto __o = this->thiz<AtlasNode *>();
	if (__o)
	{
		__o->updateAtlasValues();
	}
}

QScriptValue QtScriptAtlasNode::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<int>(context->argument(1));
			auto arg2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg3 = qscriptvalue_cast<int>(context->argument(3));
			return __e->toScriptValue(AtlasNode::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::AtlasNode::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptGroupCommand::QtScriptGroupCommand(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRenderCommand(engine, className)
{
}

QtScriptGroupCommand::QtScriptGroupCommand(QScriptEngine *engine)
	: QtScriptGroupCommand(engine, "GroupCommand")
{
}

void QtScriptGroupCommand::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<RenderCommand *>());
	auto ctor = RegisterT<GroupCommand, QtScriptGroupCommand>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptGroupCommand::getRenderQueueID()
{
	auto __o = this->thiz<GroupCommand *>();
	if (__o)
	{
		return __o->getRenderQueueID();
	}
	return 0;
}

void QtScriptGroupCommand::init(float globalOrder)
{
	auto __o = this->thiz<GroupCommand *>();
	if (__o)
	{
		__o->init(globalOrder);
	}
}

int QtScriptGroupCommand::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptGroupCommand::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptGroupCommand::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new GroupCommand();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::GroupCommand constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptCallbackCommand::QtScriptCallbackCommand(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRenderCommand(engine, className)
{
}

QtScriptCallbackCommand::QtScriptCallbackCommand(QScriptEngine *engine)
	: QtScriptCallbackCommand(engine, "CallbackCommand")
{
}

void QtScriptCallbackCommand::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<RenderCommand *>());
	auto ctor = RegisterT<CallbackCommand, QtScriptCallbackCommand>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

void QtScriptCallbackCommand::execute()
{
	auto __o = this->thiz<CallbackCommand *>();
	if (__o)
	{
		__o->execute();
	}
}

void QtScriptCallbackCommand::init(float globalZOrder)
{
	auto __o = this->thiz<CallbackCommand *>();
	if (__o)
	{
		__o->init(globalZOrder);
	}
}

void QtScriptCallbackCommand::init(float globalZorder, const cocos2d::Mat4& transform, unsigned int arg0)
{
	auto __o = this->thiz<CallbackCommand *>();
	if (__o)
	{
		__o->init(globalZorder, transform, arg0);
	}
}

int QtScriptCallbackCommand::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptCallbackCommand::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptCallbackCommand::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new CallbackCommand();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::CallbackCommand constructor");
	}
	return ok;
}


void QtScriptCallbackCommand::setFunc(QScriptValue value)
{
	auto __e = this->engine();
	auto object = thiz<CallbackCommand *>();
	if (object)
	{
		object->func = !value.isFunction() ? std::function<void ()>() : [=]() mutable -> void
{
	QScriptValueList arguments;
	value.call(QScriptValue(), arguments);
};
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptCaptureScreenCallbackCommand::QtScriptCaptureScreenCallbackCommand(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRenderCommand(engine, className)
{
}

QtScriptCaptureScreenCallbackCommand::QtScriptCaptureScreenCallbackCommand(QScriptEngine *engine)
	: QtScriptCaptureScreenCallbackCommand(engine, "CaptureScreenCallbackCommand")
{
}

void QtScriptCaptureScreenCallbackCommand::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<RenderCommand *>());
	auto ctor = RegisterT<CaptureScreenCallbackCommand, QtScriptCaptureScreenCallbackCommand>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

void QtScriptCaptureScreenCallbackCommand::init(float globalZOrder)
{
	auto __o = this->thiz<CaptureScreenCallbackCommand *>();
	if (__o)
	{
		__o->init(globalZOrder);
	}
}

void QtScriptCaptureScreenCallbackCommand::setCallback(const QScriptValue& arg0)
{
	auto __o = this->thiz<CaptureScreenCallbackCommand *>();
	if (__o)
	{
		__o->setCallback(QtCocosScriptUtils::getPixelsCallback(arg0));
	}
}

int QtScriptCaptureScreenCallbackCommand::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptCaptureScreenCallbackCommand::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptCaptureScreenCallbackCommand::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new CaptureScreenCallbackCommand();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::CaptureScreenCallbackCommand constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptClippingNode::QtScriptClippingNode(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptClippingNode::QtScriptClippingNode(QScriptEngine *engine)
	: QtScriptClippingNode(engine, "ClippingNode")
{
}

void QtScriptClippingNode::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<ClippingNode, QtScriptClippingNode>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptClippingNode::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptClippingNode::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptClippingNode::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptClippingNode::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ClippingNode");
	return false;
}

float QtScriptClippingNode::getAlphaThreshold()
{
	auto __o = this->thiz<ClippingNode *>();
	if (__o)
	{
		return __o->getAlphaThreshold();
	}
	return static_cast<float>(0);
}

cocos2d::Node* QtScriptClippingNode::getStencil()
{
	auto __o = this->thiz<ClippingNode *>();
	if (__o)
	{
		return __o->getStencil();
	}
	return nullptr;
}

bool QtScriptClippingNode::hasContent()
{
	auto __o = this->thiz<ClippingNode *>();
	if (__o)
	{
		return __o->hasContent();
	}
	return false;
}

bool QtScriptClippingNode::init(cocos2d::Node* stencil)
{
	auto __o = this->thiz<ClippingNode *>();
	if (__o)
	{
		return __o->init(stencil);
	}
	return false;
}

bool QtScriptClippingNode::isInverted()
{
	auto __o = this->thiz<ClippingNode *>();
	if (__o)
	{
		return __o->isInverted();
	}
	return false;
}

void QtScriptClippingNode::setAlphaThreshold(float alphaThreshold)
{
	auto __o = this->thiz<ClippingNode *>();
	if (__o)
	{
		__o->setAlphaThreshold(alphaThreshold);
	}
}

void QtScriptClippingNode::setInverted(bool inverted)
{
	auto __o = this->thiz<ClippingNode *>();
	if (__o)
	{
		__o->setInverted(inverted);
	}
}

void QtScriptClippingNode::setStencil(cocos2d::Node* stencil)
{
	auto __o = this->thiz<ClippingNode *>();
	if (__o)
	{
		__o->setStencil(stencil);
	}
}

QScriptValue QtScriptClippingNode::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ClippingNode::create());
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Node*>(context->argument(0));
			return __e->toScriptValue(ClippingNode::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ClippingNode::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptClippingRectangleNode::QtScriptClippingRectangleNode(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptClippingRectangleNode::QtScriptClippingRectangleNode(QScriptEngine *engine)
	: QtScriptClippingRectangleNode(engine, "ClippingRectangleNode")
{
}

void QtScriptClippingRectangleNode::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<ClippingRectangleNode, QtScriptClippingRectangleNode>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptClippingRectangleNode::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptClippingRectangleNode::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptClippingRectangleNode::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptClippingRectangleNode::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ClippingRectangleNode");
	return false;
}

cocos2d::Rect QtScriptClippingRectangleNode::getClippingRegion()
{
	auto __o = this->thiz<ClippingRectangleNode *>();
	if (__o)
	{
		return __o->getClippingRegion();
	}
	return cocos2d::Rect();
}

bool QtScriptClippingRectangleNode::isClippingEnabled()
{
	auto __o = this->thiz<ClippingRectangleNode *>();
	if (__o)
	{
		return __o->isClippingEnabled();
	}
	return false;
}

void QtScriptClippingRectangleNode::setClippingEnabled(bool enabled)
{
	auto __o = this->thiz<ClippingRectangleNode *>();
	if (__o)
	{
		__o->setClippingEnabled(enabled);
	}
}

void QtScriptClippingRectangleNode::setClippingRegion(const cocos2d::Rect& clippingRegion)
{
	auto __o = this->thiz<ClippingRectangleNode *>();
	if (__o)
	{
		__o->setClippingRegion(clippingRegion);
	}
}

QScriptValue QtScriptClippingRectangleNode::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ClippingRectangleNode::create());
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Rect>(context->argument(0));
			return __e->toScriptValue(ClippingRectangleNode::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ClippingRectangleNode::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptDrawNode::QtScriptDrawNode(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptDrawNode::QtScriptDrawNode(QScriptEngine *engine)
	: QtScriptDrawNode(engine, "DrawNode")
{
}

void QtScriptDrawNode::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<DrawNode, QtScriptDrawNode>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptDrawNode::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptDrawNode::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptDrawNode::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptDrawNode::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::DrawNode");
	return false;
}

void QtScriptDrawNode::clear()
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->clear();
	}
}

void QtScriptDrawNode::clear(int bufferType)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->clear(cocos2d::DrawNode::BufferType(bufferType));
	}
}

void QtScriptDrawNode::drawCardinalSpline(const cocos2d::PointArray* config, float tension, unsigned int segments, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawCardinalSpline(config, tension, segments, color);
	}
}

void QtScriptDrawNode::drawCatmullRom(const cocos2d::PointArray* points, unsigned int segments, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawCatmullRom(points, segments, color);
	}
}

void QtScriptDrawNode::drawCircle(const cocos2d::Vec2& center, float radius, float angle, unsigned int segments, bool drawLineToCenter, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawCircle(center, radius, angle, segments, drawLineToCenter, color);
	}
}

void QtScriptDrawNode::drawCircle(const cocos2d::Vec2& center, float radius, float angle, unsigned int segments, bool drawLineToCenter, float scaleX, float scaleY, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawCircle(center, radius, angle, segments, drawLineToCenter, scaleX, scaleY, color);
	}
}

void QtScriptDrawNode::drawCubicBezier(const cocos2d::Vec2& origin, const cocos2d::Vec2& control1, const cocos2d::Vec2& control2, const cocos2d::Vec2& destination, unsigned int segments, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawCubicBezier(origin, control1, control2, destination, segments, color);
	}
}

void QtScriptDrawNode::drawDot(const cocos2d::Vec2& pos, float radius, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawDot(pos, radius, color);
	}
}

void QtScriptDrawNode::drawLine(const cocos2d::Vec2& origin, const cocos2d::Vec2& destination, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawLine(origin, destination, color);
	}
}

void QtScriptDrawNode::drawPoint(const cocos2d::Vec2& position, const float pointSize, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawPoint(position, pointSize, color);
	}
}

void QtScriptDrawNode::drawPoints(const cocos2d::PointArray* arg0, const cocos2d::Color4B& arg1)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawPoints(arg0 ? arg0->getControlPoints().data() : nullptr, arg0 ? int(arg0->count()) : 0, arg1);
	}
}

void QtScriptDrawNode::drawPoints(const cocos2d::PointArray* arg0, const float arg1, const cocos2d::Color4B& arg2)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawPoints(arg0 ? arg0->getControlPoints().data() : nullptr, arg0 ? int(arg0->count()) : 0, arg1, arg2);
	}
}

void QtScriptDrawNode::drawPoly(const cocos2d::PointArray* arg0, bool arg1, const cocos2d::Color4B& arg2)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawPoly(arg0 ? arg0->getControlPoints().data() : nullptr, arg0 ? int(arg0->count()) : 0, arg1, arg2);
	}
}

void QtScriptDrawNode::drawPolygon(const cocos2d::PointArray* arg0, const cocos2d::Color4B& arg1, float arg2, const cocos2d::Color4B& arg3)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawPolygon(arg0 ? arg0->getControlPoints().data() : nullptr, arg0 ? int(arg0->count()) : 0, arg1, arg2, arg3);
	}
}

void QtScriptDrawNode::drawPolygon(const cocos2d::PointArray* arg0, float arg1, float arg2, const cocos2d::Color4B& arg3, const cocos2d::Color4B& arg4)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawPolygon(arg0 ? arg0->getControlPoints().data() : nullptr, arg0 ? int(arg0->count()) : 0, arg1, arg2, arg3, arg4);
	}
}

void QtScriptDrawNode::drawQuadBezier(const cocos2d::Vec2& origin, const cocos2d::Vec2& control, const cocos2d::Vec2& destination, unsigned int segments, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawQuadBezier(origin, control, destination, segments, color);
	}
}

void QtScriptDrawNode::drawRect(const cocos2d::Vec2& origin, const cocos2d::Vec2& destination, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawRect(origin, destination, color);
	}
}

void QtScriptDrawNode::drawRect(const cocos2d::Vec2& p1, const cocos2d::Vec2& p2, const cocos2d::Vec2& p3, const cocos2d::Vec2& p4, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawRect(p1, p2, p3, p4, color);
	}
}

void QtScriptDrawNode::drawSegment(const cocos2d::Vec2& from, const cocos2d::Vec2& to, float radius, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawSegment(from, to, radius, color);
	}
}

void QtScriptDrawNode::drawSegment(const cocos2d::Vec2& from, const cocos2d::Vec2& to, float width, float height, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawSegment(from, to, width, height, color);
	}
}

void QtScriptDrawNode::drawSolidCircle(const cocos2d::Vec2& center, float radius, float angle, unsigned int segments, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawSolidCircle(center, radius, angle, segments, color);
	}
}

void QtScriptDrawNode::drawSolidCircle(const cocos2d::Vec2& center, float radius, float angle, unsigned int segments, float scaleX, float scaleY, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawSolidCircle(center, radius, angle, segments, scaleX, scaleY, color);
	}
}

void QtScriptDrawNode::drawSolidPoly(const cocos2d::PointArray* arg0, const cocos2d::Color4B& arg1)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawSolidPoly(arg0 ? arg0->getControlPoints().data() : nullptr, arg0 ? int(arg0->count()) : 0, arg1);
	}
}

void QtScriptDrawNode::drawSolidRect(const cocos2d::Vec2& origin, const cocos2d::Vec2& destination, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawSolidRect(origin, destination, color);
	}
}

void QtScriptDrawNode::drawTriangle(const cocos2d::Vec2& p1, const cocos2d::Vec2& p2, const cocos2d::Vec2& p3, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->drawTriangle(p1, p2, p3, color);
	}
}

cocos2d::BlendFunc QtScriptDrawNode::getBlendFunc()
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		return __o->getBlendFunc();
	}
	return cocos2d::BlendFunc();
}

int QtScriptDrawNode::getCapacity(int bufferType)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		return __o->getCapacity(cocos2d::DrawNode::BufferType(bufferType));
	}
	return 0;
}

float QtScriptDrawNode::getLineWidth()
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		return __o->getLineWidth();
	}
	return static_cast<float>(0);
}

int QtScriptDrawNode::getSize(int bufferType)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		return __o->getSize(cocos2d::DrawNode::BufferType(bufferType));
	}
	return 0;
}

bool QtScriptDrawNode::isEmpty(int bufferType)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		return __o->isEmpty(cocos2d::DrawNode::BufferType(bufferType));
	}
	return false;
}

bool QtScriptDrawNode::isIsolated()
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		return __o->isIsolated();
	}
	return false;
}

void QtScriptDrawNode::reserve(int capacity, int bufferType)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->reserve(capacity, cocos2d::DrawNode::BufferType(bufferType));
	}
}

void QtScriptDrawNode::setBlendFunc(const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->setBlendFunc(blendFunc);
	}
}

void QtScriptDrawNode::setIsolated(bool isolated)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->setIsolated(isolated);
	}
}

void QtScriptDrawNode::setLineWidth(float lineWidth)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->setLineWidth(lineWidth);
	}
}

void QtScriptDrawNode::shrink(int bufferType)
{
	auto __o = this->thiz<DrawNode *>();
	if (__o)
	{
		__o->shrink(cocos2d::DrawNode::BufferType(bufferType));
	}
}

QScriptValue QtScriptDrawNode::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(DrawNode::create());
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			return __e->toScriptValue(DrawNode::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::DrawNode::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptFont::QtScriptFont(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptFont::QtScriptFont(QScriptEngine *engine)
	: QtScriptFont(engine, "Font")
{
}

void QtScriptFont::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Font, QtScriptFont>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptFont::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFont::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFont::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Font");
	return false;
}

cocos2d::FontAtlas* QtScriptFont::createFontAtlas()
{
	auto __o = this->thiz<Font *>();
	if (__o)
	{
		return __o->createFontAtlas();
	}
	return nullptr;
}

int QtScriptFont::getFontMaxHeight()
{
	auto __o = this->thiz<Font *>();
	if (__o)
	{
		return __o->getFontMaxHeight();
	}
	return 0;
}

} // end of cocos2d

namespace cocos2d {
QtScriptBMFontConfiguration::QtScriptBMFontConfiguration(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptBMFontConfiguration::QtScriptBMFontConfiguration(QScriptEngine *engine)
	: QtScriptBMFontConfiguration(engine, "BMFontConfiguration")
{
}

void QtScriptBMFontConfiguration::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<BMFontConfiguration, QtScriptBMFontConfiguration>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptBMFontConfiguration::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

QByteArray QtScriptBMFontConfiguration::description()
{
	auto __o = this->thiz<BMFontConfiguration *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->description());
	}
	return QByteArray();
}

QByteArray QtScriptBMFontConfiguration::getAtlasName()
{
	auto __o = this->thiz<BMFontConfiguration *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getAtlasName());
	}
	return QByteArray();
}

bool QtScriptBMFontConfiguration::initWithFNTfile(const QByteArray& FNTfile)
{
	auto __o = this->thiz<BMFontConfiguration *>();
	if (__o)
	{
		return __o->initWithFNTfile(FNTfile.toStdString());
	}
	return false;
}

void QtScriptBMFontConfiguration::setAtlasName(const QByteArray& atlasName)
{
	auto __o = this->thiz<BMFontConfiguration *>();
	if (__o)
	{
		__o->setAtlasName(atlasName.toStdString());
	}
}

QScriptValue QtScriptBMFontConfiguration::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(BMFontConfiguration::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::BMFontConfiguration::create");
	return __e->uncaughtException();
}

int QtScriptBMFontConfiguration::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptBMFontConfiguration::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptBMFontConfiguration::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new BMFontConfiguration();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::BMFontConfiguration constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptFontFNT::QtScriptFontFNT(QScriptEngine *engine, const QByteArray &className)
	: QtScriptFont(engine, className)
{
}

QtScriptFontFNT::QtScriptFontFNT(QScriptEngine *engine)
	: QtScriptFontFNT(engine, "FontFNT")
{
}

void QtScriptFontFNT::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Font *>());
	auto ctor = RegisterT<FontFNT, QtScriptFontFNT>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFontFNT::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("purgeCachedData", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFontFNT::purgeCachedData)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("reloadBMFontResource", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptFontFNT::reloadBMFontResource)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptFontFNT::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFontFNT::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFontFNT::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::FontFNT");
	return false;
}

float QtScriptFontFNT::getFontSize()
{
	auto __o = this->thiz<FontFNT *>();
	if (__o)
	{
		return __o->getFontSize();
	}
	return static_cast<float>(0);
}

int QtScriptFontFNT::getOriginalFontSize()
{
	auto __o = this->thiz<FontFNT *>();
	if (__o)
	{
		return __o->getOriginalFontSize();
	}
	return 0;
}

void QtScriptFontFNT::setFontSize(float fontSize)
{
	auto __o = this->thiz<FontFNT *>();
	if (__o)
	{
		__o->setFontSize(fontSize);
	}
}

QScriptValue QtScriptFontFNT::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(FontFNT::create(arg0));
		}
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			return __e->toScriptValue(FontFNT::create(arg0, arg1));
		}
		case 3:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<cocos2d::Rect>(context->argument(1));
			auto arg2 = qscriptvalue_cast<bool>(context->argument(2));
			return __e->toScriptValue(FontFNT::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FontFNT::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptFontFNT::purgeCachedData(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			FontFNT::purgeCachedData();
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FontFNT::purgeCachedData");
	return __e->uncaughtException();
}

QScriptValue QtScriptFontFNT::reloadBMFontResource(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			FontFNT::reloadBMFontResource(arg0);
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::FontFNT::reloadBMFontResource");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptFontLetterDefinition::QtScriptFontLetterDefinition(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<FontLetterDefinition, false>(engine, className)
{
}

QtScriptFontLetterDefinition::QtScriptFontLetterDefinition(QScriptEngine *engine)
	: QtScriptFontLetterDefinition(engine, "FontLetterDefinition")
{
}

void QtScriptFontLetterDefinition::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<FontLetterDefinition, QtScriptFontLetterDefinition>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptFontLetterDefinition::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFontLetterDefinition::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFontLetterDefinition::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::FontLetterDefinition constructor");
	return false;
}

float QtScriptFontLetterDefinition::_public_field_get_U() const
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		return object->U;
	}
	return static_cast<float>(0);
}

void QtScriptFontLetterDefinition::_public_field_set_U(float value)
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		object->U = value;
	}
}

float QtScriptFontLetterDefinition::_public_field_get_V() const
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		return object->V;
	}
	return static_cast<float>(0);
}

void QtScriptFontLetterDefinition::_public_field_set_V(float value)
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		object->V = value;
	}
}

float QtScriptFontLetterDefinition::_public_field_get_height() const
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		return object->height;
	}
	return static_cast<float>(0);
}

void QtScriptFontLetterDefinition::_public_field_set_height(float value)
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		object->height = value;
	}
}

float QtScriptFontLetterDefinition::_public_field_get_offsetX() const
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		return object->offsetX;
	}
	return static_cast<float>(0);
}

void QtScriptFontLetterDefinition::_public_field_set_offsetX(float value)
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		object->offsetX = value;
	}
}

float QtScriptFontLetterDefinition::_public_field_get_offsetY() const
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		return object->offsetY;
	}
	return static_cast<float>(0);
}

void QtScriptFontLetterDefinition::_public_field_set_offsetY(float value)
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		object->offsetY = value;
	}
}

bool QtScriptFontLetterDefinition::_public_field_get_rotated() const
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		return object->rotated;
	}
	return false;
}

void QtScriptFontLetterDefinition::_public_field_set_rotated(const bool& value)
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		object->rotated = value;
	}
}

int QtScriptFontLetterDefinition::_public_field_get_textureID() const
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		return object->textureID;
	}
	return static_cast<int>(0);
}

void QtScriptFontLetterDefinition::_public_field_set_textureID(int value)
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		object->textureID = value;
	}
}

bool QtScriptFontLetterDefinition::_public_field_get_validDefinition() const
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		return object->validDefinition;
	}
	return false;
}

void QtScriptFontLetterDefinition::_public_field_set_validDefinition(const bool& value)
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		object->validDefinition = value;
	}
}

float QtScriptFontLetterDefinition::_public_field_get_width() const
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		return object->width;
	}
	return static_cast<float>(0);
}

void QtScriptFontLetterDefinition::_public_field_set_width(float value)
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		object->width = value;
	}
}

int QtScriptFontLetterDefinition::_public_field_get_xAdvance() const
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		return object->xAdvance;
	}
	return static_cast<int>(0);
}

void QtScriptFontLetterDefinition::_public_field_set_xAdvance(int value)
{
	auto object = thiz<FontLetterDefinition *>();
	if (object)
	{
		object->xAdvance = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptFontAtlas::QtScriptFontAtlas(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptFontAtlas::QtScriptFontAtlas(QScriptEngine *engine)
	: QtScriptFontAtlas(engine, "FontAtlas")
{
}

void QtScriptFontAtlas::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<FontAtlas, QtScriptFontAtlas>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

void QtScriptFontAtlas::addLetterDefinition(QString utf32Char, const cocos2d::FontLetterDefinition& letterDefinition)
{
	auto __o = this->thiz<FontAtlas *>();
	if (__o)
	{
		__o->addLetterDefinition(utf32Char.toStdU32String().c_str()[0], letterDefinition);
	}
}

void QtScriptFontAtlas::addTexture(cocos2d::Texture2D* texture, int slot)
{
	auto __o = this->thiz<FontAtlas *>();
	if (__o)
	{
		__o->addTexture(texture, slot);
	}
}

const cocos2d::Font* QtScriptFontAtlas::getFont()
{
	auto __o = this->thiz<FontAtlas *>();
	if (__o)
	{
		return __o->getFont();
	}
	return nullptr;
}

QByteArray QtScriptFontAtlas::getFontName()
{
	auto __o = this->thiz<FontAtlas *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getFontName());
	}
	return QByteArray();
}

bool QtScriptFontAtlas::getLetterDefinitionForChar(QString utf32Char, cocos2d::FontLetterDefinition* letterDefinition)
{
	auto __o = this->thiz<FontAtlas *>();
	if (__o)
	{
		return __o->getLetterDefinitionForChar(utf32Char.toStdU32String().c_str()[0], *letterDefinition);
	}
	return false;
}

float QtScriptFontAtlas::getLineHeight()
{
	auto __o = this->thiz<FontAtlas *>();
	if (__o)
	{
		return __o->getLineHeight();
	}
	return static_cast<float>(0);
}

cocos2d::Texture2D* QtScriptFontAtlas::getTexture(int slot)
{
	auto __o = this->thiz<FontAtlas *>();
	if (__o)
	{
		return __o->getTexture(slot);
	}
	return nullptr;
}

bool QtScriptFontAtlas::prepareLetterDefinitions(const QString& utf16String)
{
	auto __o = this->thiz<FontAtlas *>();
	if (__o)
	{
		return __o->prepareLetterDefinitions(utf16String.toStdU32String());
	}
	return false;
}

void QtScriptFontAtlas::purgeTexturesAtlas()
{
	auto __o = this->thiz<FontAtlas *>();
	if (__o)
	{
		__o->purgeTexturesAtlas();
	}
}

void QtScriptFontAtlas::setAliasTexParameters()
{
	auto __o = this->thiz<FontAtlas *>();
	if (__o)
	{
		__o->setAliasTexParameters();
	}
}

void QtScriptFontAtlas::setAntiAliasTexParameters()
{
	auto __o = this->thiz<FontAtlas *>();
	if (__o)
	{
		__o->setAntiAliasTexParameters();
	}
}

void QtScriptFontAtlas::setLineHeight(float newHeight)
{
	auto __o = this->thiz<FontAtlas *>();
	if (__o)
	{
		__o->setLineHeight(newHeight);
	}
}

int QtScriptFontAtlas::constructorArgumentCountMin() const
{
	return 1;
}

int QtScriptFontAtlas::constructorArgumentCountMax() const
{
	return 1;
}

bool QtScriptFontAtlas::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Font*>(context->argument(0));
			out = new FontAtlas(arg0);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::FontAtlas constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptTTFConfig::QtScriptTTFConfig(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<_ttfConfig, false>(engine, className)
{
}

QtScriptTTFConfig::QtScriptTTFConfig(QScriptEngine *engine)
	: QtScriptTTFConfig(engine, "TTFConfig")
{
}

void QtScriptTTFConfig::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<_ttfConfig, QtScriptTTFConfig>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptTTFConfig::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTTFConfig::constructorArgumentCountMax() const
{
	return 10;
}

bool QtScriptTTFConfig::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			out = _ttfConfig(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			out = _ttfConfig(arg0, arg1);
			ok = true;
			break;
		}
		case 3:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::GlyphCollection(tmp_2);
			out = _ttfConfig(arg0, arg1, arg2);
			ok = true;
			break;
		}
		case 4:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::GlyphCollection(tmp_2);
			auto tmp_3 = qscriptvalue_cast<QByteArray>(context->argument(3));
			auto arg3 = tmp_3.toStdString();
			out = _ttfConfig(arg0, arg1, arg2, arg3);
			ok = true;
			break;
		}
		case 5:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::GlyphCollection(tmp_2);
			auto tmp_3 = qscriptvalue_cast<QByteArray>(context->argument(3));
			auto arg3 = tmp_3.toStdString();
			auto arg4 = qscriptvalue_cast<bool>(context->argument(4));
			out = _ttfConfig(arg0, arg1, arg2, arg3, arg4);
			ok = true;
			break;
		}
		case 6:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::GlyphCollection(tmp_2);
			auto tmp_3 = qscriptvalue_cast<QByteArray>(context->argument(3));
			auto arg3 = tmp_3.toStdString();
			auto arg4 = qscriptvalue_cast<bool>(context->argument(4));
			auto arg5 = qscriptvalue_cast<int>(context->argument(5));
			out = _ttfConfig(arg0, arg1, arg2, arg3, arg4, arg5);
			ok = true;
			break;
		}
		case 7:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::GlyphCollection(tmp_2);
			auto tmp_3 = qscriptvalue_cast<QByteArray>(context->argument(3));
			auto arg3 = tmp_3.toStdString();
			auto arg4 = qscriptvalue_cast<bool>(context->argument(4));
			auto arg5 = qscriptvalue_cast<int>(context->argument(5));
			auto arg6 = qscriptvalue_cast<bool>(context->argument(6));
			out = _ttfConfig(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
			ok = true;
			break;
		}
		case 8:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::GlyphCollection(tmp_2);
			auto tmp_3 = qscriptvalue_cast<QByteArray>(context->argument(3));
			auto arg3 = tmp_3.toStdString();
			auto arg4 = qscriptvalue_cast<bool>(context->argument(4));
			auto arg5 = qscriptvalue_cast<int>(context->argument(5));
			auto arg6 = qscriptvalue_cast<bool>(context->argument(6));
			auto arg7 = qscriptvalue_cast<bool>(context->argument(7));
			out = _ttfConfig(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
			ok = true;
			break;
		}
		case 9:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::GlyphCollection(tmp_2);
			auto tmp_3 = qscriptvalue_cast<QByteArray>(context->argument(3));
			auto arg3 = tmp_3.toStdString();
			auto arg4 = qscriptvalue_cast<bool>(context->argument(4));
			auto arg5 = qscriptvalue_cast<int>(context->argument(5));
			auto arg6 = qscriptvalue_cast<bool>(context->argument(6));
			auto arg7 = qscriptvalue_cast<bool>(context->argument(7));
			auto arg8 = qscriptvalue_cast<bool>(context->argument(8));
			out = _ttfConfig(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
			ok = true;
			break;
		}
		case 10:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::GlyphCollection(tmp_2);
			auto tmp_3 = qscriptvalue_cast<QByteArray>(context->argument(3));
			auto arg3 = tmp_3.toStdString();
			auto arg4 = qscriptvalue_cast<bool>(context->argument(4));
			auto arg5 = qscriptvalue_cast<int>(context->argument(5));
			auto arg6 = qscriptvalue_cast<bool>(context->argument(6));
			auto arg7 = qscriptvalue_cast<bool>(context->argument(7));
			auto arg8 = qscriptvalue_cast<bool>(context->argument(8));
			auto arg9 = qscriptvalue_cast<bool>(context->argument(9));
			out = _ttfConfig(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::_ttfConfig constructor");
	}
	return ok;
}

bool QtScriptTTFConfig::_public_field_get_bold() const
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		return object->bold;
	}
	return false;
}

void QtScriptTTFConfig::_public_field_set_bold(const bool& value)
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		object->bold = value;
	}
}

QByteArray QtScriptTTFConfig::_public_field_get_customGlyphs() const
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		return QByteArray::fromStdString(object->customGlyphs);
	}
	return QByteArray();
}

void QtScriptTTFConfig::_public_field_set_customGlyphs(const QByteArray& value)
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		object->customGlyphs = value.toStdString();
	}
}

bool QtScriptTTFConfig::_public_field_get_distanceFieldEnabled() const
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		return object->distanceFieldEnabled;
	}
	return false;
}

void QtScriptTTFConfig::_public_field_set_distanceFieldEnabled(const bool& value)
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		object->distanceFieldEnabled = value;
	}
}

QByteArray QtScriptTTFConfig::_public_field_get_fontFilePath() const
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		return QByteArray::fromStdString(object->fontFilePath);
	}
	return QByteArray();
}

void QtScriptTTFConfig::_public_field_set_fontFilePath(const QByteArray& value)
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		object->fontFilePath = value.toStdString();
	}
}

float QtScriptTTFConfig::_public_field_get_fontSize() const
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		return object->fontSize;
	}
	return static_cast<float>(0);
}

void QtScriptTTFConfig::_public_field_set_fontSize(float value)
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		object->fontSize = value;
	}
}

int QtScriptTTFConfig::_public_field_get_glyphs() const
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		return int(object->glyphs);
	}
	return static_cast<int>(0);
}

void QtScriptTTFConfig::_public_field_set_glyphs(int value)
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		object->glyphs = cocos2d::GlyphCollection(value);
	}
}

bool QtScriptTTFConfig::_public_field_get_italics() const
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		return object->italics;
	}
	return false;
}

void QtScriptTTFConfig::_public_field_set_italics(const bool& value)
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		object->italics = value;
	}
}

int QtScriptTTFConfig::_public_field_get_outlineSize() const
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		return object->outlineSize;
	}
	return static_cast<int>(0);
}

void QtScriptTTFConfig::_public_field_set_outlineSize(int value)
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		object->outlineSize = value;
	}
}

bool QtScriptTTFConfig::_public_field_get_strikethrough() const
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		return object->strikethrough;
	}
	return false;
}

void QtScriptTTFConfig::_public_field_set_strikethrough(const bool& value)
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		object->strikethrough = value;
	}
}

bool QtScriptTTFConfig::_public_field_get_underline() const
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		return object->underline;
	}
	return false;
}

void QtScriptTTFConfig::_public_field_set_underline(const bool& value)
{
	auto object = thiz<_ttfConfig *>();
	if (object)
	{
		object->underline = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptLabel::QtScriptLabel(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptLabel::QtScriptLabel(QScriptEngine *engine)
	: QtScriptLabel(engine, "Label")
{
}

void QtScriptLabel::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<Label, QtScriptLabel>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptLabel::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithBMFont", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptLabel::createWithBMFont)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithCharMap", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptLabel::createWithCharMap)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithSystemFont", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptLabel::createWithSystemFont)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTTF", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptLabel::createWithTTF)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptLabel::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptLabel::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptLabel::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Label");
	return false;
}

void QtScriptLabel::disableEffect()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->disableEffect();
	}
}

void QtScriptLabel::disableEffect(int effect)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->disableEffect(cocos2d::LabelEffect(effect));
	}
}

void QtScriptLabel::enableBold()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->enableBold();
	}
}

void QtScriptLabel::enableGlow(const cocos2d::Color4B& glowColor)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->enableGlow(glowColor);
	}
}

void QtScriptLabel::enableItalics()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->enableItalics();
	}
}

void QtScriptLabel::enableOutline(const cocos2d::Color4B& outlineColor)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->enableOutline(outlineColor);
	}
}

void QtScriptLabel::enableOutline(const cocos2d::Color4B& outlineColor, int outlineSize)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->enableOutline(outlineColor, outlineSize);
	}
}

void QtScriptLabel::enableShadow()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->enableShadow();
	}
}

void QtScriptLabel::enableShadow(const cocos2d::Color4B& shadowColor)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->enableShadow(shadowColor);
	}
}

void QtScriptLabel::enableShadow(const cocos2d::Color4B& shadowColor, const cocos2d::Size& offset)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->enableShadow(shadowColor, offset);
	}
}

void QtScriptLabel::enableShadow(const cocos2d::Color4B& shadowColor, const cocos2d::Size& offset, int blurRadius)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->enableShadow(shadowColor, offset, blurRadius);
	}
}

void QtScriptLabel::enableStrikethrough()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->enableStrikethrough();
	}
}

void QtScriptLabel::enableUnderline()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->enableUnderline();
	}
}

void QtScriptLabel::enableWrap(bool enable)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->enableWrap(enable);
	}
}

float QtScriptLabel::getAdditionalKerning()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getAdditionalKerning();
	}
	return static_cast<float>(0);
}

QByteArray QtScriptLabel::getBMFontFilePath()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getBMFontFilePath());
	}
	return QByteArray();
}

float QtScriptLabel::getBMFontSize()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getBMFontSize();
	}
	return static_cast<float>(0);
}

cocos2d::BlendFunc QtScriptLabel::getBlendFunc()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getBlendFunc();
	}
	return cocos2d::BlendFunc();
}

cocos2d::Size QtScriptLabel::getDimensions()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getDimensions();
	}
	return cocos2d::Size();
}

cocos2d::Color4F QtScriptLabel::getEffectColor()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getEffectColor();
	}
	return cocos2d::Color4F();
}

cocos2d::FontAtlas* QtScriptLabel::getFontAtlas()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getFontAtlas();
	}
	return nullptr;
}

float QtScriptLabel::getHeight()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getHeight();
	}
	return static_cast<float>(0);
}

int QtScriptLabel::getHorizontalAlignment()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return int(__o->getHorizontalAlignment());
	}
	return 0;
}

int QtScriptLabel::getLabelEffectType()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return int(__o->getLabelEffectType());
	}
	return 0;
}

int QtScriptLabel::getLabelType()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return int(__o->getLabelType());
	}
	return 0;
}

cocos2d::Sprite* QtScriptLabel::getLetter(int lettetIndex)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getLetter(lettetIndex);
	}
	return nullptr;
}

float QtScriptLabel::getLineHeight()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getLineHeight();
	}
	return static_cast<float>(0);
}

float QtScriptLabel::getLineSpacing()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getLineSpacing();
	}
	return static_cast<float>(0);
}

float QtScriptLabel::getMaxLineWidth()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getMaxLineWidth();
	}
	return static_cast<float>(0);
}

float QtScriptLabel::getOutlineSize()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getOutlineSize();
	}
	return static_cast<float>(0);
}

int QtScriptLabel::getOverflow()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return int(__o->getOverflow());
	}
	return 0;
}

float QtScriptLabel::getRenderingFontSize()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getRenderingFontSize();
	}
	return static_cast<float>(0);
}

float QtScriptLabel::getShadowBlurRadius()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getShadowBlurRadius();
	}
	return static_cast<float>(0);
}

cocos2d::Color4F QtScriptLabel::getShadowColor()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getShadowColor();
	}
	return cocos2d::Color4F();
}

cocos2d::Size QtScriptLabel::getShadowOffset()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getShadowOffset();
	}
	return cocos2d::Size();
}

QByteArray QtScriptLabel::getString()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getString());
	}
	return QByteArray();
}

int QtScriptLabel::getStringLength()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getStringLength();
	}
	return 0;
}

int QtScriptLabel::getStringNumLines()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getStringNumLines();
	}
	return 0;
}

QByteArray QtScriptLabel::getSystemFontName()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getSystemFontName());
	}
	return QByteArray();
}

float QtScriptLabel::getSystemFontSize()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getSystemFontSize();
	}
	return static_cast<float>(0);
}

cocos2d::_ttfConfig QtScriptLabel::getTTFConfig()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getTTFConfig();
	}
	return cocos2d::_ttfConfig();
}

int QtScriptLabel::getTextAlignment()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return int(__o->getTextAlignment());
	}
	return 0;
}

cocos2d::Color4B QtScriptLabel::getTextColor()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getTextColor();
	}
	return cocos2d::Color4B();
}

int QtScriptLabel::getVerticalAlignment()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return int(__o->getVerticalAlignment());
	}
	return 0;
}

float QtScriptLabel::getWidth()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->getWidth();
	}
	return static_cast<float>(0);
}

bool QtScriptLabel::initWithTTF(const cocos2d::_ttfConfig& ttfConfig, const QByteArray& text)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->initWithTTF(ttfConfig, text.toStdString());
	}
	return false;
}

bool QtScriptLabel::initWithTTF(const QByteArray& text, const QByteArray& fontFilePath, float fontSize)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->initWithTTF(text.toStdString(), fontFilePath.toStdString(), fontSize);
	}
	return false;
}

bool QtScriptLabel::initWithTTF(const QByteArray& text, const QByteArray& fontFilePath, float fontSize, const cocos2d::Size& dimensions)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->initWithTTF(text.toStdString(), fontFilePath.toStdString(), fontSize, dimensions);
	}
	return false;
}

bool QtScriptLabel::initWithTTF(const QByteArray& text, const QByteArray& fontFilePath, float fontSize, const cocos2d::Size& dimensions, int hAlignment)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->initWithTTF(text.toStdString(), fontFilePath.toStdString(), fontSize, dimensions, cocos2d::TextHAlignment(hAlignment));
	}
	return false;
}

bool QtScriptLabel::initWithTTF(const QByteArray& text, const QByteArray& fontFilePath, float fontSize, const cocos2d::Size& dimensions, int hAlignment, int vAlignment)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->initWithTTF(text.toStdString(), fontFilePath.toStdString(), fontSize, dimensions, cocos2d::TextHAlignment(hAlignment), cocos2d::TextVAlignment(vAlignment));
	}
	return false;
}

bool QtScriptLabel::isClipMarginEnabled()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->isClipMarginEnabled();
	}
	return false;
}

bool QtScriptLabel::isShadowEnabled()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->isShadowEnabled();
	}
	return false;
}

bool QtScriptLabel::isWrapEnabled()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->isWrapEnabled();
	}
	return false;
}

void QtScriptLabel::requestSystemFontRefresh()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->requestSystemFontRefresh();
	}
}

void QtScriptLabel::setAdditionalKerning(float space)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setAdditionalKerning(space);
	}
}

void QtScriptLabel::setAlignment(int hAlignment)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setAlignment(cocos2d::TextHAlignment(hAlignment));
	}
}

void QtScriptLabel::setAlignment(int hAlignment, int vAlignment)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setAlignment(cocos2d::TextHAlignment(hAlignment), cocos2d::TextVAlignment(vAlignment));
	}
}

bool QtScriptLabel::setBMFontFilePath(const QByteArray& bmfontFilePath)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->setBMFontFilePath(bmfontFilePath.toStdString());
	}
	return false;
}

bool QtScriptLabel::setBMFontFilePath(const QByteArray& bmfontFilePath, float fontSize)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->setBMFontFilePath(bmfontFilePath.toStdString(), fontSize);
	}
	return false;
}

bool QtScriptLabel::setBMFontFilePath(const QByteArray& bmfontFilePath, const cocos2d::Rect& imageRect, bool imageRotated)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->setBMFontFilePath(bmfontFilePath.toStdString(), imageRect, imageRotated);
	}
	return false;
}

bool QtScriptLabel::setBMFontFilePath(const QByteArray& bmfontFilePath, const cocos2d::Rect& imageRect, bool imageRotated, float fontSize)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->setBMFontFilePath(bmfontFilePath.toStdString(), imageRect, imageRotated, fontSize);
	}
	return false;
}

void QtScriptLabel::setBMFontSize(float fontSize)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setBMFontSize(fontSize);
	}
}

void QtScriptLabel::setBlendFunc(const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setBlendFunc(blendFunc);
	}
}

bool QtScriptLabel::setCharMap(const QByteArray& plistFile)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->setCharMap(plistFile.toStdString());
	}
	return false;
}

bool QtScriptLabel::setCharMap(const QByteArray& charMapFile, int itemWidth, int itemHeight, int startCharMap)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->setCharMap(charMapFile.toStdString(), itemWidth, itemHeight, startCharMap);
	}
	return false;
}

void QtScriptLabel::setClipMarginEnabled(bool clipEnabled)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setClipMarginEnabled(clipEnabled);
	}
}

void QtScriptLabel::setDimensions(float width, float height)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setDimensions(width, height);
	}
}

void QtScriptLabel::setHeight(float height)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setHeight(height);
	}
}

void QtScriptLabel::setHorizontalAlignment(int hAlignment)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setHorizontalAlignment(cocos2d::TextHAlignment(hAlignment));
	}
}

void QtScriptLabel::setLineBreakWithoutSpace(bool breakWithoutSpace)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setLineBreakWithoutSpace(breakWithoutSpace);
	}
}

void QtScriptLabel::setLineHeight(float height)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setLineHeight(height);
	}
}

void QtScriptLabel::setLineSpacing(float height)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setLineSpacing(height);
	}
}

void QtScriptLabel::setMaxLineWidth(float maxLineWidth)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setMaxLineWidth(maxLineWidth);
	}
}

void QtScriptLabel::setOverflow(int overflow)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setOverflow(cocos2d::Label::Overflow(overflow));
	}
}

void QtScriptLabel::setString(const QByteArray& text)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setString(text.toStdString());
	}
}

void QtScriptLabel::setSystemFontName(const QByteArray& font)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setSystemFontName(font.toStdString());
	}
}

void QtScriptLabel::setSystemFontSize(float fontSize)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setSystemFontSize(fontSize);
	}
}

bool QtScriptLabel::setTTFConfig(const cocos2d::_ttfConfig& ttfConfig)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		return __o->setTTFConfig(ttfConfig);
	}
	return false;
}

void QtScriptLabel::setTextColor(const cocos2d::Color4B& color)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setTextColor(color);
	}
}

void QtScriptLabel::setVerticalAlignment(int vAlignment)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setVerticalAlignment(cocos2d::TextVAlignment(vAlignment));
	}
}

void QtScriptLabel::setWidth(float width)
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->setWidth(width);
	}
}

void QtScriptLabel::updateContent()
{
	auto __o = this->thiz<Label *>();
	if (__o)
	{
		__o->updateContent();
	}
}

QScriptValue QtScriptLabel::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Label::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Label::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptLabel::createWithBMFont(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 6))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			return __e->toScriptValue(Label::createWithBMFont(arg0, arg1));
		}
		case 3:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::TextHAlignment(tmp_2);
			return __e->toScriptValue(Label::createWithBMFont(arg0, arg1, arg2));
		}
		case 4:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::TextHAlignment(tmp_2);
			auto arg3 = qscriptvalue_cast<int>(context->argument(3));
			return __e->toScriptValue(Label::createWithBMFont(arg0, arg1, arg2, arg3));
		}
		case 5:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::TextHAlignment(tmp_2);
			auto arg3 = qscriptvalue_cast<int>(context->argument(3));
			auto tmp_4 = qscriptvalue_cast<QByteArray>(context->argument(4));
			auto arg4 = tmp_4.toStdString();
			return __e->toScriptValue(Label::createWithBMFont(arg0, arg1, arg2, arg3, arg4));
		}
		case 6:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::TextHAlignment(tmp_2);
			auto arg3 = qscriptvalue_cast<int>(context->argument(3));
			auto arg4 = qscriptvalue_cast<cocos2d::Rect>(context->argument(4));
			auto arg5 = qscriptvalue_cast<bool>(context->argument(5));
			return __e->toScriptValue(Label::createWithBMFont(arg0, arg1, arg2, arg3, arg4, arg5));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Label::createWithBMFont");
	return __e->uncaughtException();
}

QScriptValue QtScriptLabel::createWithCharMap(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(Label::createWithCharMap(arg0));
		}
		case 2:
		{
			break;
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<int>(context->argument(1));
			auto arg2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg3 = qscriptvalue_cast<int>(context->argument(3));
			return __e->toScriptValue(Label::createWithCharMap(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Label::createWithCharMap");
	return __e->uncaughtException();
}

QScriptValue QtScriptLabel::createWithSystemFont(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 3, 6))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 3:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(Label::createWithSystemFont(arg0, arg1, arg2));
		}
		case 4:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Size>(context->argument(3));
			return __e->toScriptValue(Label::createWithSystemFont(arg0, arg1, arg2, arg3));
		}
		case 5:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Size>(context->argument(3));
			auto tmp_4 = qscriptvalue_cast<int>(context->argument(4));
			auto arg4 = cocos2d::TextHAlignment(tmp_4);
			return __e->toScriptValue(Label::createWithSystemFont(arg0, arg1, arg2, arg3, arg4));
		}
		case 6:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Size>(context->argument(3));
			auto tmp_4 = qscriptvalue_cast<int>(context->argument(4));
			auto arg4 = cocos2d::TextHAlignment(tmp_4);
			auto tmp_5 = qscriptvalue_cast<int>(context->argument(5));
			auto arg5 = cocos2d::TextVAlignment(tmp_5);
			return __e->toScriptValue(Label::createWithSystemFont(arg0, arg1, arg2, arg3, arg4, arg5));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Label::createWithSystemFont");
	return __e->uncaughtException();
}

QScriptValue QtScriptLabel::createWithTTF(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 6))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::_ttfConfig>(context->argument(0));
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			return __e->toScriptValue(Label::createWithTTF(arg0, arg1));
		}
		case 3:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(Label::createWithTTF(arg0, arg1, arg2));
		}
		case 4:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Size>(context->argument(3));
			return __e->toScriptValue(Label::createWithTTF(arg0, arg1, arg2, arg3));
		}
		case 5:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Size>(context->argument(3));
			auto tmp_4 = qscriptvalue_cast<int>(context->argument(4));
			auto arg4 = cocos2d::TextHAlignment(tmp_4);
			return __e->toScriptValue(Label::createWithTTF(arg0, arg1, arg2, arg3, arg4));
		}
		case 6:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Size>(context->argument(3));
			auto tmp_4 = qscriptvalue_cast<int>(context->argument(4));
			auto arg4 = cocos2d::TextHAlignment(tmp_4);
			auto tmp_5 = qscriptvalue_cast<int>(context->argument(5));
			auto arg5 = cocos2d::TextVAlignment(tmp_5);
			return __e->toScriptValue(Label::createWithTTF(arg0, arg1, arg2, arg3, arg4, arg5));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Label::createWithTTF");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptLabelAtlas::QtScriptLabelAtlas(QScriptEngine *engine, const QByteArray &className)
	: QtScriptAtlasNode(engine, className)
{
}

QtScriptLabelAtlas::QtScriptLabelAtlas(QScriptEngine *engine)
	: QtScriptLabelAtlas(engine, "LabelAtlas")
{
}

void QtScriptLabelAtlas::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<AtlasNode *>());
	auto ctor = RegisterT<LabelAtlas, QtScriptLabelAtlas>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptLabelAtlas::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptLabelAtlas::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptLabelAtlas::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptLabelAtlas::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::LabelAtlas");
	return false;
}

QByteArray QtScriptLabelAtlas::getString()
{
	auto __o = this->thiz<LabelAtlas *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getString());
	}
	return QByteArray();
}

bool QtScriptLabelAtlas::initWithString(const QByteArray& string, const QByteArray& fntFile)
{
	auto __o = this->thiz<LabelAtlas *>();
	if (__o)
	{
		return __o->initWithString(string.toStdString(), fntFile.toStdString());
	}
	return false;
}

bool QtScriptLabelAtlas::initWithString(const QByteArray& string, const QByteArray& charMapFile, int itemWidth, int itemHeight, int startCharMap)
{
	auto __o = this->thiz<LabelAtlas *>();
	if (__o)
	{
		return __o->initWithString(string.toStdString(), charMapFile.toStdString(), itemWidth, itemHeight, startCharMap);
	}
	return false;
}

void QtScriptLabelAtlas::setString(const QByteArray& label)
{
	auto __o = this->thiz<LabelAtlas *>();
	if (__o)
	{
		__o->setString(label.toStdString());
	}
}

QScriptValue QtScriptLabelAtlas::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 5))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(LabelAtlas::create());
		}
		case 1:
		{
			break;
		}
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			return __e->toScriptValue(LabelAtlas::create(arg0, arg1));
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			break;
		}
		case 5:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto arg2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg3 = qscriptvalue_cast<int>(context->argument(3));
			auto arg4 = qscriptvalue_cast<int>(context->argument(4));
			return __e->toScriptValue(LabelAtlas::create(arg0, arg1, arg2, arg3, arg4));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::LabelAtlas::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptLayer::QtScriptLayer(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptLayer::QtScriptLayer(QScriptEngine *engine)
	: QtScriptLayer(engine, "Layer")
{
}

void QtScriptLayer::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<Layer, QtScriptLayer>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptLayer::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptLayer::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptLayer::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptLayer::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Layer");
	return false;
}

QScriptValue QtScriptLayer::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Layer::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Layer::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptLayerColor::QtScriptLayerColor(QScriptEngine *engine, const QByteArray &className)
	: QtScriptLayer(engine, className)
{
}

QtScriptLayerColor::QtScriptLayerColor(QScriptEngine *engine)
	: QtScriptLayerColor(engine, "LayerColor")
{
}

void QtScriptLayerColor::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Layer *>());
	auto ctor = RegisterT<LayerColor, QtScriptLayerColor>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptLayerColor::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptLayerColor::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptLayerColor::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptLayerColor::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::LayerColor");
	return false;
}

void QtScriptLayerColor::changeHeight(float h)
{
	auto __o = this->thiz<LayerColor *>();
	if (__o)
	{
		__o->changeHeight(h);
	}
}

void QtScriptLayerColor::changeWidth(float w)
{
	auto __o = this->thiz<LayerColor *>();
	if (__o)
	{
		__o->changeWidth(w);
	}
}

void QtScriptLayerColor::changeWidthAndHeight(float w, float h)
{
	auto __o = this->thiz<LayerColor *>();
	if (__o)
	{
		__o->changeWidthAndHeight(w, h);
	}
}

cocos2d::BlendFunc QtScriptLayerColor::getBlendFunc()
{
	auto __o = this->thiz<LayerColor *>();
	if (__o)
	{
		return __o->getBlendFunc();
	}
	return cocos2d::BlendFunc();
}

bool QtScriptLayerColor::initWithColor(const cocos2d::Color4B& color)
{
	auto __o = this->thiz<LayerColor *>();
	if (__o)
	{
		return __o->initWithColor(color);
	}
	return false;
}

bool QtScriptLayerColor::initWithColor(const cocos2d::Color4B& color, float width, float height)
{
	auto __o = this->thiz<LayerColor *>();
	if (__o)
	{
		return __o->initWithColor(color, width, height);
	}
	return false;
}

void QtScriptLayerColor::setBlendFunc(const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<LayerColor *>();
	if (__o)
	{
		__o->setBlendFunc(blendFunc);
	}
}

QScriptValue QtScriptLayerColor::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(LayerColor::create());
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Color4B>(context->argument(0));
			return __e->toScriptValue(LayerColor::create(arg0));
		}
		case 2:
		{
			break;
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Color4B>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(LayerColor::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::LayerColor::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptLayerGradient::QtScriptLayerGradient(QScriptEngine *engine, const QByteArray &className)
	: QtScriptLayerColor(engine, className)
{
}

QtScriptLayerGradient::QtScriptLayerGradient(QScriptEngine *engine)
	: QtScriptLayerGradient(engine, "LayerGradient")
{
}

void QtScriptLayerGradient::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<LayerColor *>());
	auto ctor = RegisterT<LayerGradient, QtScriptLayerGradient>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptLayerGradient::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptLayerGradient::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptLayerGradient::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptLayerGradient::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::LayerGradient");
	return false;
}

cocos2d::Color3B QtScriptLayerGradient::getEndColor()
{
	auto __o = this->thiz<LayerGradient *>();
	if (__o)
	{
		return __o->getEndColor();
	}
	return cocos2d::Color3B();
}

quint8 QtScriptLayerGradient::getEndOpacity()
{
	auto __o = this->thiz<LayerGradient *>();
	if (__o)
	{
		return __o->getEndOpacity();
	}
	return static_cast<quint8>(0);
}

cocos2d::Color3B QtScriptLayerGradient::getStartColor()
{
	auto __o = this->thiz<LayerGradient *>();
	if (__o)
	{
		return __o->getStartColor();
	}
	return cocos2d::Color3B();
}

quint8 QtScriptLayerGradient::getStartOpacity()
{
	auto __o = this->thiz<LayerGradient *>();
	if (__o)
	{
		return __o->getStartOpacity();
	}
	return static_cast<quint8>(0);
}

cocos2d::Vec2 QtScriptLayerGradient::getVector()
{
	auto __o = this->thiz<LayerGradient *>();
	if (__o)
	{
		return __o->getVector();
	}
	return cocos2d::Vec2();
}

bool QtScriptLayerGradient::initWithColor(const cocos2d::Color4B& start, const cocos2d::Color4B& end)
{
	auto __o = this->thiz<LayerGradient *>();
	if (__o)
	{
		return __o->initWithColor(start, end);
	}
	return false;
}

bool QtScriptLayerGradient::initWithColor(const cocos2d::Color4B& start, const cocos2d::Color4B& end, const cocos2d::Vec2& v)
{
	auto __o = this->thiz<LayerGradient *>();
	if (__o)
	{
		return __o->initWithColor(start, end, v);
	}
	return false;
}

bool QtScriptLayerGradient::isCompressedInterpolation()
{
	auto __o = this->thiz<LayerGradient *>();
	if (__o)
	{
		return __o->isCompressedInterpolation();
	}
	return false;
}

void QtScriptLayerGradient::setCompressedInterpolation(bool compressedInterpolation)
{
	auto __o = this->thiz<LayerGradient *>();
	if (__o)
	{
		__o->setCompressedInterpolation(compressedInterpolation);
	}
}

void QtScriptLayerGradient::setEndColor(const cocos2d::Color3B& endColor)
{
	auto __o = this->thiz<LayerGradient *>();
	if (__o)
	{
		__o->setEndColor(endColor);
	}
}

void QtScriptLayerGradient::setEndOpacity(quint8 endOpacity)
{
	auto __o = this->thiz<LayerGradient *>();
	if (__o)
	{
		__o->setEndOpacity(endOpacity);
	}
}

void QtScriptLayerGradient::setStartColor(const cocos2d::Color3B& startColor)
{
	auto __o = this->thiz<LayerGradient *>();
	if (__o)
	{
		__o->setStartColor(startColor);
	}
}

void QtScriptLayerGradient::setStartOpacity(quint8 startOpacity)
{
	auto __o = this->thiz<LayerGradient *>();
	if (__o)
	{
		__o->setStartOpacity(startOpacity);
	}
}

void QtScriptLayerGradient::setVector(const cocos2d::Vec2& alongVector)
{
	auto __o = this->thiz<LayerGradient *>();
	if (__o)
	{
		__o->setVector(alongVector);
	}
}

QScriptValue QtScriptLayerGradient::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(LayerGradient::create());
		}
		case 1:
		{
			break;
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Color4B>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Color4B>(context->argument(1));
			return __e->toScriptValue(LayerGradient::create(arg0, arg1));
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Color4B>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Color4B>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(2));
			return __e->toScriptValue(LayerGradient::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::LayerGradient::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptLayerRadialGradient::QtScriptLayerRadialGradient(QScriptEngine *engine, const QByteArray &className)
	: QtScriptLayer(engine, className)
{
}

QtScriptLayerRadialGradient::QtScriptLayerRadialGradient(QScriptEngine *engine)
	: QtScriptLayerRadialGradient(engine, "LayerRadialGradient")
{
}

void QtScriptLayerRadialGradient::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Layer *>());
	auto ctor = RegisterT<LayerRadialGradient, QtScriptLayerRadialGradient>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptLayerRadialGradient::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptLayerRadialGradient::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptLayerRadialGradient::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptLayerRadialGradient::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::LayerRadialGradient");
	return false;
}

cocos2d::BlendFunc QtScriptLayerRadialGradient::getBlendFunc()
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		return __o->getBlendFunc();
	}
	return cocos2d::BlendFunc();
}

cocos2d::Vec2 QtScriptLayerRadialGradient::getCenter()
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		return __o->getCenter();
	}
	return cocos2d::Vec2();
}

cocos2d::Color4B QtScriptLayerRadialGradient::getEndColor()
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		return __o->getEndColor();
	}
	return cocos2d::Color4B();
}

cocos2d::Color3B QtScriptLayerRadialGradient::getEndColor3B()
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		return __o->getEndColor3B();
	}
	return cocos2d::Color3B();
}

quint8 QtScriptLayerRadialGradient::getEndOpacity()
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		return __o->getEndOpacity();
	}
	return static_cast<quint8>(0);
}

float QtScriptLayerRadialGradient::getExpand()
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		return __o->getExpand();
	}
	return static_cast<float>(0);
}

float QtScriptLayerRadialGradient::getRadius()
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		return __o->getRadius();
	}
	return static_cast<float>(0);
}

cocos2d::Color4B QtScriptLayerRadialGradient::getStartColor()
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		return __o->getStartColor();
	}
	return cocos2d::Color4B();
}

cocos2d::Color3B QtScriptLayerRadialGradient::getStartColor3B()
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		return __o->getStartColor3B();
	}
	return cocos2d::Color3B();
}

quint8 QtScriptLayerRadialGradient::getStartOpacity()
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		return __o->getStartOpacity();
	}
	return static_cast<quint8>(0);
}

bool QtScriptLayerRadialGradient::initWithColor(const cocos2d::Color4B& startColor, const cocos2d::Color4B& endColor, float radius, const cocos2d::Vec2& center, float expand)
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		return __o->initWithColor(startColor, endColor, radius, center, expand);
	}
	return false;
}

void QtScriptLayerRadialGradient::setBlendFunc(const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		__o->setBlendFunc(blendFunc);
	}
}

void QtScriptLayerRadialGradient::setCenter(const cocos2d::Vec2& center)
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		__o->setCenter(center);
	}
}

void QtScriptLayerRadialGradient::setEndColor(const cocos2d::Color4B& color)
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		__o->setEndColor(color);
	}
}

void QtScriptLayerRadialGradient::setEndColor3B(const cocos2d::Color3B& color)
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		__o->setEndColor3B(color);
	}
}

void QtScriptLayerRadialGradient::setEndOpacity(quint8 opacity)
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		__o->setEndOpacity(opacity);
	}
}

void QtScriptLayerRadialGradient::setExpand(float expand)
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		__o->setExpand(expand);
	}
}

void QtScriptLayerRadialGradient::setRadius(float radius)
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		__o->setRadius(radius);
	}
}

void QtScriptLayerRadialGradient::setStartColor(const cocos2d::Color4B& color)
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		__o->setStartColor(color);
	}
}

void QtScriptLayerRadialGradient::setStartColor3B(const cocos2d::Color3B& color)
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		__o->setStartColor3B(color);
	}
}

void QtScriptLayerRadialGradient::setStartOpacity(quint8 opacity)
{
	auto __o = this->thiz<LayerRadialGradient *>();
	if (__o)
	{
		__o->setStartOpacity(opacity);
	}
}

QScriptValue QtScriptLayerRadialGradient::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 5))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(LayerRadialGradient::create());
		}
		case 1:
		{
			break;
		}
		case 2:
		{
			break;
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			break;
		}
		case 5:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Color4B>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Color4B>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Vec2>(context->argument(3));
			auto arg4 = qscriptvalue_cast<float>(context->argument(4));
			return __e->toScriptValue(LayerRadialGradient::create(arg0, arg1, arg2, arg3, arg4));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::LayerRadialGradient::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptLayerMultiplex::QtScriptLayerMultiplex(QScriptEngine *engine, const QByteArray &className)
	: QtScriptLayer(engine, className)
{
}

QtScriptLayerMultiplex::QtScriptLayerMultiplex(QScriptEngine *engine)
	: QtScriptLayerMultiplex(engine, "LayerMultiplex")
{
}

void QtScriptLayerMultiplex::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Layer *>());
	auto ctor = RegisterT<LayerMultiplex, QtScriptLayerMultiplex>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptLayerMultiplex::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithArray", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptLayerMultiplex::createWithArray)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithLayer", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptLayerMultiplex::createWithLayer)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptLayerMultiplex::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptLayerMultiplex::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptLayerMultiplex::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::LayerMultiplex");
	return false;
}

void QtScriptLayerMultiplex::addLayer(cocos2d::Layer* layer)
{
	auto __o = this->thiz<LayerMultiplex *>();
	if (__o)
	{
		__o->addLayer(layer);
	}
}

bool QtScriptLayerMultiplex::initWithArray(const cocos2d::Vector<cocos2d::Layer *>& arrayOfLayers)
{
	auto __o = this->thiz<LayerMultiplex *>();
	if (__o)
	{
		return __o->initWithArray(arrayOfLayers);
	}
	return false;
}

void QtScriptLayerMultiplex::switchTo(int n)
{
	auto __o = this->thiz<LayerMultiplex *>();
	if (__o)
	{
		__o->switchTo(n);
	}
}

void QtScriptLayerMultiplex::switchTo(int n, bool cleanup)
{
	auto __o = this->thiz<LayerMultiplex *>();
	if (__o)
	{
		__o->switchTo(n, cleanup);
	}
}

void QtScriptLayerMultiplex::switchToAndReleaseMe(int n)
{
	auto __o = this->thiz<LayerMultiplex *>();
	if (__o)
	{
		__o->switchToAndReleaseMe(n);
	}
}

QScriptValue QtScriptLayerMultiplex::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(LayerMultiplex::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::LayerMultiplex::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptLayerMultiplex::createWithArray(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vector<cocos2d::Layer *>>(context->argument(0));
			return __e->toScriptValue(LayerMultiplex::createWithArray(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::LayerMultiplex::createWithArray");
	return __e->uncaughtException();
}

QScriptValue QtScriptLayerMultiplex::createWithLayer(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Layer*>(context->argument(0));
			return __e->toScriptValue(LayerMultiplex::createWithLayer(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::LayerMultiplex::createWithLayer");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptMenuItem::QtScriptMenuItem(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptMenuItem::QtScriptMenuItem(QScriptEngine *engine)
	: QtScriptMenuItem(engine, "MenuItem")
{
}

void QtScriptMenuItem::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<MenuItem, QtScriptMenuItem>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMenuItem::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptMenuItem::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMenuItem::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMenuItem::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::MenuItem");
	return false;
}

bool QtScriptMenuItem::initWithCallback(QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<MenuItem *>();
	if (__o)
	{
		return __o->initWithCallback(!callback.isFunction() ? cocos2d::ccMenuCallback() : [=](cocos2d::Ref* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
	return false;
}

bool QtScriptMenuItem::isEnabled()
{
	auto __o = this->thiz<MenuItem *>();
	if (__o)
	{
		return __o->isEnabled();
	}
	return false;
}

bool QtScriptMenuItem::isSelected()
{
	auto __o = this->thiz<MenuItem *>();
	if (__o)
	{
		return __o->isSelected();
	}
	return false;
}

cocos2d::Rect QtScriptMenuItem::rect()
{
	auto __o = this->thiz<MenuItem *>();
	if (__o)
	{
		return __o->rect();
	}
	return cocos2d::Rect();
}

void QtScriptMenuItem::setCallback(QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<MenuItem *>();
	if (__o)
	{
		__o->setCallback(!callback.isFunction() ? cocos2d::ccMenuCallback() : [=](cocos2d::Ref* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

void QtScriptMenuItem::setEnabled(bool value)
{
	auto __o = this->thiz<MenuItem *>();
	if (__o)
	{
		__o->setEnabled(value);
	}
}

QScriptValue QtScriptMenuItem::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(MenuItem::create());
		}
		case 1:
		{
			auto tmp_0 = context->argument(0);
			auto arg0 = !tmp_0.isFunction() ? cocos2d::ccMenuCallback() : [=](cocos2d::Ref* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	tmp_0.call(QScriptValue(), arguments);
};
			return __e->toScriptValue(MenuItem::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MenuItem::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptMenuItemLabel::QtScriptMenuItemLabel(QScriptEngine *engine, const QByteArray &className)
	: QtScriptMenuItem(engine, className)
{
}

QtScriptMenuItemLabel::QtScriptMenuItemLabel(QScriptEngine *engine)
	: QtScriptMenuItemLabel(engine, "MenuItemLabel")
{
}

void QtScriptMenuItemLabel::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<MenuItem *>());
	auto ctor = RegisterT<MenuItemLabel, QtScriptMenuItemLabel>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMenuItemLabel::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptMenuItemLabel::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMenuItemLabel::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMenuItemLabel::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::MenuItemLabel");
	return false;
}

cocos2d::Color3B QtScriptMenuItemLabel::getDisabledColor()
{
	auto __o = this->thiz<MenuItemLabel *>();
	if (__o)
	{
		return __o->getDisabledColor();
	}
	return cocos2d::Color3B();
}

cocos2d::Node* QtScriptMenuItemLabel::getLabel()
{
	auto __o = this->thiz<MenuItemLabel *>();
	if (__o)
	{
		return __o->getLabel();
	}
	return nullptr;
}

QByteArray QtScriptMenuItemLabel::getString()
{
	auto __o = this->thiz<MenuItemLabel *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getString());
	}
	return QByteArray();
}

bool QtScriptMenuItemLabel::initWithLabel(cocos2d::Node* label, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<MenuItemLabel *>();
	if (__o)
	{
		return __o->initWithLabel(label, !callback.isFunction() ? cocos2d::ccMenuCallback() : [=](cocos2d::Ref* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
	return false;
}

void QtScriptMenuItemLabel::setDisabledColor(const cocos2d::Color3B& color)
{
	auto __o = this->thiz<MenuItemLabel *>();
	if (__o)
	{
		__o->setDisabledColor(color);
	}
}

void QtScriptMenuItemLabel::setLabel(cocos2d::Node* node)
{
	auto __o = this->thiz<MenuItemLabel *>();
	if (__o)
	{
		__o->setLabel(node);
	}
}

void QtScriptMenuItemLabel::setString(const QByteArray& label)
{
	auto __o = this->thiz<MenuItemLabel *>();
	if (__o)
	{
		__o->setString(label.toStdString());
	}
}

QScriptValue QtScriptMenuItemLabel::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Node*>(context->argument(0));
			return __e->toScriptValue(MenuItemLabel::create(arg0));
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Node*>(context->argument(0));
			auto tmp_1 = context->argument(1);
			auto arg1 = !tmp_1.isFunction() ? cocos2d::ccMenuCallback() : [=](cocos2d::Ref* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	tmp_1.call(QScriptValue(), arguments);
};
			return __e->toScriptValue(MenuItemLabel::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MenuItemLabel::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptMenuItemAtlasFont::QtScriptMenuItemAtlasFont(QScriptEngine *engine, const QByteArray &className)
	: QtScriptMenuItemLabel(engine, className)
{
}

QtScriptMenuItemAtlasFont::QtScriptMenuItemAtlasFont(QScriptEngine *engine)
	: QtScriptMenuItemAtlasFont(engine, "MenuItemAtlasFont")
{
}

void QtScriptMenuItemAtlasFont::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<MenuItemLabel *>());
	auto ctor = RegisterT<MenuItemAtlasFont, QtScriptMenuItemAtlasFont>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMenuItemAtlasFont::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptMenuItemAtlasFont::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMenuItemAtlasFont::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMenuItemAtlasFont::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::MenuItemAtlasFont");
	return false;
}

bool QtScriptMenuItemAtlasFont::initWithString(const QByteArray& value, const QByteArray& charMapFile, int itemWidth, int itemHeight, char startCharMap, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<MenuItemAtlasFont *>();
	if (__o)
	{
		return __o->initWithString(value.toStdString(), charMapFile.toStdString(), itemWidth, itemHeight, startCharMap, !callback.isFunction() ? cocos2d::ccMenuCallback() : [=](cocos2d::Ref* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
	return false;
}

QScriptValue QtScriptMenuItemAtlasFont::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 5, 6))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 5:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto arg2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg3 = qscriptvalue_cast<int>(context->argument(3));
			auto arg4 = qscriptvalue_cast<char>(context->argument(4));
			return __e->toScriptValue(MenuItemAtlasFont::create(arg0, arg1, arg2, arg3, arg4));
		}
		case 6:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto arg2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg3 = qscriptvalue_cast<int>(context->argument(3));
			auto arg4 = qscriptvalue_cast<char>(context->argument(4));
			auto tmp_5 = context->argument(5);
			auto arg5 = !tmp_5.isFunction() ? cocos2d::ccMenuCallback() : [=](cocos2d::Ref* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	tmp_5.call(QScriptValue(), arguments);
};
			return __e->toScriptValue(MenuItemAtlasFont::create(arg0, arg1, arg2, arg3, arg4, arg5));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MenuItemAtlasFont::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptMenuItemFont::QtScriptMenuItemFont(QScriptEngine *engine, const QByteArray &className)
	: QtScriptMenuItemLabel(engine, className)
{
}

QtScriptMenuItemFont::QtScriptMenuItemFont(QScriptEngine *engine)
	: QtScriptMenuItemFont(engine, "MenuItemFont")
{
}

void QtScriptMenuItemFont::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<MenuItemLabel *>());
	auto ctor = RegisterT<MenuItemFont, QtScriptMenuItemFont>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMenuItemFont::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getFontName", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMenuItemFont::getFontName)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getFontSize", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMenuItemFont::getFontSize)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("setFontName", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMenuItemFont::setFontName)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("setFontSize", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMenuItemFont::setFontSize)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptMenuItemFont::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMenuItemFont::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMenuItemFont::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::MenuItemFont");
	return false;
}

QByteArray QtScriptMenuItemFont::getFontName()
{
	auto __o = this->thiz<MenuItemFont *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getFontNameObj());
	}
	return QByteArray();
}

int QtScriptMenuItemFont::getFontSize()
{
	auto __o = this->thiz<MenuItemFont *>();
	if (__o)
	{
		return __o->getFontSizeObj();
	}
	return 0;
}

bool QtScriptMenuItemFont::initWithString(const QByteArray& value, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<MenuItemFont *>();
	if (__o)
	{
		return __o->initWithString(value.toStdString(), !callback.isFunction() ? cocos2d::ccMenuCallback() : [=](cocos2d::Ref* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
	return false;
}

void QtScriptMenuItemFont::setFontName(const QByteArray& name)
{
	auto __o = this->thiz<MenuItemFont *>();
	if (__o)
	{
		__o->setFontNameObj(name.toStdString());
	}
}

void QtScriptMenuItemFont::setFontSize(int size)
{
	auto __o = this->thiz<MenuItemFont *>();
	if (__o)
	{
		__o->setFontSizeObj(size);
	}
}

QScriptValue QtScriptMenuItemFont::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(MenuItemFont::create());
		}
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(MenuItemFont::create(arg0));
		}
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = context->argument(1);
			auto arg1 = !tmp_1.isFunction() ? cocos2d::ccMenuCallback() : [=](cocos2d::Ref* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	tmp_1.call(QScriptValue(), arguments);
};
			return __e->toScriptValue(MenuItemFont::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MenuItemFont::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptMenuItemFont::getFontName(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(QByteArray::fromStdString(MenuItemFont::getFontName()));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MenuItemFont::getFontName");
	return __e->uncaughtException();
}

QScriptValue QtScriptMenuItemFont::getFontSize(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(MenuItemFont::getFontSize());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MenuItemFont::getFontSize");
	return __e->uncaughtException();
}

QScriptValue QtScriptMenuItemFont::setFontName(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			MenuItemFont::setFontName(arg0);
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MenuItemFont::setFontName");
	return __e->uncaughtException();
}

QScriptValue QtScriptMenuItemFont::setFontSize(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			MenuItemFont::setFontSize(arg0);
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MenuItemFont::setFontSize");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptMenuItemSprite::QtScriptMenuItemSprite(QScriptEngine *engine, const QByteArray &className)
	: QtScriptMenuItem(engine, className)
{
}

QtScriptMenuItemSprite::QtScriptMenuItemSprite(QScriptEngine *engine)
	: QtScriptMenuItemSprite(engine, "MenuItemSprite")
{
}

void QtScriptMenuItemSprite::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<MenuItem *>());
	auto ctor = RegisterT<MenuItemSprite, QtScriptMenuItemSprite>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMenuItemSprite::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptMenuItemSprite::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMenuItemSprite::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMenuItemSprite::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::MenuItemSprite");
	return false;
}

cocos2d::Node* QtScriptMenuItemSprite::getDisabledImage()
{
	auto __o = this->thiz<MenuItemSprite *>();
	if (__o)
	{
		return __o->getDisabledImage();
	}
	return nullptr;
}

cocos2d::Node* QtScriptMenuItemSprite::getNormalImage()
{
	auto __o = this->thiz<MenuItemSprite *>();
	if (__o)
	{
		return __o->getNormalImage();
	}
	return nullptr;
}

cocos2d::Node* QtScriptMenuItemSprite::getSelectedImage()
{
	auto __o = this->thiz<MenuItemSprite *>();
	if (__o)
	{
		return __o->getSelectedImage();
	}
	return nullptr;
}

bool QtScriptMenuItemSprite::initWithNormalSprite(cocos2d::Node* normalSprite, cocos2d::Node* selectedSprite, cocos2d::Node* disabledSprite, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<MenuItemSprite *>();
	if (__o)
	{
		return __o->initWithNormalSprite(normalSprite, selectedSprite, disabledSprite, !callback.isFunction() ? cocos2d::ccMenuCallback() : [=](cocos2d::Ref* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
	return false;
}

void QtScriptMenuItemSprite::setDisabledImage(cocos2d::Node* image)
{
	auto __o = this->thiz<MenuItemSprite *>();
	if (__o)
	{
		__o->setDisabledImage(image);
	}
}

void QtScriptMenuItemSprite::setNormalImage(cocos2d::Node* image)
{
	auto __o = this->thiz<MenuItemSprite *>();
	if (__o)
	{
		__o->setNormalImage(image);
	}
}

void QtScriptMenuItemSprite::setSelectedImage(cocos2d::Node* image)
{
	auto __o = this->thiz<MenuItemSprite *>();
	if (__o)
	{
		__o->setSelectedImage(image);
	}
}

QScriptValue QtScriptMenuItemSprite::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Node*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Node*>(context->argument(1));
			return __e->toScriptValue(MenuItemSprite::create(arg0, arg1));
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Node*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Node*>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Node*>(context->argument(2));
			return __e->toScriptValue(MenuItemSprite::create(arg0, arg1, arg2));
		}
		case 4:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Node*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Node*>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Node*>(context->argument(2));
			auto tmp_3 = context->argument(3);
			auto arg3 = !tmp_3.isFunction() ? cocos2d::ccMenuCallback() : [=](cocos2d::Ref* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	tmp_3.call(QScriptValue(), arguments);
};
			return __e->toScriptValue(MenuItemSprite::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MenuItemSprite::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptMenuItemImage::QtScriptMenuItemImage(QScriptEngine *engine, const QByteArray &className)
	: QtScriptMenuItemSprite(engine, className)
{
}

QtScriptMenuItemImage::QtScriptMenuItemImage(QScriptEngine *engine)
	: QtScriptMenuItemImage(engine, "MenuItemImage")
{
}

void QtScriptMenuItemImage::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<MenuItemSprite *>());
	auto ctor = RegisterT<MenuItemImage, QtScriptMenuItemImage>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMenuItemImage::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptMenuItemImage::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMenuItemImage::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMenuItemImage::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::MenuItemImage");
	return false;
}

bool QtScriptMenuItemImage::initWithNormalImage(const QByteArray& normalImage, const QByteArray& selectedImage, const QByteArray& disabledImage, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<MenuItemImage *>();
	if (__o)
	{
		return __o->initWithNormalImage(normalImage.toStdString(), selectedImage.toStdString(), disabledImage.toStdString(), !callback.isFunction() ? cocos2d::ccMenuCallback() : [=](cocos2d::Ref* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
	return false;
}

void QtScriptMenuItemImage::setDisabledSpriteFrame(cocos2d::SpriteFrame* frame)
{
	auto __o = this->thiz<MenuItemImage *>();
	if (__o)
	{
		__o->setDisabledSpriteFrame(frame);
	}
}

void QtScriptMenuItemImage::setNormalSpriteFrame(cocos2d::SpriteFrame* frame)
{
	auto __o = this->thiz<MenuItemImage *>();
	if (__o)
	{
		__o->setNormalSpriteFrame(frame);
	}
}

void QtScriptMenuItemImage::setSelectedSpriteFrame(cocos2d::SpriteFrame* frame)
{
	auto __o = this->thiz<MenuItemImage *>();
	if (__o)
	{
		__o->setSelectedSpriteFrame(frame);
	}
}

QScriptValue QtScriptMenuItemImage::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(MenuItemImage::create());
		}
		case 1:
		{
			break;
		}
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			return __e->toScriptValue(MenuItemImage::create(arg0, arg1));
		}
		case 3:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto tmp_2 = qscriptvalue_cast<QByteArray>(context->argument(2));
			auto arg2 = tmp_2.toStdString();
			return __e->toScriptValue(MenuItemImage::create(arg0, arg1, arg2));
		}
		case 4:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto tmp_2 = qscriptvalue_cast<QByteArray>(context->argument(2));
			auto arg2 = tmp_2.toStdString();
			auto tmp_3 = context->argument(3);
			auto arg3 = !tmp_3.isFunction() ? cocos2d::ccMenuCallback() : [=](cocos2d::Ref* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	tmp_3.call(QScriptValue(), arguments);
};
			return __e->toScriptValue(MenuItemImage::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MenuItemImage::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptMenuItemToggle::QtScriptMenuItemToggle(QScriptEngine *engine, const QByteArray &className)
	: QtScriptMenuItem(engine, className)
{
}

QtScriptMenuItemToggle::QtScriptMenuItemToggle(QScriptEngine *engine)
	: QtScriptMenuItemToggle(engine, "MenuItemToggle")
{
}

void QtScriptMenuItemToggle::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<MenuItem *>());
	auto ctor = RegisterT<MenuItemToggle, QtScriptMenuItemToggle>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMenuItemToggle::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithCallback", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMenuItemToggle::createWithCallback)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptMenuItemToggle::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMenuItemToggle::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMenuItemToggle::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::MenuItemToggle");
	return false;
}

void QtScriptMenuItemToggle::addSubItem(cocos2d::MenuItem* item)
{
	auto __o = this->thiz<MenuItemToggle *>();
	if (__o)
	{
		__o->addSubItem(item);
	}
}

unsigned int QtScriptMenuItemToggle::getSelectedIndex()
{
	auto __o = this->thiz<MenuItemToggle *>();
	if (__o)
	{
		return __o->getSelectedIndex();
	}
	return static_cast<unsigned int>(0);
}

cocos2d::MenuItem* QtScriptMenuItemToggle::getSelectedItem()
{
	auto __o = this->thiz<MenuItemToggle *>();
	if (__o)
	{
		return __o->getSelectedItem();
	}
	return nullptr;
}

cocos2d::Vector<cocos2d::MenuItem *> QtScriptMenuItemToggle::getSubItems()
{
	auto __o = this->thiz<MenuItemToggle *>();
	if (__o)
	{
		return __o->getSubItems();
	}
	return cocos2d::Vector<cocos2d::MenuItem *>();
}

bool QtScriptMenuItemToggle::initWithItem(cocos2d::MenuItem* item)
{
	auto __o = this->thiz<MenuItemToggle *>();
	if (__o)
	{
		return __o->initWithItem(item);
	}
	return false;
}

void QtScriptMenuItemToggle::setSelectedIndex(unsigned int index)
{
	auto __o = this->thiz<MenuItemToggle *>();
	if (__o)
	{
		__o->setSelectedIndex(index);
	}
}

void QtScriptMenuItemToggle::setSubItems(const cocos2d::Vector<cocos2d::MenuItem *>& items)
{
	auto __o = this->thiz<MenuItemToggle *>();
	if (__o)
	{
		__o->setSubItems(items);
	}
}

QScriptValue QtScriptMenuItemToggle::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(MenuItemToggle::create());
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::MenuItem*>(context->argument(0));
			return __e->toScriptValue(MenuItemToggle::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MenuItemToggle::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptMenuItemToggle::createWithCallback(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto tmp_0 = context->argument(0);
			auto arg0 = !tmp_0.isFunction() ? cocos2d::ccMenuCallback() : [=](cocos2d::Ref* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	tmp_0.call(QScriptValue(), arguments);
};
			auto arg1 = qscriptvalue_cast<cocos2d::Vector<cocos2d::MenuItem *>>(context->argument(1));
			return __e->toScriptValue(MenuItemToggle::createWithCallback(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MenuItemToggle::createWithCallback");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptMenu::QtScriptMenu(QScriptEngine *engine, const QByteArray &className)
	: QtScriptLayer(engine, className)
{
}

QtScriptMenu::QtScriptMenu(QScriptEngine *engine)
	: QtScriptMenu(engine, "Menu")
{
}

void QtScriptMenu::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Layer *>());
	auto ctor = RegisterT<Menu, QtScriptMenu>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMenu::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithArray", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMenu::createWithArray)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithItem", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMenu::createWithItem)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptMenu::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMenu::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMenu::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Menu");
	return false;
}

void QtScriptMenu::alignItemsHorizontally()
{
	auto __o = this->thiz<Menu *>();
	if (__o)
	{
		__o->alignItemsHorizontally();
	}
}

void QtScriptMenu::alignItemsHorizontallyWithPadding(float padding)
{
	auto __o = this->thiz<Menu *>();
	if (__o)
	{
		__o->alignItemsHorizontallyWithPadding(padding);
	}
}

void QtScriptMenu::alignItemsInColumnsWithArray(const cocos2d::ValueVector& rows)
{
	auto __o = this->thiz<Menu *>();
	if (__o)
	{
		__o->alignItemsInColumnsWithArray(rows);
	}
}

void QtScriptMenu::alignItemsInRowsWithArray(const cocos2d::ValueVector& columns)
{
	auto __o = this->thiz<Menu *>();
	if (__o)
	{
		__o->alignItemsInRowsWithArray(columns);
	}
}

void QtScriptMenu::alignItemsVertically()
{
	auto __o = this->thiz<Menu *>();
	if (__o)
	{
		__o->alignItemsVertically();
	}
}

void QtScriptMenu::alignItemsVerticallyWithPadding(float padding)
{
	auto __o = this->thiz<Menu *>();
	if (__o)
	{
		__o->alignItemsVerticallyWithPadding(padding);
	}
}

bool QtScriptMenu::initWithArray(const cocos2d::Vector<cocos2d::MenuItem *>& arrayOfItems)
{
	auto __o = this->thiz<Menu *>();
	if (__o)
	{
		return __o->initWithArray(arrayOfItems);
	}
	return false;
}

bool QtScriptMenu::isEnabled()
{
	auto __o = this->thiz<Menu *>();
	if (__o)
	{
		return __o->isEnabled();
	}
	return false;
}

void QtScriptMenu::setEnabled(bool value)
{
	auto __o = this->thiz<Menu *>();
	if (__o)
	{
		__o->setEnabled(value);
	}
}

QScriptValue QtScriptMenu::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Menu::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Menu::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptMenu::createWithArray(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vector<cocos2d::MenuItem *>>(context->argument(0));
			return __e->toScriptValue(Menu::createWithArray(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Menu::createWithArray");
	return __e->uncaughtException();
}

QScriptValue QtScriptMenu::createWithItem(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::MenuItem*>(context->argument(0));
			return __e->toScriptValue(Menu::createWithItem(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Menu::createWithItem");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptMotionStreak::QtScriptMotionStreak(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptMotionStreak::QtScriptMotionStreak(QScriptEngine *engine)
	: QtScriptMotionStreak(engine, "MotionStreak")
{
}

void QtScriptMotionStreak::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<MotionStreak, QtScriptMotionStreak>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMotionStreak::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptMotionStreak::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMotionStreak::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMotionStreak::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::MotionStreak");
	return false;
}

cocos2d::BlendFunc QtScriptMotionStreak::getBlendFunc()
{
	auto __o = this->thiz<MotionStreak *>();
	if (__o)
	{
		return __o->getBlendFunc();
	}
	return cocos2d::BlendFunc();
}

float QtScriptMotionStreak::getStroke()
{
	auto __o = this->thiz<MotionStreak *>();
	if (__o)
	{
		return __o->getStroke();
	}
	return static_cast<float>(0);
}

cocos2d::Texture2D* QtScriptMotionStreak::getTexture()
{
	auto __o = this->thiz<MotionStreak *>();
	if (__o)
	{
		return __o->getTexture();
	}
	return nullptr;
}

bool QtScriptMotionStreak::initWithFade(float fade, float minSeg, float stroke, const cocos2d::Color3B& color, const QByteArray& path)
{
	auto __o = this->thiz<MotionStreak *>();
	if (__o)
	{
		return __o->initWithFade(fade, minSeg, stroke, color, path.toStdString());
	}
	return false;
}

bool QtScriptMotionStreak::isFastMode()
{
	auto __o = this->thiz<MotionStreak *>();
	if (__o)
	{
		return __o->isFastMode();
	}
	return false;
}

bool QtScriptMotionStreak::isStartingPositionInitialized()
{
	auto __o = this->thiz<MotionStreak *>();
	if (__o)
	{
		return __o->isStartingPositionInitialized();
	}
	return false;
}

void QtScriptMotionStreak::reset()
{
	auto __o = this->thiz<MotionStreak *>();
	if (__o)
	{
		__o->reset();
	}
}

void QtScriptMotionStreak::setBlendFunc(const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<MotionStreak *>();
	if (__o)
	{
		__o->setBlendFunc(blendFunc);
	}
}

void QtScriptMotionStreak::setFastMode(bool bFastMode)
{
	auto __o = this->thiz<MotionStreak *>();
	if (__o)
	{
		__o->setFastMode(bFastMode);
	}
}

void QtScriptMotionStreak::setStartingPositionInitialized(bool bStartingPositionInitialized)
{
	auto __o = this->thiz<MotionStreak *>();
	if (__o)
	{
		__o->setStartingPositionInitialized(bStartingPositionInitialized);
	}
}

void QtScriptMotionStreak::setStroke(float stroke)
{
	auto __o = this->thiz<MotionStreak *>();
	if (__o)
	{
		__o->setStroke(stroke);
	}
}

void QtScriptMotionStreak::setTexture(cocos2d::Texture2D* texture)
{
	auto __o = this->thiz<MotionStreak *>();
	if (__o)
	{
		__o->setTexture(texture);
	}
}

void QtScriptMotionStreak::tintWithColor(const cocos2d::Color3B& colors)
{
	auto __o = this->thiz<MotionStreak *>();
	if (__o)
	{
		__o->tintWithColor(colors);
	}
}

QScriptValue QtScriptMotionStreak::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 5, 5))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 5:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Color3B>(context->argument(3));
			auto tmp_4 = qscriptvalue_cast<QByteArray>(context->argument(4));
			auto arg4 = tmp_4.toStdString();
			return __e->toScriptValue(MotionStreak::create(arg0, arg1, arg2, arg3, arg4));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MotionStreak::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptNodeGrid::QtScriptNodeGrid(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptNodeGrid::QtScriptNodeGrid(QScriptEngine *engine)
	: QtScriptNodeGrid(engine, "NodeGrid")
{
}

void QtScriptNodeGrid::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<NodeGrid, QtScriptNodeGrid>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptNodeGrid::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptNodeGrid::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptNodeGrid::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptNodeGrid::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::NodeGrid");
	return false;
}

cocos2d::GridBase* QtScriptNodeGrid::getGrid()
{
	auto __o = this->thiz<NodeGrid *>();
	if (__o)
	{
		return __o->getGrid();
	}
	return nullptr;
}

cocos2d::Rect QtScriptNodeGrid::getGridRect()
{
	auto __o = this->thiz<NodeGrid *>();
	if (__o)
	{
		return __o->getGridRect();
	}
	return cocos2d::Rect();
}

void QtScriptNodeGrid::setGrid(cocos2d::GridBase* grid)
{
	auto __o = this->thiz<NodeGrid *>();
	if (__o)
	{
		__o->setGrid(grid);
	}
}

void QtScriptNodeGrid::setGridRect(const cocos2d::Rect& gridRect)
{
	auto __o = this->thiz<NodeGrid *>();
	if (__o)
	{
		__o->setGridRect(gridRect);
	}
}

void QtScriptNodeGrid::setTarget(cocos2d::Node* target)
{
	auto __o = this->thiz<NodeGrid *>();
	if (__o)
	{
		__o->setTarget(target);
	}
}

QScriptValue QtScriptNodeGrid::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(NodeGrid::create());
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Rect>(context->argument(0));
			return __e->toScriptValue(NodeGrid::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::NodeGrid::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptParticleBatchNode::QtScriptParticleBatchNode(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptParticleBatchNode::QtScriptParticleBatchNode(QScriptEngine *engine)
	: QtScriptParticleBatchNode(engine, "ParticleBatchNode")
{
}

void QtScriptParticleBatchNode::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<ParticleBatchNode, QtScriptParticleBatchNode>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleBatchNode::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTexture", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleBatchNode::createWithTexture)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptParticleBatchNode::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptParticleBatchNode::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptParticleBatchNode::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ParticleBatchNode");
	return false;
}

void QtScriptParticleBatchNode::disableParticle(int particleIndex)
{
	auto __o = this->thiz<ParticleBatchNode *>();
	if (__o)
	{
		__o->disableParticle(particleIndex);
	}
}

cocos2d::BlendFunc QtScriptParticleBatchNode::getBlendFunc()
{
	auto __o = this->thiz<ParticleBatchNode *>();
	if (__o)
	{
		return __o->getBlendFunc();
	}
	return cocos2d::BlendFunc();
}

cocos2d::Texture2D* QtScriptParticleBatchNode::getTexture()
{
	auto __o = this->thiz<ParticleBatchNode *>();
	if (__o)
	{
		return __o->getTexture();
	}
	return nullptr;
}

cocos2d::TextureAtlas* QtScriptParticleBatchNode::getTextureAtlas()
{
	auto __o = this->thiz<ParticleBatchNode *>();
	if (__o)
	{
		return __o->getTextureAtlas();
	}
	return nullptr;
}

bool QtScriptParticleBatchNode::initWithFile(const QByteArray& fileImage, int capacity)
{
	auto __o = this->thiz<ParticleBatchNode *>();
	if (__o)
	{
		return __o->initWithFile(fileImage.toStdString(), capacity);
	}
	return false;
}

bool QtScriptParticleBatchNode::initWithTexture(cocos2d::Texture2D* tex, int capacity)
{
	auto __o = this->thiz<ParticleBatchNode *>();
	if (__o)
	{
		return __o->initWithTexture(tex, capacity);
	}
	return false;
}

void QtScriptParticleBatchNode::insertChild(cocos2d::ParticleSystem* system, int index)
{
	auto __o = this->thiz<ParticleBatchNode *>();
	if (__o)
	{
		__o->insertChild(system, index);
	}
}

void QtScriptParticleBatchNode::removeChildAtIndex(int index, bool doCleanup)
{
	auto __o = this->thiz<ParticleBatchNode *>();
	if (__o)
	{
		__o->removeChildAtIndex(index, doCleanup);
	}
}

void QtScriptParticleBatchNode::setBlendFunc(const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<ParticleBatchNode *>();
	if (__o)
	{
		__o->setBlendFunc(blendFunc);
	}
}

void QtScriptParticleBatchNode::setTexture(cocos2d::Texture2D* texture)
{
	auto __o = this->thiz<ParticleBatchNode *>();
	if (__o)
	{
		__o->setTexture(texture);
	}
}

void QtScriptParticleBatchNode::setTextureAtlas(cocos2d::TextureAtlas* atlas)
{
	auto __o = this->thiz<ParticleBatchNode *>();
	if (__o)
	{
		__o->setTextureAtlas(atlas);
	}
}

QScriptValue QtScriptParticleBatchNode::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(ParticleBatchNode::create(arg0));
		}
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<int>(context->argument(1));
			return __e->toScriptValue(ParticleBatchNode::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleBatchNode::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptParticleBatchNode::createWithTexture(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(0));
			return __e->toScriptValue(ParticleBatchNode::createWithTexture(arg0));
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<int>(context->argument(1));
			return __e->toScriptValue(ParticleBatchNode::createWithTexture(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleBatchNode::createWithTexture");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptParticleSystem::QtScriptParticleSystem(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptParticleSystem::QtScriptParticleSystem(QScriptEngine *engine)
	: QtScriptParticleSystem(engine, "ParticleSystem")
{
}

void QtScriptParticleSystem::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<ParticleSystem, QtScriptParticleSystem>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleSystem::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTotalParticles", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleSystem::createWithTotalParticles)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getAllParticleSystems", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleSystem::getAllParticleSystems)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptParticleSystem::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptParticleSystem::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptParticleSystem::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ParticleSystem");
	return false;
}

void QtScriptParticleSystem::addParticles(int count)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->addParticles(count);
	}
}

float QtScriptParticleSystem::getAngle()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getAngle();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getAngleVar()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getAngleVar();
	}
	return static_cast<float>(0);
}

int QtScriptParticleSystem::getAtlasIndex()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getAtlasIndex();
	}
	return 0;
}

cocos2d::ParticleBatchNode* QtScriptParticleSystem::getBatchNode()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getBatchNode();
	}
	return nullptr;
}

cocos2d::BlendFunc QtScriptParticleSystem::getBlendFunc()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getBlendFunc();
	}
	return cocos2d::BlendFunc();
}

float QtScriptParticleSystem::getDuration()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getDuration();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getEmissionRate()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getEmissionRate();
	}
	return static_cast<float>(0);
}

int QtScriptParticleSystem::getEmitterMode()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return int(__o->getEmitterMode());
	}
	return 0;
}

cocos2d::Color4F QtScriptParticleSystem::getEndColor()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getEndColor();
	}
	return cocos2d::Color4F();
}

cocos2d::Color4F QtScriptParticleSystem::getEndColorVar()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getEndColorVar();
	}
	return cocos2d::Color4F();
}

float QtScriptParticleSystem::getEndRadius()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getEndRadius();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getEndRadiusVar()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getEndRadiusVar();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getEndSize()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getEndSize();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getEndSizeVar()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getEndSizeVar();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getEndSpin()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getEndSpin();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getEndSpinVar()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getEndSpinVar();
	}
	return static_cast<float>(0);
}

cocos2d::Vec2 QtScriptParticleSystem::getGravity()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getGravity();
	}
	return cocos2d::Vec2();
}

float QtScriptParticleSystem::getLife()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getLife();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getLifeVar()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getLifeVar();
	}
	return static_cast<float>(0);
}

unsigned int QtScriptParticleSystem::getParticleCount()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getParticleCount();
	}
	return static_cast<unsigned int>(0);
}

cocos2d::Vec2 QtScriptParticleSystem::getPosVar()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getPosVar();
	}
	return cocos2d::Vec2();
}

int QtScriptParticleSystem::getPositionType()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return int(__o->getPositionType());
	}
	return 0;
}

float QtScriptParticleSystem::getRadialAccel()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getRadialAccel();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getRadialAccelVar()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getRadialAccelVar();
	}
	return static_cast<float>(0);
}

QByteArray QtScriptParticleSystem::getResourceFile()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getResourceFile());
	}
	return QByteArray();
}

float QtScriptParticleSystem::getRotatePerSecond()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getRotatePerSecond();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getRotatePerSecondVar()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getRotatePerSecondVar();
	}
	return static_cast<float>(0);
}

bool QtScriptParticleSystem::getRotationIsDir()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getRotationIsDir();
	}
	return false;
}

cocos2d::Vec2 QtScriptParticleSystem::getSourcePosition()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getSourcePosition();
	}
	return cocos2d::Vec2();
}

float QtScriptParticleSystem::getSpeed()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getSpeed();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getSpeedVar()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getSpeedVar();
	}
	return static_cast<float>(0);
}

cocos2d::Color4F QtScriptParticleSystem::getStartColor()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getStartColor();
	}
	return cocos2d::Color4F();
}

cocos2d::Color4F QtScriptParticleSystem::getStartColorVar()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getStartColorVar();
	}
	return cocos2d::Color4F();
}

float QtScriptParticleSystem::getStartRadius()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getStartRadius();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getStartRadiusVar()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getStartRadiusVar();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getStartSize()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getStartSize();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getStartSizeVar()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getStartSizeVar();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getStartSpin()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getStartSpin();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getStartSpinVar()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getStartSpinVar();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getTangentialAccel()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getTangentialAccel();
	}
	return static_cast<float>(0);
}

float QtScriptParticleSystem::getTangentialAccelVar()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getTangentialAccelVar();
	}
	return static_cast<float>(0);
}

cocos2d::Texture2D* QtScriptParticleSystem::getTexture()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getTexture();
	}
	return nullptr;
}

int QtScriptParticleSystem::getTotalParticles()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->getTotalParticles();
	}
	return 0;
}

bool QtScriptParticleSystem::initWithData(const QByteArray& arg0)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->initWithData(arg0.data(), arg0.size());
	}
	return false;
}

bool QtScriptParticleSystem::initWithFile(const QByteArray& plistFile)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->initWithFile(plistFile.toStdString());
	}
	return false;
}

bool QtScriptParticleSystem::initWithTotalParticles(int numberOfParticles)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->initWithTotalParticles(numberOfParticles);
	}
	return false;
}

bool QtScriptParticleSystem::isActive()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->isActive();
	}
	return false;
}

bool QtScriptParticleSystem::isAutoRemoveOnFinish()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->isAutoRemoveOnFinish();
	}
	return false;
}

bool QtScriptParticleSystem::isBlendAdditive()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->isBlendAdditive();
	}
	return false;
}

bool QtScriptParticleSystem::isFull()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->isFull();
	}
	return false;
}

bool QtScriptParticleSystem::isPaused()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->isPaused();
	}
	return false;
}

bool QtScriptParticleSystem::isSourcePositionCompatible()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		return __o->isSourcePositionCompatible();
	}
	return false;
}

void QtScriptParticleSystem::pauseEmissions()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->pauseEmissions();
	}
}

void QtScriptParticleSystem::postStep()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->postStep();
	}
}

void QtScriptParticleSystem::resetSystem()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->resetSystem();
	}
}

void QtScriptParticleSystem::resumeEmissions()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->resumeEmissions();
	}
}

void QtScriptParticleSystem::setAngle(float angle)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setAngle(angle);
	}
}

void QtScriptParticleSystem::setAngleVar(float angleVar)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setAngleVar(angleVar);
	}
}

void QtScriptParticleSystem::setAtlasIndex(int index)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setAtlasIndex(index);
	}
}

void QtScriptParticleSystem::setAutoRemoveOnFinish(bool var)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setAutoRemoveOnFinish(var);
	}
}

void QtScriptParticleSystem::setBatchNode(cocos2d::ParticleBatchNode* batchNode)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setBatchNode(batchNode);
	}
}

void QtScriptParticleSystem::setBlendAdditive(bool value)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setBlendAdditive(value);
	}
}

void QtScriptParticleSystem::setBlendFunc(const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setBlendFunc(blendFunc);
	}
}

void QtScriptParticleSystem::setDuration(float duration)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setDuration(duration);
	}
}

void QtScriptParticleSystem::setEmissionRate(float rate)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setEmissionRate(rate);
	}
}

void QtScriptParticleSystem::setEmitterMode(int mode)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setEmitterMode(cocos2d::ParticleSystem::Mode(mode));
	}
}

void QtScriptParticleSystem::setEndColor(const cocos2d::Color4F& color)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setEndColor(color);
	}
}

void QtScriptParticleSystem::setEndColorVar(const cocos2d::Color4F& color)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setEndColorVar(color);
	}
}

void QtScriptParticleSystem::setEndRadius(float endRadius)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setEndRadius(endRadius);
	}
}

void QtScriptParticleSystem::setEndRadiusVar(float endRadiusVar)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setEndRadiusVar(endRadiusVar);
	}
}

void QtScriptParticleSystem::setEndSize(float endSize)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setEndSize(endSize);
	}
}

void QtScriptParticleSystem::setEndSizeVar(float sizeVar)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setEndSizeVar(sizeVar);
	}
}

void QtScriptParticleSystem::setEndSpin(float endSpin)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setEndSpin(endSpin);
	}
}

void QtScriptParticleSystem::setEndSpinVar(float endSpinVar)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setEndSpinVar(endSpinVar);
	}
}

void QtScriptParticleSystem::setGravity(const cocos2d::Vec2& g)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setGravity(g);
	}
}

void QtScriptParticleSystem::setLife(float life)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setLife(life);
	}
}

void QtScriptParticleSystem::setLifeVar(float lifeVar)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setLifeVar(lifeVar);
	}
}

void QtScriptParticleSystem::setPosVar(const cocos2d::Vec2& pos)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setPosVar(pos);
	}
}

void QtScriptParticleSystem::setPositionType(int type)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setPositionType(cocos2d::ParticleSystem::PositionType(type));
	}
}

void QtScriptParticleSystem::setRadialAccel(float t)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setRadialAccel(t);
	}
}

void QtScriptParticleSystem::setRadialAccelVar(float t)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setRadialAccelVar(t);
	}
}

void QtScriptParticleSystem::setRotatePerSecond(float degrees)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setRotatePerSecond(degrees);
	}
}

void QtScriptParticleSystem::setRotatePerSecondVar(float degrees)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setRotatePerSecondVar(degrees);
	}
}

void QtScriptParticleSystem::setRotationIsDir(bool t)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setRotationIsDir(t);
	}
}

void QtScriptParticleSystem::setSourcePosition(const cocos2d::Vec2& pos)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setSourcePosition(pos);
	}
}

void QtScriptParticleSystem::setSourcePositionCompatible(bool sourcePositionCompatible)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setSourcePositionCompatible(sourcePositionCompatible);
	}
}

void QtScriptParticleSystem::setSpeed(float speed)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setSpeed(speed);
	}
}

void QtScriptParticleSystem::setSpeedVar(float speed)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setSpeedVar(speed);
	}
}

void QtScriptParticleSystem::setStartColor(const cocos2d::Color4F& color)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setStartColor(color);
	}
}

void QtScriptParticleSystem::setStartColorVar(const cocos2d::Color4F& color)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setStartColorVar(color);
	}
}

void QtScriptParticleSystem::setStartRadius(float startRadius)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setStartRadius(startRadius);
	}
}

void QtScriptParticleSystem::setStartRadiusVar(float startRadiusVar)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setStartRadiusVar(startRadiusVar);
	}
}

void QtScriptParticleSystem::setStartSize(float startSize)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setStartSize(startSize);
	}
}

void QtScriptParticleSystem::setStartSizeVar(float sizeVar)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setStartSizeVar(sizeVar);
	}
}

void QtScriptParticleSystem::setStartSpin(float spin)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setStartSpin(spin);
	}
}

void QtScriptParticleSystem::setStartSpinVar(float pinVar)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setStartSpinVar(pinVar);
	}
}

void QtScriptParticleSystem::setTangentialAccel(float t)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setTangentialAccel(t);
	}
}

void QtScriptParticleSystem::setTangentialAccelVar(float t)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setTangentialAccelVar(t);
	}
}

void QtScriptParticleSystem::setTexture(cocos2d::Texture2D* texture)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setTexture(texture);
	}
}

void QtScriptParticleSystem::setTotalParticles(int totalParticles)
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->setTotalParticles(totalParticles);
	}
}

void QtScriptParticleSystem::start()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->start();
	}
}

void QtScriptParticleSystem::stop()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->stop();
	}
}

void QtScriptParticleSystem::stopSystem()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->stopSystem();
	}
}

void QtScriptParticleSystem::updateWithNoTime()
{
	auto __o = this->thiz<ParticleSystem *>();
	if (__o)
	{
		__o->updateWithNoTime();
	}
}

QScriptValue QtScriptParticleSystem::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(ParticleSystem::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleSystem::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptParticleSystem::createWithTotalParticles(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			return __e->toScriptValue(ParticleSystem::createWithTotalParticles(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleSystem::createWithTotalParticles");
	return __e->uncaughtException();
}

QScriptValue QtScriptParticleSystem::getAllParticleSystems(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ParticleSystem::getAllParticleSystems());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleSystem::getAllParticleSystems");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptParticleSystemQuad::QtScriptParticleSystemQuad(QScriptEngine *engine, const QByteArray &className)
	: QtScriptParticleSystem(engine, className)
{
}

QtScriptParticleSystemQuad::QtScriptParticleSystemQuad(QScriptEngine *engine)
	: QtScriptParticleSystemQuad(engine, "ParticleSystemQuad")
{
}

void QtScriptParticleSystemQuad::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ParticleSystem *>());
	auto ctor = RegisterT<ParticleSystemQuad, QtScriptParticleSystemQuad>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleSystemQuad::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTotalParticles", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleSystemQuad::createWithTotalParticles)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptParticleSystemQuad::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptParticleSystemQuad::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptParticleSystemQuad::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ParticleSystemQuad");
	return false;
}

void QtScriptParticleSystemQuad::setDisplayFrame(cocos2d::SpriteFrame* spriteFrame)
{
	auto __o = this->thiz<ParticleSystemQuad *>();
	if (__o)
	{
		__o->setDisplayFrame(spriteFrame);
	}
}

void QtScriptParticleSystemQuad::setTextureWithRect(cocos2d::Texture2D* texture, const cocos2d::Rect& rect)
{
	auto __o = this->thiz<ParticleSystemQuad *>();
	if (__o)
	{
		__o->setTextureWithRect(texture, rect);
	}
}

QScriptValue QtScriptParticleSystemQuad::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ParticleSystemQuad::create());
		}
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(ParticleSystemQuad::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleSystemQuad::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptParticleSystemQuad::createWithTotalParticles(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			return __e->toScriptValue(ParticleSystemQuad::createWithTotalParticles(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleSystemQuad::createWithTotalParticles");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptParticleFire::QtScriptParticleFire(QScriptEngine *engine, const QByteArray &className)
	: QtScriptParticleSystemQuad(engine, className)
{
}

QtScriptParticleFire::QtScriptParticleFire(QScriptEngine *engine)
	: QtScriptParticleFire(engine, "ParticleFire")
{
}

void QtScriptParticleFire::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ParticleSystemQuad *>());
	auto ctor = RegisterT<ParticleFire, QtScriptParticleFire>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleFire::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTotalParticles", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleFire::createWithTotalParticles)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptParticleFire::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptParticleFire::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptParticleFire::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ParticleFire");
	return false;
}

QScriptValue QtScriptParticleFire::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ParticleFire::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleFire::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptParticleFire::createWithTotalParticles(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			return __e->toScriptValue(ParticleFire::createWithTotalParticles(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleFire::createWithTotalParticles");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptParticleFireworks::QtScriptParticleFireworks(QScriptEngine *engine, const QByteArray &className)
	: QtScriptParticleSystemQuad(engine, className)
{
}

QtScriptParticleFireworks::QtScriptParticleFireworks(QScriptEngine *engine)
	: QtScriptParticleFireworks(engine, "ParticleFireworks")
{
}

void QtScriptParticleFireworks::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ParticleSystemQuad *>());
	auto ctor = RegisterT<ParticleFireworks, QtScriptParticleFireworks>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleFireworks::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTotalParticles", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleFireworks::createWithTotalParticles)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptParticleFireworks::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptParticleFireworks::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptParticleFireworks::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ParticleFireworks");
	return false;
}

QScriptValue QtScriptParticleFireworks::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ParticleFireworks::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleFireworks::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptParticleFireworks::createWithTotalParticles(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			return __e->toScriptValue(ParticleFireworks::createWithTotalParticles(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleFireworks::createWithTotalParticles");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptParticleSun::QtScriptParticleSun(QScriptEngine *engine, const QByteArray &className)
	: QtScriptParticleSystemQuad(engine, className)
{
}

QtScriptParticleSun::QtScriptParticleSun(QScriptEngine *engine)
	: QtScriptParticleSun(engine, "ParticleSun")
{
}

void QtScriptParticleSun::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ParticleSystemQuad *>());
	auto ctor = RegisterT<ParticleSun, QtScriptParticleSun>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleSun::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTotalParticles", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleSun::createWithTotalParticles)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptParticleSun::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptParticleSun::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptParticleSun::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ParticleSun");
	return false;
}

QScriptValue QtScriptParticleSun::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ParticleSun::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleSun::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptParticleSun::createWithTotalParticles(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			return __e->toScriptValue(ParticleSun::createWithTotalParticles(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleSun::createWithTotalParticles");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptParticleGalaxy::QtScriptParticleGalaxy(QScriptEngine *engine, const QByteArray &className)
	: QtScriptParticleSystemQuad(engine, className)
{
}

QtScriptParticleGalaxy::QtScriptParticleGalaxy(QScriptEngine *engine)
	: QtScriptParticleGalaxy(engine, "ParticleGalaxy")
{
}

void QtScriptParticleGalaxy::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ParticleSystemQuad *>());
	auto ctor = RegisterT<ParticleGalaxy, QtScriptParticleGalaxy>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleGalaxy::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTotalParticles", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleGalaxy::createWithTotalParticles)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptParticleGalaxy::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptParticleGalaxy::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptParticleGalaxy::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ParticleGalaxy");
	return false;
}

QScriptValue QtScriptParticleGalaxy::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ParticleGalaxy::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleGalaxy::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptParticleGalaxy::createWithTotalParticles(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			return __e->toScriptValue(ParticleGalaxy::createWithTotalParticles(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleGalaxy::createWithTotalParticles");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptParticleFlower::QtScriptParticleFlower(QScriptEngine *engine, const QByteArray &className)
	: QtScriptParticleSystemQuad(engine, className)
{
}

QtScriptParticleFlower::QtScriptParticleFlower(QScriptEngine *engine)
	: QtScriptParticleFlower(engine, "ParticleFlower")
{
}

void QtScriptParticleFlower::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ParticleSystemQuad *>());
	auto ctor = RegisterT<ParticleFlower, QtScriptParticleFlower>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleFlower::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTotalParticles", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleFlower::createWithTotalParticles)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptParticleFlower::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptParticleFlower::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptParticleFlower::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ParticleFlower");
	return false;
}

QScriptValue QtScriptParticleFlower::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ParticleFlower::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleFlower::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptParticleFlower::createWithTotalParticles(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			return __e->toScriptValue(ParticleFlower::createWithTotalParticles(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleFlower::createWithTotalParticles");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptParticleMeteor::QtScriptParticleMeteor(QScriptEngine *engine, const QByteArray &className)
	: QtScriptParticleSystemQuad(engine, className)
{
}

QtScriptParticleMeteor::QtScriptParticleMeteor(QScriptEngine *engine)
	: QtScriptParticleMeteor(engine, "ParticleMeteor")
{
}

void QtScriptParticleMeteor::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ParticleSystemQuad *>());
	auto ctor = RegisterT<ParticleMeteor, QtScriptParticleMeteor>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleMeteor::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTotalParticles", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleMeteor::createWithTotalParticles)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptParticleMeteor::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptParticleMeteor::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptParticleMeteor::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ParticleMeteor");
	return false;
}

QScriptValue QtScriptParticleMeteor::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ParticleMeteor::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleMeteor::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptParticleMeteor::createWithTotalParticles(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			return __e->toScriptValue(ParticleMeteor::createWithTotalParticles(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleMeteor::createWithTotalParticles");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptParticleSpiral::QtScriptParticleSpiral(QScriptEngine *engine, const QByteArray &className)
	: QtScriptParticleSystemQuad(engine, className)
{
}

QtScriptParticleSpiral::QtScriptParticleSpiral(QScriptEngine *engine)
	: QtScriptParticleSpiral(engine, "ParticleSpiral")
{
}

void QtScriptParticleSpiral::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ParticleSystemQuad *>());
	auto ctor = RegisterT<ParticleSpiral, QtScriptParticleSpiral>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleSpiral::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTotalParticles", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleSpiral::createWithTotalParticles)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptParticleSpiral::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptParticleSpiral::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptParticleSpiral::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ParticleSpiral");
	return false;
}

QScriptValue QtScriptParticleSpiral::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ParticleSpiral::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleSpiral::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptParticleSpiral::createWithTotalParticles(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			return __e->toScriptValue(ParticleSpiral::createWithTotalParticles(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleSpiral::createWithTotalParticles");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptParticleExplosion::QtScriptParticleExplosion(QScriptEngine *engine, const QByteArray &className)
	: QtScriptParticleSystemQuad(engine, className)
{
}

QtScriptParticleExplosion::QtScriptParticleExplosion(QScriptEngine *engine)
	: QtScriptParticleExplosion(engine, "ParticleExplosion")
{
}

void QtScriptParticleExplosion::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ParticleSystemQuad *>());
	auto ctor = RegisterT<ParticleExplosion, QtScriptParticleExplosion>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleExplosion::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTotalParticles", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleExplosion::createWithTotalParticles)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptParticleExplosion::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptParticleExplosion::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptParticleExplosion::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ParticleExplosion");
	return false;
}

QScriptValue QtScriptParticleExplosion::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ParticleExplosion::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleExplosion::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptParticleExplosion::createWithTotalParticles(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			return __e->toScriptValue(ParticleExplosion::createWithTotalParticles(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleExplosion::createWithTotalParticles");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptParticleSmoke::QtScriptParticleSmoke(QScriptEngine *engine, const QByteArray &className)
	: QtScriptParticleSystemQuad(engine, className)
{
}

QtScriptParticleSmoke::QtScriptParticleSmoke(QScriptEngine *engine)
	: QtScriptParticleSmoke(engine, "ParticleSmoke")
{
}

void QtScriptParticleSmoke::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ParticleSystemQuad *>());
	auto ctor = RegisterT<ParticleSmoke, QtScriptParticleSmoke>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleSmoke::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTotalParticles", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleSmoke::createWithTotalParticles)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptParticleSmoke::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptParticleSmoke::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptParticleSmoke::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ParticleSmoke");
	return false;
}

QScriptValue QtScriptParticleSmoke::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ParticleSmoke::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleSmoke::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptParticleSmoke::createWithTotalParticles(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			return __e->toScriptValue(ParticleSmoke::createWithTotalParticles(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleSmoke::createWithTotalParticles");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptParticleSnow::QtScriptParticleSnow(QScriptEngine *engine, const QByteArray &className)
	: QtScriptParticleSystemQuad(engine, className)
{
}

QtScriptParticleSnow::QtScriptParticleSnow(QScriptEngine *engine)
	: QtScriptParticleSnow(engine, "ParticleSnow")
{
}

void QtScriptParticleSnow::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ParticleSystemQuad *>());
	auto ctor = RegisterT<ParticleSnow, QtScriptParticleSnow>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleSnow::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTotalParticles", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleSnow::createWithTotalParticles)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptParticleSnow::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptParticleSnow::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptParticleSnow::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ParticleSnow");
	return false;
}

QScriptValue QtScriptParticleSnow::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ParticleSnow::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleSnow::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptParticleSnow::createWithTotalParticles(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			return __e->toScriptValue(ParticleSnow::createWithTotalParticles(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleSnow::createWithTotalParticles");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptParticleRain::QtScriptParticleRain(QScriptEngine *engine, const QByteArray &className)
	: QtScriptParticleSystemQuad(engine, className)
{
}

QtScriptParticleRain::QtScriptParticleRain(QScriptEngine *engine)
	: QtScriptParticleRain(engine, "ParticleRain")
{
}

void QtScriptParticleRain::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ParticleSystemQuad *>());
	auto ctor = RegisterT<ParticleRain, QtScriptParticleRain>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleRain::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTotalParticles", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParticleRain::createWithTotalParticles)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptParticleRain::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptParticleRain::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptParticleRain::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ParticleRain");
	return false;
}

QScriptValue QtScriptParticleRain::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ParticleRain::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleRain::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptParticleRain::createWithTotalParticles(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			return __e->toScriptValue(ParticleRain::createWithTotalParticles(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParticleRain::createWithTotalParticles");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptProgressTimer::QtScriptProgressTimer(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptProgressTimer::QtScriptProgressTimer(QScriptEngine *engine)
	: QtScriptProgressTimer(engine, "ProgressTimer")
{
}

void QtScriptProgressTimer::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<ProgressTimer, QtScriptProgressTimer>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptProgressTimer::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptProgressTimer::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptProgressTimer::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptProgressTimer::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ProgressTimer");
	return false;
}

cocos2d::Vec2 QtScriptProgressTimer::getBarChangeRate()
{
	auto __o = this->thiz<ProgressTimer *>();
	if (__o)
	{
		return __o->getBarChangeRate();
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptProgressTimer::getMidpoint()
{
	auto __o = this->thiz<ProgressTimer *>();
	if (__o)
	{
		return __o->getMidpoint();
	}
	return cocos2d::Vec2();
}

float QtScriptProgressTimer::getPercentage()
{
	auto __o = this->thiz<ProgressTimer *>();
	if (__o)
	{
		return __o->getPercentage();
	}
	return static_cast<float>(0);
}

cocos2d::Sprite* QtScriptProgressTimer::getSprite()
{
	auto __o = this->thiz<ProgressTimer *>();
	if (__o)
	{
		return __o->getSprite();
	}
	return nullptr;
}

int QtScriptProgressTimer::getType()
{
	auto __o = this->thiz<ProgressTimer *>();
	if (__o)
	{
		return int(__o->getType());
	}
	return 0;
}

bool QtScriptProgressTimer::initWithSprite(cocos2d::Sprite* sp)
{
	auto __o = this->thiz<ProgressTimer *>();
	if (__o)
	{
		return __o->initWithSprite(sp);
	}
	return false;
}

bool QtScriptProgressTimer::isReverseDirection()
{
	auto __o = this->thiz<ProgressTimer *>();
	if (__o)
	{
		return __o->isReverseDirection();
	}
	return false;
}

void QtScriptProgressTimer::setBarChangeRate(const cocos2d::Vec2& barChangeRate)
{
	auto __o = this->thiz<ProgressTimer *>();
	if (__o)
	{
		__o->setBarChangeRate(barChangeRate);
	}
}

void QtScriptProgressTimer::setMidpoint(const cocos2d::Vec2& point)
{
	auto __o = this->thiz<ProgressTimer *>();
	if (__o)
	{
		__o->setMidpoint(point);
	}
}

void QtScriptProgressTimer::setPercentage(float percentage)
{
	auto __o = this->thiz<ProgressTimer *>();
	if (__o)
	{
		__o->setPercentage(percentage);
	}
}

void QtScriptProgressTimer::setReverseDirection(bool value)
{
	auto __o = this->thiz<ProgressTimer *>();
	if (__o)
	{
		__o->setReverseDirection(value);
	}
}

void QtScriptProgressTimer::setSprite(cocos2d::Sprite* sprite)
{
	auto __o = this->thiz<ProgressTimer *>();
	if (__o)
	{
		__o->setSprite(sprite);
	}
}

void QtScriptProgressTimer::setType(int type)
{
	auto __o = this->thiz<ProgressTimer *>();
	if (__o)
	{
		__o->setType(cocos2d::ProgressTimer::Type(type));
	}
}

QScriptValue QtScriptProgressTimer::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Sprite*>(context->argument(0));
			return __e->toScriptValue(ProgressTimer::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ProgressTimer::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptProtectedNode::QtScriptProtectedNode(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptProtectedNode::QtScriptProtectedNode(QScriptEngine *engine)
	: QtScriptProtectedNode(engine, "ProtectedNode")
{
}

void QtScriptProtectedNode::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<ProtectedNode, QtScriptProtectedNode>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptProtectedNode::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptProtectedNode::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptProtectedNode::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptProtectedNode::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ProtectedNode");
	return false;
}

void QtScriptProtectedNode::addProtectedChild(cocos2d::Node* child)
{
	auto __o = this->thiz<ProtectedNode *>();
	if (__o)
	{
		__o->addProtectedChild(child);
	}
}

void QtScriptProtectedNode::addProtectedChild(cocos2d::Node* child, int localZOrder)
{
	auto __o = this->thiz<ProtectedNode *>();
	if (__o)
	{
		__o->addProtectedChild(child, localZOrder);
	}
}

void QtScriptProtectedNode::addProtectedChild(cocos2d::Node* child, int localZOrder, int tag)
{
	auto __o = this->thiz<ProtectedNode *>();
	if (__o)
	{
		__o->addProtectedChild(child, localZOrder, tag);
	}
}

cocos2d::Node* QtScriptProtectedNode::getProtectedChildByTag(int tag)
{
	auto __o = this->thiz<ProtectedNode *>();
	if (__o)
	{
		return __o->getProtectedChildByTag(tag);
	}
	return nullptr;
}

void QtScriptProtectedNode::removeAllProtectedChildren()
{
	auto __o = this->thiz<ProtectedNode *>();
	if (__o)
	{
		__o->removeAllProtectedChildren();
	}
}

void QtScriptProtectedNode::removeAllProtectedChildrenWithCleanup(bool cleanup)
{
	auto __o = this->thiz<ProtectedNode *>();
	if (__o)
	{
		__o->removeAllProtectedChildrenWithCleanup(cleanup);
	}
}

void QtScriptProtectedNode::removeProtectedChild(cocos2d::Node* child)
{
	auto __o = this->thiz<ProtectedNode *>();
	if (__o)
	{
		__o->removeProtectedChild(child);
	}
}

void QtScriptProtectedNode::removeProtectedChild(cocos2d::Node* child, bool cleanup)
{
	auto __o = this->thiz<ProtectedNode *>();
	if (__o)
	{
		__o->removeProtectedChild(child, cleanup);
	}
}

void QtScriptProtectedNode::removeProtectedChildByTag(int tag)
{
	auto __o = this->thiz<ProtectedNode *>();
	if (__o)
	{
		__o->removeProtectedChildByTag(tag);
	}
}

void QtScriptProtectedNode::removeProtectedChildByTag(int tag, bool cleanup)
{
	auto __o = this->thiz<ProtectedNode *>();
	if (__o)
	{
		__o->removeProtectedChildByTag(tag, cleanup);
	}
}

void QtScriptProtectedNode::reorderProtectedChild(cocos2d::Node* child, int localZOrder)
{
	auto __o = this->thiz<ProtectedNode *>();
	if (__o)
	{
		__o->reorderProtectedChild(child, localZOrder);
	}
}

void QtScriptProtectedNode::sortAllProtectedChildren()
{
	auto __o = this->thiz<ProtectedNode *>();
	if (__o)
	{
		__o->sortAllProtectedChildren();
	}
}

QScriptValue QtScriptProtectedNode::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ProtectedNode::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ProtectedNode::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptTextureAtlas::QtScriptTextureAtlas(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptTextureAtlas::QtScriptTextureAtlas(QScriptEngine *engine)
	: QtScriptTextureAtlas(engine, "TextureAtlas")
{
}

void QtScriptTextureAtlas::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<TextureAtlas, QtScriptTextureAtlas>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTextureAtlas::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTexture", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTextureAtlas::createWithTexture)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

void QtScriptTextureAtlas::fillWithEmptyQuadsFromIndex(int index, int amount)
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		__o->fillWithEmptyQuadsFromIndex(index, amount);
	}
}

unsigned QtScriptTextureAtlas::getCapacity()
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		return unsigned(__o->getCapacity());
	}
	return static_cast<unsigned>(0);
}

QByteArray QtScriptTextureAtlas::getDescription()
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getDescription());
	}
	return QByteArray();
}

cocos2d::Texture2D* QtScriptTextureAtlas::getTexture()
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		return __o->getTexture();
	}
	return nullptr;
}

unsigned QtScriptTextureAtlas::getTotalQuads()
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		return unsigned(__o->getTotalQuads());
	}
	return static_cast<unsigned>(0);
}

void QtScriptTextureAtlas::increaseTotalQuadsWith(int amount)
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		__o->increaseTotalQuadsWith(amount);
	}
}

bool QtScriptTextureAtlas::initWithFile(const QByteArray& file, int capacity)
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		return __o->initWithFile(file.toStdString(), capacity);
	}
	return false;
}

bool QtScriptTextureAtlas::initWithTexture(cocos2d::Texture2D* texture, int capacity)
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		return __o->initWithTexture(texture, capacity);
	}
	return false;
}

void QtScriptTextureAtlas::insertQuad(const cocos2d::V3F_C4B_T2F_Quad& quad, int index)
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		__o->insertQuad(quad, index);
	}
}

void QtScriptTextureAtlas::insertQuadFromIndex(int fromIndex, int newIndex)
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		__o->insertQuadFromIndex(fromIndex, newIndex);
	}
}

bool QtScriptTextureAtlas::isDirty()
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		return __o->isDirty();
	}
	return false;
}

void QtScriptTextureAtlas::moveQuadsFromIndex(int index, int newIndex)
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		__o->moveQuadsFromIndex(index, newIndex);
	}
}

void QtScriptTextureAtlas::moveQuadsFromIndex(int oldIndex, int amount, int newIndex)
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		__o->moveQuadsFromIndex(oldIndex, amount, newIndex);
	}
}

void QtScriptTextureAtlas::removeAllQuads()
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		__o->removeAllQuads();
	}
}

void QtScriptTextureAtlas::removeQuadAtIndex(int index)
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		__o->removeQuadAtIndex(index);
	}
}

void QtScriptTextureAtlas::removeQuadsAtIndex(int index, int amount)
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		__o->removeQuadsAtIndex(index, amount);
	}
}

bool QtScriptTextureAtlas::resizeCapacity(int capacity)
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		return __o->resizeCapacity(capacity);
	}
	return false;
}

void QtScriptTextureAtlas::setDirty(bool bDirty)
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		__o->setDirty(bDirty);
	}
}

void QtScriptTextureAtlas::setTexture(cocos2d::Texture2D* texture)
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		__o->setTexture(texture);
	}
}

void QtScriptTextureAtlas::updateQuad(const cocos2d::V3F_C4B_T2F_Quad& quad, int index)
{
	auto __o = this->thiz<TextureAtlas *>();
	if (__o)
	{
		__o->updateQuad(quad, index);
	}
}

QScriptValue QtScriptTextureAtlas::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<int>(context->argument(1));
			return __e->toScriptValue(TextureAtlas::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::TextureAtlas::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptTextureAtlas::createWithTexture(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<int>(context->argument(1));
			return __e->toScriptValue(TextureAtlas::createWithTexture(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::TextureAtlas::createWithTexture");
	return __e->uncaughtException();
}

int QtScriptTextureAtlas::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTextureAtlas::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTextureAtlas::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new TextureAtlas();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::TextureAtlas constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptSprite::QtScriptSprite(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptSprite::QtScriptSprite(QScriptEngine *engine)
	: QtScriptSprite(engine, "Sprite")
{
}

void QtScriptSprite::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<Sprite, QtScriptSprite>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithSpriteFrame", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite::createWithSpriteFrame)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithSpriteFrameName", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite::createWithSpriteFrameName)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTexture", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite::createWithTexture)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSprite::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSprite::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSprite::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Sprite");
	return false;
}

cocos2d::Sprite* QtScriptSprite::clone()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

void QtScriptSprite::copyPropertiesFrom(const cocos2d::Sprite* from)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->copyPropertiesFrom(from);
	}
}

unsigned int QtScriptSprite::getAtlasIndex()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->getAtlasIndex();
	}
	return static_cast<unsigned int>(0);
}

cocos2d::SpriteBatchNode* QtScriptSprite::getBatchNode()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->getBatchNode();
	}
	return nullptr;
}

cocos2d::BlendFunc QtScriptSprite::getBlendFunc()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->getBlendFunc();
	}
	return cocos2d::BlendFunc();
}

cocos2d::Rect QtScriptSprite::getCenterRect()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->getCenterRect();
	}
	return cocos2d::Rect();
}

cocos2d::Rect QtScriptSprite::getCenterRectNormalized()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->getCenterRectNormalized();
	}
	return cocos2d::Rect();
}

cocos2d::Vec2 QtScriptSprite::getOffsetPosition()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->getOffsetPosition();
	}
	return cocos2d::Vec2();
}

cocos2d::V3F_C4B_T2F_Quad QtScriptSprite::getQuad()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->getQuad();
	}
	return cocos2d::V3F_C4B_T2F_Quad();
}

QByteArray QtScriptSprite::getResourceName()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getResourceName());
	}
	return QByteArray();
}

int QtScriptSprite::getResourceType()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->getResourceType();
	}
	return 0;
}

cocos2d::SpriteFrame* QtScriptSprite::getSpriteFrame()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->getSpriteFrame();
	}
	return nullptr;
}

cocos2d::Texture2D* QtScriptSprite::getTexture()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->getTexture();
	}
	return nullptr;
}

cocos2d::TextureAtlas* QtScriptSprite::getTextureAtlas()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->getTextureAtlas();
	}
	return nullptr;
}

cocos2d::Rect QtScriptSprite::getTextureRect()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->getTextureRect();
	}
	return cocos2d::Rect();
}

bool QtScriptSprite::initWithFile(const QByteArray& filename)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->initWithFile(filename.toStdString());
	}
	return false;
}

bool QtScriptSprite::initWithFile(const QByteArray& filename, const cocos2d::Rect& rect)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->initWithFile(filename.toStdString(), rect);
	}
	return false;
}

bool QtScriptSprite::initWithPolygon(const cocos2d::PolygonInfo& info)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->initWithPolygon(info);
	}
	return false;
}

bool QtScriptSprite::initWithSpriteFrame(cocos2d::SpriteFrame* spriteFrame)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->initWithSpriteFrame(spriteFrame);
	}
	return false;
}

bool QtScriptSprite::initWithSpriteFrameName(const QByteArray& spriteFrameName)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->initWithSpriteFrameName(spriteFrameName.toStdString());
	}
	return false;
}

bool QtScriptSprite::initWithTexture(cocos2d::Texture2D* texture)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->initWithTexture(texture);
	}
	return false;
}

bool QtScriptSprite::initWithTexture(cocos2d::Texture2D* texture, const cocos2d::Rect& rect)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->initWithTexture(texture, rect);
	}
	return false;
}

bool QtScriptSprite::initWithTexture(cocos2d::Texture2D* texture, const cocos2d::Rect& rect, bool rotated)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->initWithTexture(texture, rect, rotated);
	}
	return false;
}

bool QtScriptSprite::isDirty()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->isDirty();
	}
	return false;
}

bool QtScriptSprite::isFlippedX()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->isFlippedX();
	}
	return false;
}

bool QtScriptSprite::isFlippedY()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->isFlippedY();
	}
	return false;
}

bool QtScriptSprite::isFrameDisplayed(cocos2d::SpriteFrame* frame)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->isFrameDisplayed(frame);
	}
	return false;
}

bool QtScriptSprite::isStretchEnabled()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->isStretchEnabled();
	}
	return false;
}

bool QtScriptSprite::isTextureRectRotated()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		return __o->isTextureRectRotated();
	}
	return false;
}

void QtScriptSprite::setAtlasIndex(unsigned int atlasIndex)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setAtlasIndex(atlasIndex);
	}
}

void QtScriptSprite::setBatchNode(cocos2d::SpriteBatchNode* spriteBatchNode)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setBatchNode(spriteBatchNode);
	}
}

void QtScriptSprite::setBlendFunc(const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setBlendFunc(blendFunc);
	}
}

void QtScriptSprite::setCenterRect(const cocos2d::Rect& rect)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setCenterRect(rect);
	}
}

void QtScriptSprite::setCenterRectNormalized(const cocos2d::Rect& rect)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setCenterRectNormalized(rect);
	}
}

void QtScriptSprite::setDirty(bool dirty)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setDirty(dirty);
	}
}

void QtScriptSprite::setDisplayFrameWithAnimationName(const QByteArray& animationName, unsigned int frameIndex)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setDisplayFrameWithAnimationName(animationName.toStdString(), frameIndex);
	}
}

void QtScriptSprite::setFlippedX(bool flippedX)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setFlippedX(flippedX);
	}
}

void QtScriptSprite::setFlippedY(bool flippedY)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setFlippedY(flippedY);
	}
}

void QtScriptSprite::setSpriteFrame(cocos2d::SpriteFrame* newFrame)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setSpriteFrame(newFrame);
	}
}

void QtScriptSprite::setStretchEnabled(bool enabled)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setStretchEnabled(enabled);
	}
}

void QtScriptSprite::setTexture(cocos2d::Texture2D* texture)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setTexture(texture);
	}
}

void QtScriptSprite::setTextureAtlas(cocos2d::TextureAtlas* textureAtlas)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setTextureAtlas(textureAtlas);
	}
}

void QtScriptSprite::setTextureRect(const cocos2d::Rect& rect)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setTextureRect(rect);
	}
}

void QtScriptSprite::setTextureRect(const cocos2d::Rect& rect, bool rotated, const cocos2d::Size& untrimmedSize)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setTextureRect(rect, rotated, untrimmedSize);
	}
}

void QtScriptSprite::setVertexLayout()
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setVertexLayout();
	}
}

void QtScriptSprite::setVertexRect(const cocos2d::Rect& rect)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->setVertexRect(rect);
	}
}

void QtScriptSprite::updateShaders(const QByteArray& vert, const QByteArray& frag)
{
	auto __o = this->thiz<Sprite *>();
	if (__o)
	{
		__o->updateShaders(vert.data(), frag.data());
	}
}

QScriptValue QtScriptSprite::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Sprite::create());
		}
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(Sprite::create(arg0));
		}
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<cocos2d::Rect>(context->argument(1));
			return __e->toScriptValue(Sprite::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptSprite::createWithSpriteFrame(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::SpriteFrame*>(context->argument(0));
			return __e->toScriptValue(Sprite::createWithSpriteFrame(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite::createWithSpriteFrame");
	return __e->uncaughtException();
}

QScriptValue QtScriptSprite::createWithSpriteFrameName(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(Sprite::createWithSpriteFrameName(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite::createWithSpriteFrameName");
	return __e->uncaughtException();
}

QScriptValue QtScriptSprite::createWithTexture(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(0));
			return __e->toScriptValue(Sprite::createWithTexture(arg0));
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Rect>(context->argument(1));
			return __e->toScriptValue(Sprite::createWithTexture(arg0, arg1));
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Rect>(context->argument(1));
			auto arg2 = qscriptvalue_cast<bool>(context->argument(2));
			return __e->toScriptValue(Sprite::createWithTexture(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite::createWithTexture");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptRenderTexture::QtScriptRenderTexture(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptRenderTexture::QtScriptRenderTexture(QScriptEngine *engine)
	: QtScriptRenderTexture(engine, "RenderTexture")
{
}

void QtScriptRenderTexture::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<RenderTexture, QtScriptRenderTexture>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptRenderTexture::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptRenderTexture::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptRenderTexture::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptRenderTexture::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::RenderTexture");
	return false;
}

void QtScriptRenderTexture::begin()
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->begin();
	}
}

void QtScriptRenderTexture::beginWithClear(float r, float g, float b, float a)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->beginWithClear(r, g, b, a);
	}
}

void QtScriptRenderTexture::beginWithClear(float r, float g, float b, float a, float depthValue)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->beginWithClear(r, g, b, a, depthValue);
	}
}

void QtScriptRenderTexture::beginWithClear(float r, float g, float b, float a, float depthValue, int stencilValue)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->beginWithClear(r, g, b, a, depthValue, stencilValue);
	}
}

void QtScriptRenderTexture::clear(float r, float g, float b, float a)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->clear(r, g, b, a);
	}
}

void QtScriptRenderTexture::clearDepth(float depthValue)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->clearDepth(depthValue);
	}
}

void QtScriptRenderTexture::clearStencil(int stencilValue)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->clearStencil(stencilValue);
	}
}

void QtScriptRenderTexture::end()
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->end();
	}
}

cocos2d::Color4F QtScriptRenderTexture::getClearColor()
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		return __o->getClearColor();
	}
	return cocos2d::Color4F();
}

float QtScriptRenderTexture::getClearDepth()
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		return __o->getClearDepth();
	}
	return static_cast<float>(0);
}

int QtScriptRenderTexture::getClearFlags()
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		return int(__o->getClearFlags());
	}
	return 0;
}

int QtScriptRenderTexture::getClearStencil()
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		return __o->getClearStencil();
	}
	return 0;
}

void QtScriptRenderTexture::getPixels(const QScriptValue& arg0, bool arg1)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->getPixels(QtCocosScriptUtils::getPixelsCallback(arg0), arg1);
	}
}

cocos2d::Sprite* QtScriptRenderTexture::getSprite()
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		return __o->getSprite();
	}
	return nullptr;
}

bool QtScriptRenderTexture::initWithWidthAndHeight(int w, int h, int format)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		return __o->initWithWidthAndHeight(w, h, cocos2d::backend::PixelFormat(format));
	}
	return false;
}

bool QtScriptRenderTexture::initWithWidthAndHeight(int w, int h, int format, int depthStencilFormat)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		return __o->initWithWidthAndHeight(w, h, cocos2d::backend::PixelFormat(format), cocos2d::backend::PixelFormat(depthStencilFormat));
	}
	return false;
}

bool QtScriptRenderTexture::isAutoDraw()
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		return __o->isAutoDraw();
	}
	return false;
}

void QtScriptRenderTexture::newImage(QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->newImage(!callback.isFunction() ? cocos2d::RenderTexture::ImageCallback() : [=](cocos2d::Image* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

void QtScriptRenderTexture::newImage(QScriptValue callback, bool flipImage)
{
	auto __e = this->engine();
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->newImage(!callback.isFunction() ? cocos2d::RenderTexture::ImageCallback() : [=](cocos2d::Image* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
}, flipImage);
	}
}

bool QtScriptRenderTexture::saveToFile(const QByteArray& filename)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		return __o->saveToFile(filename.toStdString());
	}
	return false;
}

bool QtScriptRenderTexture::saveToFile(const QByteArray& filename, bool isRGBA)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		return __o->saveToFile(filename.toStdString(), isRGBA);
	}
	return false;
}

bool QtScriptRenderTexture::saveToFile(const QByteArray& filename, bool isRGBA, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		return __o->saveToFile(filename.toStdString(), isRGBA, !callback.isFunction() ? std::function<void (cocos2d::RenderTexture *, const std::string&)>() : [=](cocos2d::RenderTexture* larg0, const std::string& larg1) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	arguments << __e->toScriptValue(QByteArray::fromStdString(larg1));
	callback.call(QScriptValue(), arguments);
});
	}
	return false;
}

bool QtScriptRenderTexture::saveToFileAsNonPMA(const QByteArray& filename)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		return __o->saveToFileAsNonPMA(filename.toStdString());
	}
	return false;
}

bool QtScriptRenderTexture::saveToFileAsNonPMA(const QByteArray& filename, bool isRGBA)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		return __o->saveToFileAsNonPMA(filename.toStdString(), isRGBA);
	}
	return false;
}

bool QtScriptRenderTexture::saveToFileAsNonPMA(const QByteArray& filename, bool isRGBA, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		return __o->saveToFileAsNonPMA(filename.toStdString(), isRGBA, !callback.isFunction() ? std::function<void (cocos2d::RenderTexture *, const std::string&)>() : [=](cocos2d::RenderTexture* larg0, const std::string& larg1) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	arguments << __e->toScriptValue(QByteArray::fromStdString(larg1));
	callback.call(QScriptValue(), arguments);
});
	}
	return false;
}

void QtScriptRenderTexture::setAutoDraw(bool isAutoDraw)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->setAutoDraw(isAutoDraw);
	}
}

void QtScriptRenderTexture::setClearColor(const cocos2d::Color4F& clearColor)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->setClearColor(clearColor);
	}
}

void QtScriptRenderTexture::setClearDepth(float clearDepth)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->setClearDepth(clearDepth);
	}
}

void QtScriptRenderTexture::setClearFlags(int clearFlags)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->setClearFlags(cocos2d::ClearFlag(clearFlags));
	}
}

void QtScriptRenderTexture::setClearStencil(int clearStencil)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->setClearStencil(clearStencil);
	}
}

void QtScriptRenderTexture::setKeepMatrix(bool keepMatrix)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->setKeepMatrix(keepMatrix);
	}
}

void QtScriptRenderTexture::setSprite(cocos2d::Sprite* sprite)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->setSprite(sprite);
	}
}

void QtScriptRenderTexture::setVirtualViewport(const cocos2d::Vec2& rtBegin, const cocos2d::Rect& fullRect, const cocos2d::Rect& fullViewport)
{
	auto __o = this->thiz<RenderTexture *>();
	if (__o)
	{
		__o->setVirtualViewport(rtBegin, fullRect, fullViewport);
	}
}

QScriptValue QtScriptRenderTexture::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			auto arg1 = qscriptvalue_cast<int>(context->argument(1));
			return __e->toScriptValue(RenderTexture::create(arg0, arg1));
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			auto arg1 = qscriptvalue_cast<int>(context->argument(1));
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::backend::PixelFormat(tmp_2);
			return __e->toScriptValue(RenderTexture::create(arg0, arg1, arg2));
		}
		case 4:
		{
			auto arg0 = qscriptvalue_cast<int>(context->argument(0));
			auto arg1 = qscriptvalue_cast<int>(context->argument(1));
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::backend::PixelFormat(tmp_2);
			auto tmp_3 = qscriptvalue_cast<int>(context->argument(3));
			auto arg3 = cocos2d::backend::PixelFormat(tmp_3);
			return __e->toScriptValue(RenderTexture::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::RenderTexture::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptOBB::QtScriptOBB(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<OBB, false>(engine, className)
{
}

QtScriptOBB::QtScriptOBB(QScriptEngine *engine)
	: QtScriptOBB(engine, "OBB")
{
}

void QtScriptOBB::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<OBB, QtScriptOBB>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

bool QtScriptOBB::containPoint(const cocos2d::Vec3& point)
{
	auto __o = this->thiz<OBB *>();
	if (__o)
	{
		return __o->containPoint(point);
	}
	return false;
}

bool QtScriptOBB::differs(const cocos2d::OBB& other)
{
	auto __o = this->thiz<OBB *>();
	if (__o)
	{
		return __o->operator!=(other);
	}
	return false;
}

bool QtScriptOBB::equals(const cocos2d::OBB& other)
{
	auto __o = this->thiz<OBB *>();
	if (__o)
	{
		return __o->operator==(other);
	}
	return false;
}

bool QtScriptOBB::intersects(const cocos2d::OBB& box)
{
	auto __o = this->thiz<OBB *>();
	if (__o)
	{
		return __o->intersects(box);
	}
	return false;
}

bool QtScriptOBB::isEmpty()
{
	auto __o = this->thiz<OBB *>();
	if (__o)
	{
		return __o->isEmpty();
	}
	return false;
}

void QtScriptOBB::reset()
{
	auto __o = this->thiz<OBB *>();
	if (__o)
	{
		__o->reset();
	}
}

void QtScriptOBB::set(const cocos2d::Vec3& center, const cocos2d::Vec3& _xAxis, const cocos2d::Vec3& _yAxis, const cocos2d::Vec3& _zAxis, const cocos2d::Vec3& _extents)
{
	auto __o = this->thiz<OBB *>();
	if (__o)
	{
		__o->set(center, _xAxis, _yAxis, _zAxis, _extents);
	}
}

void QtScriptOBB::setAABB(const cocos2d::AABB& aabb)
{
	auto __o = this->thiz<OBB *>();
	if (__o)
	{
		__o->setAABB(aabb);
	}
}

cocos2d::AABB QtScriptOBB::toAABB()
{
	auto __o = this->thiz<OBB *>();
	if (__o)
	{
		return __o->toAABB();
	}
	return cocos2d::AABB();
}

void QtScriptOBB::transform(const cocos2d::Mat4& mat)
{
	auto __o = this->thiz<OBB *>();
	if (__o)
	{
		__o->transform(mat);
	}
}

cocos2d::OBB QtScriptOBB::transformed(const cocos2d::Mat4& mat)
{
	auto __o = this->thiz<OBB *>();
	if (__o)
	{
		return __o->transformed(mat);
	}
	return cocos2d::OBB();
}

int QtScriptOBB::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptOBB::constructorArgumentCountMax() const
{
	return 1;
}

bool QtScriptOBB::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::OBB>(context->argument(0));
			out = OBB(arg0);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::OBB constructor");
	}
	return ok;
}

cocos2d::Vec3 QtScriptOBB::_public_field_get_center() const
{
	auto object = thiz<OBB *>();
	if (object)
	{
		return object->_center;
	}
	return cocos2d::Vec3();
}

void QtScriptOBB::_public_field_set_center(const cocos2d::Vec3& value)
{
	auto object = thiz<OBB *>();
	if (object)
	{
		object->_center = value;
	}
}

cocos2d::Vec3 QtScriptOBB::_public_field_get_extentX() const
{
	auto object = thiz<OBB *>();
	if (object)
	{
		return object->_extentX;
	}
	return cocos2d::Vec3();
}

void QtScriptOBB::_public_field_set_extentX(const cocos2d::Vec3& value)
{
	auto object = thiz<OBB *>();
	if (object)
	{
		object->_extentX = value;
	}
}

cocos2d::Vec3 QtScriptOBB::_public_field_get_extentY() const
{
	auto object = thiz<OBB *>();
	if (object)
	{
		return object->_extentY;
	}
	return cocos2d::Vec3();
}

void QtScriptOBB::_public_field_set_extentY(const cocos2d::Vec3& value)
{
	auto object = thiz<OBB *>();
	if (object)
	{
		object->_extentY = value;
	}
}

cocos2d::Vec3 QtScriptOBB::_public_field_get_extentZ() const
{
	auto object = thiz<OBB *>();
	if (object)
	{
		return object->_extentZ;
	}
	return cocos2d::Vec3();
}

void QtScriptOBB::_public_field_set_extentZ(const cocos2d::Vec3& value)
{
	auto object = thiz<OBB *>();
	if (object)
	{
		object->_extentZ = value;
	}
}

cocos2d::Vec3 QtScriptOBB::_public_field_get_extents() const
{
	auto object = thiz<OBB *>();
	if (object)
	{
		return object->_extents;
	}
	return cocos2d::Vec3();
}

void QtScriptOBB::_public_field_set_extents(const cocos2d::Vec3& value)
{
	auto object = thiz<OBB *>();
	if (object)
	{
		object->_extents = value;
	}
}

cocos2d::Vec3 QtScriptOBB::_public_field_get_xAxis() const
{
	auto object = thiz<OBB *>();
	if (object)
	{
		return object->_xAxis;
	}
	return cocos2d::Vec3();
}

void QtScriptOBB::_public_field_set_xAxis(const cocos2d::Vec3& value)
{
	auto object = thiz<OBB *>();
	if (object)
	{
		object->_xAxis = value;
	}
}

cocos2d::Vec3 QtScriptOBB::_public_field_get_yAxis() const
{
	auto object = thiz<OBB *>();
	if (object)
	{
		return object->_yAxis;
	}
	return cocos2d::Vec3();
}

void QtScriptOBB::_public_field_set_yAxis(const cocos2d::Vec3& value)
{
	auto object = thiz<OBB *>();
	if (object)
	{
		object->_yAxis = value;
	}
}

cocos2d::Vec3 QtScriptOBB::_public_field_get_zAxis() const
{
	auto object = thiz<OBB *>();
	if (object)
	{
		return object->_zAxis;
	}
	return cocos2d::Vec3();
}

void QtScriptOBB::_public_field_set_zAxis(const cocos2d::Vec3& value)
{
	auto object = thiz<OBB *>();
	if (object)
	{
		object->_zAxis = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptPlane::QtScriptPlane(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Plane, false>(engine, className)
{
}

QtScriptPlane::QtScriptPlane(QScriptEngine *engine)
	: QtScriptPlane(engine, "Plane")
{
}

void QtScriptPlane::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<Plane, QtScriptPlane>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

float QtScriptPlane::dist2Plane(const cocos2d::Vec3& p)
{
	auto __o = this->thiz<Plane *>();
	if (__o)
	{
		return __o->dist2Plane(p);
	}
	return static_cast<float>(0);
}

float QtScriptPlane::getDist()
{
	auto __o = this->thiz<Plane *>();
	if (__o)
	{
		return __o->getDist();
	}
	return static_cast<float>(0);
}

cocos2d::Vec3 QtScriptPlane::getNormal()
{
	auto __o = this->thiz<Plane *>();
	if (__o)
	{
		return __o->getNormal();
	}
	return cocos2d::Vec3();
}

int QtScriptPlane::getSide(const cocos2d::Vec3& point)
{
	auto __o = this->thiz<Plane *>();
	if (__o)
	{
		return int(__o->getSide(point));
	}
	return 0;
}

void QtScriptPlane::initPlane(const cocos2d::Vec3& normal, float dist)
{
	auto __o = this->thiz<Plane *>();
	if (__o)
	{
		__o->initPlane(normal, dist);
	}
}

void QtScriptPlane::initPlane(const cocos2d::Vec3& p1, const cocos2d::Vec3& p2, const cocos2d::Vec3& p3)
{
	auto __o = this->thiz<Plane *>();
	if (__o)
	{
		__o->initPlane(p1, p2, p3);
	}
}

void QtScriptPlane::initWithNormalAndPoint(const cocos2d::Vec3& normal, const cocos2d::Vec3& point)
{
	auto __o = this->thiz<Plane *>();
	if (__o)
	{
		__o->initPlane(normal, point);
	}
}

int QtScriptPlane::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptPlane::constructorArgumentCountMax() const
{
	return 3;
}

bool QtScriptPlane::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Plane>(context->argument(0));
			out = Plane(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			out = Plane(arg0, arg1);
			ok = true;
			break;
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(2));
			out = Plane(arg0, arg1, arg2);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Plane constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptFrustum::QtScriptFrustum(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Frustum, false>(engine, className)
{
}

QtScriptFrustum::QtScriptFrustum(QScriptEngine *engine)
	: QtScriptFrustum(engine, "Frustum")
{
}

void QtScriptFrustum::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<Frustum, QtScriptFrustum>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

bool QtScriptFrustum::initFrustum(const cocos2d::Camera* camera)
{
	auto __o = this->thiz<Frustum *>();
	if (__o)
	{
		return __o->initFrustum(camera);
	}
	return false;
}

bool QtScriptFrustum::isClipZ()
{
	auto __o = this->thiz<Frustum *>();
	if (__o)
	{
		return __o->isClipZ();
	}
	return false;
}

bool QtScriptFrustum::isOutOfFrustum(const cocos2d::AABB& aabb)
{
	auto __o = this->thiz<Frustum *>();
	if (__o)
	{
		return __o->isOutOfFrustum(aabb);
	}
	return false;
}

void QtScriptFrustum::setClipZ(bool clipZ)
{
	auto __o = this->thiz<Frustum *>();
	if (__o)
	{
		__o->setClipZ(clipZ);
	}
}

int QtScriptFrustum::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptFrustum::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptFrustum::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Frustum constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptCamera::QtScriptCamera(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptCamera::QtScriptCamera(QScriptEngine *engine)
	: QtScriptCamera(engine, "Camera")
{
}

void QtScriptCamera::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<Camera, QtScriptCamera>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCamera::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createOrthographic", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCamera::createOrthographic)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createPerspective", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCamera::createPerspective)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getDefaultCamera", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCamera::getDefaultCamera)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getDefaultViewport", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCamera::getDefaultViewport)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getVisitingCamera", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCamera::getVisitingCamera)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("setDefaultViewport", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCamera::setDefaultViewport)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptCamera::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptCamera::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptCamera::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Camera");
	return false;
}

void QtScriptCamera::apply()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		__o->apply();
	}
}

void QtScriptCamera::applyViewport()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		__o->applyViewport();
	}
}

void QtScriptCamera::clearBackground()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		__o->clearBackground();
	}
}

cocos2d::CameraBackgroundBrush* QtScriptCamera::getBackgroundBrush()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->getBackgroundBrush();
	}
	return nullptr;
}

int QtScriptCamera::getCameraFlag()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return int(__o->getCameraFlag());
	}
	return 0;
}

qint8 QtScriptCamera::getDepth()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->getDepth();
	}
	return static_cast<qint8>(0);
}

float QtScriptCamera::getDepthInView(const cocos2d::Mat4& transform)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->getDepthInView(transform);
	}
	return static_cast<float>(0);
}

float QtScriptCamera::getFarPlane()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->getFarPlane();
	}
	return static_cast<float>(0);
}

float QtScriptCamera::getNearPlane()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->getNearPlane();
	}
	return static_cast<float>(0);
}

cocos2d::Mat4 QtScriptCamera::getProjectionMatrix()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->getProjectionMatrix();
	}
	return cocos2d::Mat4();
}

int QtScriptCamera::getRenderOrder()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->getRenderOrder();
	}
	return 0;
}

int QtScriptCamera::getType()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return int(__o->getType());
	}
	return 0;
}

cocos2d::Mat4 QtScriptCamera::getViewMatrix()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->getViewMatrix();
	}
	return cocos2d::Mat4();
}

cocos2d::Mat4 QtScriptCamera::getViewProjectionMatrix()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->getViewProjectionMatrix();
	}
	return cocos2d::Mat4();
}

bool QtScriptCamera::initDefault()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->initDefault();
	}
	return false;
}

bool QtScriptCamera::initOrthographic(float zoomX, float zoomY, float nearPlane, float farPlane)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->initOrthographic(zoomX, zoomY, nearPlane, farPlane);
	}
	return false;
}

bool QtScriptCamera::initPerspective(float fieldOfView, float aspectRatio, float nearPlane, float farPlane)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->initPerspective(fieldOfView, aspectRatio, nearPlane, farPlane);
	}
	return false;
}

bool QtScriptCamera::isBrushValid()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->isBrushValid();
	}
	return false;
}

bool QtScriptCamera::isViewProjectionUpdated()
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->isViewProjectionUpdated();
	}
	return false;
}

bool QtScriptCamera::isVisibleInFrustum(const cocos2d::AABB* aabb)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->isVisibleInFrustum(aabb);
	}
	return false;
}

void QtScriptCamera::lookAt(const cocos2d::Vec3& target)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		__o->lookAt(target);
	}
}

void QtScriptCamera::lookAt(const cocos2d::Vec3& target, const cocos2d::Vec3& up)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		__o->lookAt(target, up);
	}
}

cocos2d::Vec2 QtScriptCamera::project(const cocos2d::Vec3& src)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->project(src);
	}
	return cocos2d::Vec2();
}

cocos2d::Vec2 QtScriptCamera::projectGL(const cocos2d::Vec3& src)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->projectGL(src);
	}
	return cocos2d::Vec2();
}

void QtScriptCamera::setAdditionalProjection(const cocos2d::Mat4& mat)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		__o->setAdditionalProjection(mat);
	}
}

void QtScriptCamera::setBackgroundBrush(cocos2d::CameraBackgroundBrush* clearBrush)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		__o->setBackgroundBrush(clearBrush);
	}
}

void QtScriptCamera::setCameraFlag(int flag)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		__o->setCameraFlag(cocos2d::CameraFlag(flag));
	}
}

void QtScriptCamera::setDepth(qint8 depth)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		__o->setDepth(depth);
	}
}

void QtScriptCamera::setScene(cocos2d::Scene* scene)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		__o->setScene(scene);
	}
}

cocos2d::Vec3 QtScriptCamera::unproject(const cocos2d::Vec3& src)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->unproject(src);
	}
	return cocos2d::Vec3();
}

void QtScriptCamera::unproject(const cocos2d::Size& size, const cocos2d::Vec3* src, cocos2d::Vec3* dst)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		__o->unproject(size, src, dst);
	}
}

cocos2d::Vec3 QtScriptCamera::unprojectGL(const cocos2d::Vec3& src)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		return __o->unprojectGL(src);
	}
	return cocos2d::Vec3();
}

void QtScriptCamera::unprojectGL(const cocos2d::Size& size, const cocos2d::Vec3* src, cocos2d::Vec3* dst)
{
	auto __o = this->thiz<Camera *>();
	if (__o)
	{
		__o->unprojectGL(size, src, dst);
	}
}

QScriptValue QtScriptCamera::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Camera::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Camera::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptCamera::createOrthographic(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			return __e->toScriptValue(Camera::createOrthographic(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Camera::createOrthographic");
	return __e->uncaughtException();
}

QScriptValue QtScriptCamera::createPerspective(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			return __e->toScriptValue(Camera::createPerspective(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Camera::createPerspective");
	return __e->uncaughtException();
}

QScriptValue QtScriptCamera::getDefaultCamera(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Camera::getDefaultCamera());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Camera::getDefaultCamera");
	return __e->uncaughtException();
}

QScriptValue QtScriptCamera::getDefaultViewport(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Camera::getDefaultViewport());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Camera::getDefaultViewport");
	return __e->uncaughtException();
}

QScriptValue QtScriptCamera::getVisitingCamera(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Camera::getVisitingCamera());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Camera::getVisitingCamera");
	return __e->uncaughtException();
}

QScriptValue QtScriptCamera::setDefaultViewport(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Viewport>(context->argument(0));
			Camera::setDefaultViewport(arg0);
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Camera::setDefaultViewport");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptCameraBackgroundBrush::QtScriptCameraBackgroundBrush(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptCameraBackgroundBrush::QtScriptCameraBackgroundBrush(QScriptEngine *engine)
	: QtScriptCameraBackgroundBrush(engine, "CameraBackgroundBrush")
{
}

void QtScriptCameraBackgroundBrush::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<CameraBackgroundBrush, QtScriptCameraBackgroundBrush>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("createColorBrush", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCameraBackgroundBrush::createColorBrush)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createDepthBrush", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCameraBackgroundBrush::createDepthBrush)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createNoneBrush", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCameraBackgroundBrush::createNoneBrush)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createSkyboxBrush", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCameraBackgroundBrush::createSkyboxBrush)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptCameraBackgroundBrush::getBrushType()
{
	auto __o = this->thiz<CameraBackgroundBrush *>();
	if (__o)
	{
		return int(__o->getBrushType());
	}
	return 0;
}

bool QtScriptCameraBackgroundBrush::init()
{
	auto __o = this->thiz<CameraBackgroundBrush *>();
	if (__o)
	{
		return __o->init();
	}
	return false;
}

bool QtScriptCameraBackgroundBrush::isValid()
{
	auto __o = this->thiz<CameraBackgroundBrush *>();
	if (__o)
	{
		return __o->isValid();
	}
	return false;
}

QScriptValue QtScriptCameraBackgroundBrush::createColorBrush(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Color4F>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(CameraBackgroundBrush::createColorBrush(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::CameraBackgroundBrush::createColorBrush");
	return __e->uncaughtException();
}

QScriptValue QtScriptCameraBackgroundBrush::createDepthBrush(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(CameraBackgroundBrush::createDepthBrush());
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			return __e->toScriptValue(CameraBackgroundBrush::createDepthBrush(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::CameraBackgroundBrush::createDepthBrush");
	return __e->uncaughtException();
}

QScriptValue QtScriptCameraBackgroundBrush::createNoneBrush(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(CameraBackgroundBrush::createNoneBrush());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::CameraBackgroundBrush::createNoneBrush");
	return __e->uncaughtException();
}

QScriptValue QtScriptCameraBackgroundBrush::createSkyboxBrush(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 6, 6))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 6:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto tmp_2 = qscriptvalue_cast<QByteArray>(context->argument(2));
			auto arg2 = tmp_2.toStdString();
			auto tmp_3 = qscriptvalue_cast<QByteArray>(context->argument(3));
			auto arg3 = tmp_3.toStdString();
			auto tmp_4 = qscriptvalue_cast<QByteArray>(context->argument(4));
			auto arg4 = tmp_4.toStdString();
			auto tmp_5 = qscriptvalue_cast<QByteArray>(context->argument(5));
			auto arg5 = tmp_5.toStdString();
			return __e->toScriptValue(CameraBackgroundBrush::createSkyboxBrush(arg0, arg1, arg2, arg3, arg4, arg5));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::CameraBackgroundBrush::createSkyboxBrush");
	return __e->uncaughtException();
}

int QtScriptCameraBackgroundBrush::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptCameraBackgroundBrush::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptCameraBackgroundBrush::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new CameraBackgroundBrush();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::CameraBackgroundBrush constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptCameraBackgroundDepthBrush::QtScriptCameraBackgroundDepthBrush(QScriptEngine *engine, const QByteArray &className)
	: QtScriptCameraBackgroundBrush(engine, className)
{
}

QtScriptCameraBackgroundDepthBrush::QtScriptCameraBackgroundDepthBrush(QScriptEngine *engine)
	: QtScriptCameraBackgroundDepthBrush(engine, "CameraBackgroundDepthBrush")
{
}

void QtScriptCameraBackgroundDepthBrush::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<CameraBackgroundBrush *>());
	auto ctor = RegisterT<CameraBackgroundDepthBrush, QtScriptCameraBackgroundDepthBrush>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCameraBackgroundDepthBrush::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

void QtScriptCameraBackgroundDepthBrush::setDepth(float depth)
{
	auto __o = this->thiz<CameraBackgroundDepthBrush *>();
	if (__o)
	{
		__o->setDepth(depth);
	}
}

QScriptValue QtScriptCameraBackgroundDepthBrush::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			return __e->toScriptValue(CameraBackgroundDepthBrush::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::CameraBackgroundDepthBrush::create");
	return __e->uncaughtException();
}

int QtScriptCameraBackgroundDepthBrush::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptCameraBackgroundDepthBrush::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptCameraBackgroundDepthBrush::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new CameraBackgroundDepthBrush();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::CameraBackgroundDepthBrush constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptCameraBackgroundColorBrush::QtScriptCameraBackgroundColorBrush(QScriptEngine *engine, const QByteArray &className)
	: QtScriptCameraBackgroundDepthBrush(engine, className)
{
}

QtScriptCameraBackgroundColorBrush::QtScriptCameraBackgroundColorBrush(QScriptEngine *engine)
	: QtScriptCameraBackgroundColorBrush(engine, "CameraBackgroundColorBrush")
{
}

void QtScriptCameraBackgroundColorBrush::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<CameraBackgroundDepthBrush *>());
	auto ctor = RegisterT<CameraBackgroundColorBrush, QtScriptCameraBackgroundColorBrush>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCameraBackgroundColorBrush::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

void QtScriptCameraBackgroundColorBrush::setColor(const cocos2d::Color4F& color)
{
	auto __o = this->thiz<CameraBackgroundColorBrush *>();
	if (__o)
	{
		__o->setColor(color);
	}
}

QScriptValue QtScriptCameraBackgroundColorBrush::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Color4F>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			return __e->toScriptValue(CameraBackgroundColorBrush::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::CameraBackgroundColorBrush::create");
	return __e->uncaughtException();
}

int QtScriptCameraBackgroundColorBrush::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptCameraBackgroundColorBrush::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptCameraBackgroundColorBrush::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new CameraBackgroundColorBrush();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::CameraBackgroundColorBrush constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptCameraBackgroundSkyBoxBrush::QtScriptCameraBackgroundSkyBoxBrush(QScriptEngine *engine, const QByteArray &className)
	: QtScriptCameraBackgroundBrush(engine, className)
{
}

QtScriptCameraBackgroundSkyBoxBrush::QtScriptCameraBackgroundSkyBoxBrush(QScriptEngine *engine)
	: QtScriptCameraBackgroundSkyBoxBrush(engine, "CameraBackgroundSkyBoxBrush")
{
}

void QtScriptCameraBackgroundSkyBoxBrush::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<CameraBackgroundBrush *>());
	auto ctor = RegisterT<CameraBackgroundSkyBoxBrush, QtScriptCameraBackgroundSkyBoxBrush>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptCameraBackgroundSkyBoxBrush::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

bool QtScriptCameraBackgroundSkyBoxBrush::isActived()
{
	auto __o = this->thiz<CameraBackgroundSkyBoxBrush *>();
	if (__o)
	{
		return __o->isActived();
	}
	return false;
}

void QtScriptCameraBackgroundSkyBoxBrush::setActived(bool actived)
{
	auto __o = this->thiz<CameraBackgroundSkyBoxBrush *>();
	if (__o)
	{
		__o->setActived(actived);
	}
}

void QtScriptCameraBackgroundSkyBoxBrush::setTexture(cocos2d::TextureCube* texture)
{
	auto __o = this->thiz<CameraBackgroundSkyBoxBrush *>();
	if (__o)
	{
		__o->setTexture(texture);
	}
}

void QtScriptCameraBackgroundSkyBoxBrush::setTextureValid(bool valid)
{
	auto __o = this->thiz<CameraBackgroundSkyBoxBrush *>();
	if (__o)
	{
		__o->setTextureValid(valid);
	}
}

QScriptValue QtScriptCameraBackgroundSkyBoxBrush::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 6))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(CameraBackgroundSkyBoxBrush::create());
		}
		case 1:
		{
			break;
		}
		case 2:
		{
			break;
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			break;
		}
		case 5:
		{
			break;
		}
		case 6:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto tmp_2 = qscriptvalue_cast<QByteArray>(context->argument(2));
			auto arg2 = tmp_2.toStdString();
			auto tmp_3 = qscriptvalue_cast<QByteArray>(context->argument(3));
			auto arg3 = tmp_3.toStdString();
			auto tmp_4 = qscriptvalue_cast<QByteArray>(context->argument(4));
			auto arg4 = tmp_4.toStdString();
			auto tmp_5 = qscriptvalue_cast<QByteArray>(context->argument(5));
			auto arg5 = tmp_5.toStdString();
			return __e->toScriptValue(CameraBackgroundSkyBoxBrush::create(arg0, arg1, arg2, arg3, arg4, arg5));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::CameraBackgroundSkyBoxBrush::create");
	return __e->uncaughtException();
}

int QtScriptCameraBackgroundSkyBoxBrush::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptCameraBackgroundSkyBoxBrush::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptCameraBackgroundSkyBoxBrush::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new CameraBackgroundSkyBoxBrush();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::CameraBackgroundSkyBoxBrush constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptGridBase::QtScriptGridBase(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptGridBase::QtScriptGridBase(QScriptEngine *engine)
	: QtScriptGridBase(engine, "GridBase")
{
}

void QtScriptGridBase::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<GridBase, QtScriptGridBase>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptGridBase::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptGridBase::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptGridBase::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::GridBase");
	return false;
}

cocos2d::Rect QtScriptGridBase::getGridRect()
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		return __o->getGridRect();
	}
	return cocos2d::Rect();
}

cocos2d::Size QtScriptGridBase::getGridSize()
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		return __o->getGridSize();
	}
	return cocos2d::Size();
}

int QtScriptGridBase::getReuseGrid()
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		return __o->getReuseGrid();
	}
	return 0;
}

cocos2d::Vec2 QtScriptGridBase::getStep()
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		return __o->getStep();
	}
	return cocos2d::Vec2();
}

bool QtScriptGridBase::initWithSize(const cocos2d::Size& gridSize)
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		return __o->initWithSize(gridSize);
	}
	return false;
}

bool QtScriptGridBase::initWithSize(const cocos2d::Size& gridSize, const cocos2d::Rect& rect)
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		return __o->initWithSize(gridSize, rect);
	}
	return false;
}

bool QtScriptGridBase::initWithSize(const cocos2d::Size& gridSize, cocos2d::Texture2D* texture, bool flipped)
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		return __o->initWithSize(gridSize, texture, flipped);
	}
	return false;
}

bool QtScriptGridBase::initWithSize(const cocos2d::Size& gridSize, cocos2d::Texture2D* texture, bool flipped, const cocos2d::Rect& rect)
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		return __o->initWithSize(gridSize, texture, flipped, rect);
	}
	return false;
}

bool QtScriptGridBase::isActive()
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		return __o->isActive();
	}
	return false;
}

bool QtScriptGridBase::isTextureFlipped()
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		return __o->isTextureFlipped();
	}
	return false;
}

void QtScriptGridBase::setActive(bool active)
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		__o->setActive(active);
	}
}

void QtScriptGridBase::setGridRect(const cocos2d::Rect& rect)
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		__o->setGridRect(rect);
	}
}

void QtScriptGridBase::setGridSize(const cocos2d::Size& gridSize)
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		__o->setGridSize(gridSize);
	}
}

void QtScriptGridBase::setReuseGrid(int reuseGrid)
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		__o->setReuseGrid(reuseGrid);
	}
}

void QtScriptGridBase::setStep(const cocos2d::Vec2& step)
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		__o->setStep(step);
	}
}

void QtScriptGridBase::setTextureFlipped(bool flipped)
{
	auto __o = this->thiz<GridBase *>();
	if (__o)
	{
		__o->setTextureFlipped(flipped);
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptGrid3D::QtScriptGrid3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptGridBase(engine, className)
{
}

QtScriptGrid3D::QtScriptGrid3D(QScriptEngine *engine)
	: QtScriptGrid3D(engine, "Grid3D")
{
}

void QtScriptGrid3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<GridBase *>());
	auto ctor = RegisterT<Grid3D, QtScriptGrid3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptGrid3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptGrid3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptGrid3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptGrid3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Grid3D");
	return false;
}

bool QtScriptGrid3D::getNeedDepthTestForBlit()
{
	auto __o = this->thiz<Grid3D *>();
	if (__o)
	{
		return __o->getNeedDepthTestForBlit();
	}
	return false;
}

cocos2d::Vec3 QtScriptGrid3D::getOriginalVertex(const cocos2d::Vec2& pos)
{
	auto __o = this->thiz<Grid3D *>();
	if (__o)
	{
		return __o->getOriginalVertex(pos);
	}
	return cocos2d::Vec3();
}

cocos2d::Vec3 QtScriptGrid3D::getVertex(const cocos2d::Vec2& pos)
{
	auto __o = this->thiz<Grid3D *>();
	if (__o)
	{
		return __o->getVertex(pos);
	}
	return cocos2d::Vec3();
}

void QtScriptGrid3D::setNeedDepthTestForBlit(bool neededDepthTest)
{
	auto __o = this->thiz<Grid3D *>();
	if (__o)
	{
		__o->setNeedDepthTestForBlit(neededDepthTest);
	}
}

void QtScriptGrid3D::setVertex(const cocos2d::Vec2& pos, const cocos2d::Vec3& vertex)
{
	auto __o = this->thiz<Grid3D *>();
	if (__o)
	{
		__o->setVertex(pos, vertex);
	}
}

QScriptValue QtScriptGrid3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Size>(context->argument(0));
			return __e->toScriptValue(Grid3D::create(arg0));
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Size>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Rect>(context->argument(1));
			return __e->toScriptValue(Grid3D::create(arg0, arg1));
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Size>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(1));
			auto arg2 = qscriptvalue_cast<bool>(context->argument(2));
			return __e->toScriptValue(Grid3D::create(arg0, arg1, arg2));
		}
		case 4:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Size>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(1));
			auto arg2 = qscriptvalue_cast<bool>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Rect>(context->argument(3));
			return __e->toScriptValue(Grid3D::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Grid3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptTiledGrid3D::QtScriptTiledGrid3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptGridBase(engine, className)
{
}

QtScriptTiledGrid3D::QtScriptTiledGrid3D(QScriptEngine *engine)
	: QtScriptTiledGrid3D(engine, "TiledGrid3D")
{
}

void QtScriptTiledGrid3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<GridBase *>());
	auto ctor = RegisterT<TiledGrid3D, QtScriptTiledGrid3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTiledGrid3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptTiledGrid3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTiledGrid3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTiledGrid3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::TiledGrid3D");
	return false;
}

cocos2d::Quad3 QtScriptTiledGrid3D::getOriginalTile(const cocos2d::Vec2& pos)
{
	auto __o = this->thiz<TiledGrid3D *>();
	if (__o)
	{
		return __o->getOriginalTile(pos);
	}
	return cocos2d::Quad3();
}

cocos2d::Quad3 QtScriptTiledGrid3D::getTile(const cocos2d::Vec2& pos)
{
	auto __o = this->thiz<TiledGrid3D *>();
	if (__o)
	{
		return __o->getTile(pos);
	}
	return cocos2d::Quad3();
}

void QtScriptTiledGrid3D::setTile(const cocos2d::Vec2& pos, const cocos2d::Quad3& coords)
{
	auto __o = this->thiz<TiledGrid3D *>();
	if (__o)
	{
		__o->setTile(pos, coords);
	}
}

QScriptValue QtScriptTiledGrid3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Size>(context->argument(0));
			return __e->toScriptValue(TiledGrid3D::create(arg0));
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Size>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Rect>(context->argument(1));
			return __e->toScriptValue(TiledGrid3D::create(arg0, arg1));
		}
		case 3:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Size>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(1));
			auto arg2 = qscriptvalue_cast<bool>(context->argument(2));
			return __e->toScriptValue(TiledGrid3D::create(arg0, arg1, arg2));
		}
		case 4:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Size>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(1));
			auto arg2 = qscriptvalue_cast<bool>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Rect>(context->argument(3));
			return __e->toScriptValue(TiledGrid3D::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::TiledGrid3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptBaseLight::QtScriptBaseLight(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptBaseLight::QtScriptBaseLight(QScriptEngine *engine)
	: QtScriptBaseLight(engine, "BaseLight")
{
}

void QtScriptBaseLight::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<BaseLight, QtScriptBaseLight>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptBaseLight::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptBaseLight::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptBaseLight::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::BaseLight");
	return false;
}

float QtScriptBaseLight::getIntensity()
{
	auto __o = this->thiz<BaseLight *>();
	if (__o)
	{
		return __o->getIntensity();
	}
	return static_cast<float>(0);
}

int QtScriptBaseLight::getLightFlag()
{
	auto __o = this->thiz<BaseLight *>();
	if (__o)
	{
		return int(__o->getLightFlag());
	}
	return 0;
}

int QtScriptBaseLight::getLightType()
{
	auto __o = this->thiz<BaseLight *>();
	if (__o)
	{
		return int(__o->getLightType());
	}
	return 0;
}

bool QtScriptBaseLight::isEnabled()
{
	auto __o = this->thiz<BaseLight *>();
	if (__o)
	{
		return __o->isEnabled();
	}
	return false;
}

void QtScriptBaseLight::setEnabled(bool enabled)
{
	auto __o = this->thiz<BaseLight *>();
	if (__o)
	{
		__o->setEnabled(enabled);
	}
}

void QtScriptBaseLight::setIntensity(float intensity)
{
	auto __o = this->thiz<BaseLight *>();
	if (__o)
	{
		__o->setIntensity(intensity);
	}
}

void QtScriptBaseLight::setLightFlag(int flag)
{
	auto __o = this->thiz<BaseLight *>();
	if (__o)
	{
		__o->setLightFlag(cocos2d::LightFlag(flag));
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptDirectionLight::QtScriptDirectionLight(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseLight(engine, className)
{
}

QtScriptDirectionLight::QtScriptDirectionLight(QScriptEngine *engine)
	: QtScriptDirectionLight(engine, "DirectionLight")
{
}

void QtScriptDirectionLight::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<BaseLight *>());
	auto ctor = RegisterT<DirectionLight, QtScriptDirectionLight>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptDirectionLight::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptDirectionLight::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptDirectionLight::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptDirectionLight::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::DirectionLight");
	return false;
}

cocos2d::Vec3 QtScriptDirectionLight::getDirection()
{
	auto __o = this->thiz<DirectionLight *>();
	if (__o)
	{
		return __o->getDirection();
	}
	return cocos2d::Vec3();
}

cocos2d::Vec3 QtScriptDirectionLight::getDirectionInWorld()
{
	auto __o = this->thiz<DirectionLight *>();
	if (__o)
	{
		return __o->getDirectionInWorld();
	}
	return cocos2d::Vec3();
}

void QtScriptDirectionLight::setDirection(const cocos2d::Vec3& dir)
{
	auto __o = this->thiz<DirectionLight *>();
	if (__o)
	{
		__o->setDirection(dir);
	}
}

QScriptValue QtScriptDirectionLight::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Color3B>(context->argument(1));
			return __e->toScriptValue(DirectionLight::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::DirectionLight::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptPointLight::QtScriptPointLight(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseLight(engine, className)
{
}

QtScriptPointLight::QtScriptPointLight(QScriptEngine *engine)
	: QtScriptPointLight(engine, "PointLight")
{
}

void QtScriptPointLight::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<BaseLight *>());
	auto ctor = RegisterT<PointLight, QtScriptPointLight>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptPointLight::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptPointLight::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptPointLight::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptPointLight::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::PointLight");
	return false;
}

float QtScriptPointLight::getRange()
{
	auto __o = this->thiz<PointLight *>();
	if (__o)
	{
		return __o->getRange();
	}
	return static_cast<float>(0);
}

void QtScriptPointLight::setRange(float range)
{
	auto __o = this->thiz<PointLight *>();
	if (__o)
	{
		__o->setRange(range);
	}
}

QScriptValue QtScriptPointLight::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 3, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 3:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Color3B>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			return __e->toScriptValue(PointLight::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::PointLight::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptSpotLight::QtScriptSpotLight(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseLight(engine, className)
{
}

QtScriptSpotLight::QtScriptSpotLight(QScriptEngine *engine)
	: QtScriptSpotLight(engine, "SpotLight")
{
}

void QtScriptSpotLight::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<BaseLight *>());
	auto ctor = RegisterT<SpotLight, QtScriptSpotLight>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSpotLight::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSpotLight::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSpotLight::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSpotLight::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::SpotLight");
	return false;
}

float QtScriptSpotLight::getCosInnerAngle()
{
	auto __o = this->thiz<SpotLight *>();
	if (__o)
	{
		return __o->getCosInnerAngle();
	}
	return static_cast<float>(0);
}

float QtScriptSpotLight::getCosOuterAngle()
{
	auto __o = this->thiz<SpotLight *>();
	if (__o)
	{
		return __o->getCosOuterAngle();
	}
	return static_cast<float>(0);
}

cocos2d::Vec3 QtScriptSpotLight::getDirection()
{
	auto __o = this->thiz<SpotLight *>();
	if (__o)
	{
		return __o->getDirection();
	}
	return cocos2d::Vec3();
}

cocos2d::Vec3 QtScriptSpotLight::getDirectionInWorld()
{
	auto __o = this->thiz<SpotLight *>();
	if (__o)
	{
		return __o->getDirectionInWorld();
	}
	return cocos2d::Vec3();
}

float QtScriptSpotLight::getInnerAngle()
{
	auto __o = this->thiz<SpotLight *>();
	if (__o)
	{
		return __o->getInnerAngle();
	}
	return static_cast<float>(0);
}

float QtScriptSpotLight::getOuterAngle()
{
	auto __o = this->thiz<SpotLight *>();
	if (__o)
	{
		return __o->getOuterAngle();
	}
	return static_cast<float>(0);
}

float QtScriptSpotLight::getRange()
{
	auto __o = this->thiz<SpotLight *>();
	if (__o)
	{
		return __o->getRange();
	}
	return static_cast<float>(0);
}

void QtScriptSpotLight::setDirection(const cocos2d::Vec3& dir)
{
	auto __o = this->thiz<SpotLight *>();
	if (__o)
	{
		__o->setDirection(dir);
	}
}

void QtScriptSpotLight::setInnerAngle(float angle)
{
	auto __o = this->thiz<SpotLight *>();
	if (__o)
	{
		__o->setInnerAngle(angle);
	}
}

void QtScriptSpotLight::setOuterAngle(float outerAngle)
{
	auto __o = this->thiz<SpotLight *>();
	if (__o)
	{
		__o->setOuterAngle(outerAngle);
	}
}

void QtScriptSpotLight::setRange(float range)
{
	auto __o = this->thiz<SpotLight *>();
	if (__o)
	{
		__o->setRange(range);
	}
}

QScriptValue QtScriptSpotLight::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 6, 6))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 6:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::Color3B>(context->argument(2));
			auto arg3 = qscriptvalue_cast<float>(context->argument(3));
			auto arg4 = qscriptvalue_cast<float>(context->argument(4));
			auto arg5 = qscriptvalue_cast<float>(context->argument(5));
			return __e->toScriptValue(SpotLight::create(arg0, arg1, arg2, arg3, arg4, arg5));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::SpotLight::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptAmbientLight::QtScriptAmbientLight(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseLight(engine, className)
{
}

QtScriptAmbientLight::QtScriptAmbientLight(QScriptEngine *engine)
	: QtScriptAmbientLight(engine, "AmbientLight")
{
}

void QtScriptAmbientLight::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<BaseLight *>());
	auto ctor = RegisterT<AmbientLight, QtScriptAmbientLight>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAmbientLight::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptAmbientLight::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAmbientLight::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptAmbientLight::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::AmbientLight");
	return false;
}

QScriptValue QtScriptAmbientLight::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Color3B>(context->argument(0));
			return __e->toScriptValue(AmbientLight::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::AmbientLight::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptRenderStateBlock::QtScriptRenderStateBlock(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<RenderState::StateBlock, false>(engine, className)
{
}

QtScriptRenderStateBlock::QtScriptRenderStateBlock(QScriptEngine *engine)
	: QtScriptRenderStateBlock(engine, "RenderStateBlock")
{
}

void QtScriptRenderStateBlock::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<RenderState::StateBlock, QtScriptRenderStateBlock>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

void QtScriptRenderStateBlock::bind(cocos2d::PipelineDescriptor* programState)
{
	auto __o = this->thiz<RenderState::StateBlock *>();
	if (__o)
	{
		__o->bind(programState);
	}
}

quint32 QtScriptRenderStateBlock::getHash()
{
	auto __o = this->thiz<RenderState::StateBlock *>();
	if (__o)
	{
		return __o->getHash();
	}
	return static_cast<quint32>(0);
}

bool QtScriptRenderStateBlock::isDirty()
{
	auto __o = this->thiz<RenderState::StateBlock *>();
	if (__o)
	{
		return __o->isDirty();
	}
	return false;
}

void QtScriptRenderStateBlock::setBlend(bool enabled)
{
	auto __o = this->thiz<RenderState::StateBlock *>();
	if (__o)
	{
		__o->setBlend(enabled);
	}
}

void QtScriptRenderStateBlock::setBlendDst(int blend)
{
	auto __o = this->thiz<RenderState::StateBlock *>();
	if (__o)
	{
		__o->setBlendDst(cocos2d::backend::BlendFactor(blend));
	}
}

void QtScriptRenderStateBlock::setBlendFunc(const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<RenderState::StateBlock *>();
	if (__o)
	{
		__o->setBlendFunc(blendFunc);
	}
}

void QtScriptRenderStateBlock::setBlendSrc(int blend)
{
	auto __o = this->thiz<RenderState::StateBlock *>();
	if (__o)
	{
		__o->setBlendSrc(cocos2d::backend::BlendFactor(blend));
	}
}

void QtScriptRenderStateBlock::setCullFace(bool enabled)
{
	auto __o = this->thiz<RenderState::StateBlock *>();
	if (__o)
	{
		__o->setCullFace(enabled);
	}
}

void QtScriptRenderStateBlock::setCullFaceSide(int side)
{
	auto __o = this->thiz<RenderState::StateBlock *>();
	if (__o)
	{
		__o->setCullFaceSide(cocos2d::backend::CullMode(side));
	}
}

void QtScriptRenderStateBlock::setDepthFunction(int func)
{
	auto __o = this->thiz<RenderState::StateBlock *>();
	if (__o)
	{
		__o->setDepthFunction(cocos2d::backend::CompareFunction(func));
	}
}

void QtScriptRenderStateBlock::setDepthTest(bool enabled)
{
	auto __o = this->thiz<RenderState::StateBlock *>();
	if (__o)
	{
		__o->setDepthTest(enabled);
	}
}

void QtScriptRenderStateBlock::setDepthWrite(bool enabled)
{
	auto __o = this->thiz<RenderState::StateBlock *>();
	if (__o)
	{
		__o->setDepthWrite(enabled);
	}
}

void QtScriptRenderStateBlock::setFrontFace(int winding)
{
	auto __o = this->thiz<RenderState::StateBlock *>();
	if (__o)
	{
		__o->setFrontFace(cocos2d::backend::Winding(winding));
	}
}

void QtScriptRenderStateBlock::setState(const QByteArray& name, const QByteArray& value)
{
	auto __o = this->thiz<RenderState::StateBlock *>();
	if (__o)
	{
		__o->setState(name.toStdString(), value.toStdString());
	}
}

int QtScriptRenderStateBlock::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptRenderStateBlock::constructorArgumentCountMax() const
{
	return 1;
}

bool QtScriptRenderStateBlock::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::RenderState::StateBlock>(context->argument(0));
			out = RenderState::StateBlock(arg0);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::RenderState::StateBlock constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptRenderState::QtScriptRenderState(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptRenderState::QtScriptRenderState(QScriptEngine *engine)
	: QtScriptRenderState(engine, "RenderState")
{
}

void QtScriptRenderState::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<RenderState, QtScriptRenderState>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptRenderState::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptRenderState::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptRenderState::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::RenderState");
	return false;
}

QByteArray QtScriptRenderState::getName()
{
	auto __o = this->thiz<RenderState *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getName());
	}
	return QByteArray();
}

cocos2d::RenderState::StateBlock* QtScriptRenderState::getStateBlock()
{
	auto __o = this->thiz<RenderState *>();
	if (__o)
	{
		return &__o->getStateBlock();
	}
	return nullptr;
}

} // end of cocos2d

namespace cocos2d {
QtScriptTechnique::QtScriptTechnique(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptTechnique::QtScriptTechnique(QScriptEngine *engine)
	: QtScriptTechnique(engine, "Technique")
{
}

void QtScriptTechnique::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Technique, QtScriptTechnique>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTechnique::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithProgramState", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTechnique::createWithProgramState)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptTechnique::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTechnique::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTechnique::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Technique");
	return false;
}

void QtScriptTechnique::addPass(cocos2d::Pass* pass)
{
	auto __o = this->thiz<Technique *>();
	if (__o)
	{
		__o->addPass(pass);
	}
}

cocos2d::Technique* QtScriptTechnique::clone()
{
	auto __o = this->thiz<Technique *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

QByteArray QtScriptTechnique::getName()
{
	auto __o = this->thiz<Technique *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getName());
	}
	return QByteArray();
}

cocos2d::Pass* QtScriptTechnique::getPassByIndex(int index)
{
	auto __o = this->thiz<Technique *>();
	if (__o)
	{
		return __o->getPassByIndex(index);
	}
	return nullptr;
}

int QtScriptTechnique::getPassCount()
{
	auto __o = this->thiz<Technique *>();
	if (__o)
	{
		return int(__o->getPassCount());
	}
	return 0;
}

cocos2d::Vector<cocos2d::Pass *> QtScriptTechnique::getPasses()
{
	auto __o = this->thiz<Technique *>();
	if (__o)
	{
		return __o->getPasses();
	}
	return cocos2d::Vector<cocos2d::Pass *>();
}

cocos2d::RenderState::StateBlock* QtScriptTechnique::getStateBlock()
{
	auto __o = this->thiz<Technique *>();
	if (__o)
	{
		return &__o->getStateBlock();
	}
	return nullptr;
}

void QtScriptTechnique::setMaterial(cocos2d::Material* material)
{
	auto __o = this->thiz<Technique *>();
	if (__o)
	{
		__o->setMaterial(material);
	}
}

QScriptValue QtScriptTechnique::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Material*>(context->argument(0));
			return __e->toScriptValue(Technique::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Technique::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptTechnique::createWithProgramState(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Material*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::backend::ProgramState*>(context->argument(1));
			return __e->toScriptValue(Technique::createWithProgramState(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Technique::createWithProgramState");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptMaterial::QtScriptMaterial(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptMaterial::QtScriptMaterial(QScriptEngine *engine)
	: QtScriptMaterial(engine, "Material")
{
}

void QtScriptMaterial::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Material, QtScriptMaterial>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("createWithFilename", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMaterial::createWithFilename)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithProgramState", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMaterial::createWithProgramState)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptMaterial::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMaterial::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMaterial::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Material");
	return false;
}

void QtScriptMaterial::addTechnique(cocos2d::Technique* technique)
{
	auto __o = this->thiz<Material *>();
	if (__o)
	{
		__o->addTechnique(technique);
	}
}

cocos2d::Material* QtScriptMaterial::clone()
{
	auto __o = this->thiz<Material *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

QByteArray QtScriptMaterial::getName()
{
	auto __o = this->thiz<Material *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getName());
	}
	return QByteArray();
}

cocos2d::RenderState* QtScriptMaterial::getRenderState()
{
	auto __o = this->thiz<Material *>();
	if (__o)
	{
		return __o->getRenderState();
	}
	return nullptr;
}

cocos2d::RenderState::StateBlock QtScriptMaterial::getStateBlock()
{
	auto __o = this->thiz<Material *>();
	if (__o)
	{
		return __o->getStateBlock();
	}
	return cocos2d::RenderState::StateBlock();
}

cocos2d::Technique* QtScriptMaterial::getTechnique()
{
	auto __o = this->thiz<Material *>();
	if (__o)
	{
		return __o->getTechnique();
	}
	return nullptr;
}

cocos2d::Technique* QtScriptMaterial::getTechniqueByIndex(int index)
{
	auto __o = this->thiz<Material *>();
	if (__o)
	{
		return __o->getTechniqueByIndex(index);
	}
	return nullptr;
}

cocos2d::Technique* QtScriptMaterial::getTechniqueByName(const QByteArray& name)
{
	auto __o = this->thiz<Material *>();
	if (__o)
	{
		return __o->getTechniqueByName(name.toStdString());
	}
	return nullptr;
}

int QtScriptMaterial::getTechniqueCount()
{
	auto __o = this->thiz<Material *>();
	if (__o)
	{
		return int(__o->getTechniqueCount());
	}
	return 0;
}

void QtScriptMaterial::setName(const QByteArray& name)
{
	auto __o = this->thiz<Material *>();
	if (__o)
	{
		__o->setName(name.toStdString());
	}
}

void QtScriptMaterial::setStateBlock(const cocos2d::RenderState::StateBlock& state)
{
	auto __o = this->thiz<Material *>();
	if (__o)
	{
		__o->setStateBlock(state);
	}
}

void QtScriptMaterial::setTechnique(const QByteArray& techniqueName)
{
	auto __o = this->thiz<Material *>();
	if (__o)
	{
		__o->setTechnique(techniqueName.toStdString());
	}
}

QScriptValue QtScriptMaterial::createWithFilename(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(Material::createWithFilename(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Material::createWithFilename");
	return __e->uncaughtException();
}

QScriptValue QtScriptMaterial::createWithProgramState(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::backend::ProgramState*>(context->argument(0));
			return __e->toScriptValue(Material::createWithProgramState(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Material::createWithProgramState");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptPass::QtScriptPass(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptPass::QtScriptPass(QScriptEngine *engine)
	: QtScriptPass(engine, "Pass")
{
}

void QtScriptPass::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Pass, QtScriptPass>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptPass::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithProgramState", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptPass::createWithProgramState)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptPass::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptPass::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptPass::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Pass");
	return false;
}

cocos2d::Pass* QtScriptPass::clone()
{
	auto __o = this->thiz<Pass *>();
	if (__o)
	{
		return __o->clone();
	}
	return nullptr;
}

QByteArray QtScriptPass::getName()
{
	auto __o = this->thiz<Pass *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getName());
	}
	return QByteArray();
}

cocos2d::backend::ProgramState* QtScriptPass::getProgramState()
{
	auto __o = this->thiz<Pass *>();
	if (__o)
	{
		return __o->getProgramState();
	}
	return nullptr;
}

cocos2d::RenderState::StateBlock QtScriptPass::getStateBlock()
{
	auto __o = this->thiz<Pass *>();
	if (__o)
	{
		return __o->getStateBlock();
	}
	return cocos2d::RenderState::StateBlock();
}

cocos2d::VertexAttribBinding* QtScriptPass::getVertexAttributeBinding()
{
	auto __o = this->thiz<Pass *>();
	if (__o)
	{
		return __o->getVertexAttributeBinding();
	}
	return nullptr;
}

void QtScriptPass::setName(const QByteArray& name)
{
	auto __o = this->thiz<Pass *>();
	if (__o)
	{
		__o->setName(name.toStdString());
	}
}

void QtScriptPass::setTechnique(cocos2d::Technique* technique)
{
	auto __o = this->thiz<Pass *>();
	if (__o)
	{
		__o->setTechnique(technique);
	}
}

void QtScriptPass::setVertexAttribBinding(cocos2d::VertexAttribBinding* binding)
{
	auto __o = this->thiz<Pass *>();
	if (__o)
	{
		__o->setVertexAttribBinding(binding);
	}
}

QScriptValue QtScriptPass::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Technique*>(context->argument(0));
			return __e->toScriptValue(Pass::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Pass::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptPass::createWithProgramState(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Technique*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::backend::ProgramState*>(context->argument(1));
			return __e->toScriptValue(Pass::createWithProgramState(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Pass::createWithProgramState");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptRenderer::QtScriptRenderer(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Renderer, false>(engine, className)
{
}

QtScriptRenderer::QtScriptRenderer(QScriptEngine *engine)
	: QtScriptRenderer(engine, "Renderer")
{
}

void QtScriptRenderer::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<Renderer, QtScriptRenderer>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

void QtScriptRenderer::addCommand(cocos2d::RenderCommand* command)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->addCommand(command);
	}
}

void QtScriptRenderer::addCommand(cocos2d::RenderCommand* command, int renderQueueID)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->addCommand(command, renderQueueID);
	}
}

void QtScriptRenderer::addDrawnBatches(int number)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->addDrawnBatches(number);
	}
}

void QtScriptRenderer::addDrawnVertices(int number)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->addDrawnVertices(number);
	}
}

bool QtScriptRenderer::checkVisibility(const cocos2d::Mat4& transform, const cocos2d::Size& size)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->checkVisibility(transform, size);
	}
	return false;
}

void QtScriptRenderer::clean()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->clean();
	}
}

void QtScriptRenderer::clear(int flags, const cocos2d::Color4F& color, float depth, unsigned int stencil, float globalOrder)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->clear(cocos2d::ClearFlag(flags), color, depth, stencil, globalOrder);
	}
}

void QtScriptRenderer::clearDrawStats()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->clearDrawStats();
	}
}

int QtScriptRenderer::createRenderQueue()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->createRenderQueue();
	}
	return 0;
}

cocos2d::Color4F QtScriptRenderer::getClearColor()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->getClearColor();
	}
	return cocos2d::Color4F();
}

float QtScriptRenderer::getClearDepth()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->getClearDepth();
	}
	return static_cast<float>(0);
}

int QtScriptRenderer::getClearFlag()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return int(__o->getClearFlag());
	}
	return 0;
}

unsigned int QtScriptRenderer::getClearStencil()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->getClearStencil();
	}
	return static_cast<unsigned int>(0);
}

cocos2d::Texture2D* QtScriptRenderer::getColorAttachment()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->getColorAttachment();
	}
	return nullptr;
}

int QtScriptRenderer::getCullMode()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return int(__o->getCullMode());
	}
	return 0;
}

cocos2d::Texture2D* QtScriptRenderer::getDepthAttachment()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->getDepthAttachment();
	}
	return nullptr;
}

int QtScriptRenderer::getDepthCompareFunction()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return int(__o->getDepthCompareFunction());
	}
	return 0;
}

bool QtScriptRenderer::getDepthTest()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->getDepthTest();
	}
	return false;
}

bool QtScriptRenderer::getDepthWrite()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->getDepthWrite();
	}
	return false;
}

int QtScriptRenderer::getDrawnBatches()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return int(__o->getDrawnBatches());
	}
	return 0;
}

int QtScriptRenderer::getDrawnVertices()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return int(__o->getDrawnVertices());
	}
	return 0;
}

int QtScriptRenderer::getRenderTargetFlag()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return int(__o->getRenderTargetFlag());
	}
	return 0;
}

cocos2d::ScissorRect QtScriptRenderer::getScissorRect()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->getScissorRect();
	}
	return cocos2d::ScissorRect();
}

bool QtScriptRenderer::getScissorTest()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->getScissorTest();
	}
	return false;
}

cocos2d::Texture2D* QtScriptRenderer::getStencilAttachment()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->getStencilAttachment();
	}
	return nullptr;
}

int QtScriptRenderer::getStencilCompareFunction()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return int(__o->getStencilCompareFunction());
	}
	return 0;
}

int QtScriptRenderer::getStencilDepthPassOperation()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return int(__o->getStencilDepthPassOperation());
	}
	return 0;
}

int QtScriptRenderer::getStencilFailureOperation()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return int(__o->getStencilFailureOperation());
	}
	return 0;
}

int QtScriptRenderer::getStencilPassDepthFailureOperation()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return int(__o->getStencilPassDepthFailureOperation());
	}
	return 0;
}

unsigned int QtScriptRenderer::getStencilReadMask()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->getStencilReadMask();
	}
	return static_cast<unsigned int>(0);
}

unsigned int QtScriptRenderer::getStencilReferenceValue()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->getStencilReferenceValue();
	}
	return static_cast<unsigned int>(0);
}

bool QtScriptRenderer::getStencilTest()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->getStencilTest();
	}
	return false;
}

unsigned int QtScriptRenderer::getStencilWriteMask()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->getStencilWriteMask();
	}
	return static_cast<unsigned int>(0);
}

cocos2d::Viewport QtScriptRenderer::getViewport()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return __o->getViewport();
	}
	return cocos2d::Viewport();
}

int QtScriptRenderer::getWinding()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		return int(__o->getWinding());
	}
	return 0;
}

void QtScriptRenderer::init()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->init();
	}
}

void QtScriptRenderer::popGroup()
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->popGroup();
	}
}

void QtScriptRenderer::pushGroup(int renderQueueID)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->pushGroup(renderQueueID);
	}
}

void QtScriptRenderer::setCullMode(int mode)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->setCullMode(cocos2d::backend::CullMode(mode));
	}
}

void QtScriptRenderer::setDepthCompareFunction(int func)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->setDepthCompareFunction(cocos2d::backend::CompareFunction(func));
	}
}

void QtScriptRenderer::setDepthTest(bool value)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->setDepthTest(value);
	}
}

void QtScriptRenderer::setDepthWrite(bool value)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->setDepthWrite(value);
	}
}

void QtScriptRenderer::setRenderTarget(int flags, cocos2d::Texture2D* colorAttachment, cocos2d::Texture2D* depthAttachment, cocos2d::Texture2D* stencilAttachment)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->setRenderTarget(cocos2d::RenderTargetFlag(flags), colorAttachment, depthAttachment, stencilAttachment);
	}
}

void QtScriptRenderer::setScissorRect(float x, float y, float width, float height)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->setScissorRect(x, y, width, height);
	}
}

void QtScriptRenderer::setScissorTest(bool enabled)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->setScissorTest(enabled);
	}
}

void QtScriptRenderer::setStencilCompareFunction(int func, unsigned int ref, unsigned int readMask)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->setStencilCompareFunction(cocos2d::backend::CompareFunction(func), ref, readMask);
	}
}

void QtScriptRenderer::setStencilOperation(int stencilFailureOp, int depthFailureOp, int stencilDepthPassOp)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->setStencilOperation(cocos2d::backend::StencilOperation(stencilFailureOp), cocos2d::backend::StencilOperation(depthFailureOp), cocos2d::backend::StencilOperation(stencilDepthPassOp));
	}
}

void QtScriptRenderer::setStencilTest(bool value)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->setStencilTest(value);
	}
}

void QtScriptRenderer::setStencilWriteMask(unsigned int mask)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->setStencilWriteMask(mask);
	}
}

void QtScriptRenderer::setViewPort(int x, int y, unsigned int w, unsigned int h)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->setViewPort(x, y, w, h);
	}
}

void QtScriptRenderer::setWinding(int winding)
{
	auto __o = this->thiz<Renderer *>();
	if (__o)
	{
		__o->setWinding(cocos2d::backend::Winding(winding));
	}
}

int QtScriptRenderer::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptRenderer::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptRenderer::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Renderer constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptTextureCube::QtScriptTextureCube(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptTextureCube::QtScriptTextureCube(QScriptEngine *engine)
	: QtScriptTextureCube(engine, "TextureCube")
{
}

void QtScriptTextureCube::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<TextureCube, QtScriptTextureCube>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTextureCube::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

cocos2d::backend::TextureBackend* QtScriptTextureCube::getBackendTexture()
{
	auto __o = this->thiz<TextureCube *>();
	if (__o)
	{
		return __o->getBackendTexture();
	}
	return nullptr;
}

bool QtScriptTextureCube::reloadTexture()
{
	auto __o = this->thiz<TextureCube *>();
	if (__o)
	{
		return __o->reloadTexture();
	}
	return false;
}

void QtScriptTextureCube::setTexParameters(const cocos2d::backend::SamplerDescriptor& arg0)
{
	auto __o = this->thiz<TextureCube *>();
	if (__o)
	{
		__o->setTexParameters(arg0);
	}
}

QScriptValue QtScriptTextureCube::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 6, 6))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 6:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto tmp_2 = qscriptvalue_cast<QByteArray>(context->argument(2));
			auto arg2 = tmp_2.toStdString();
			auto tmp_3 = qscriptvalue_cast<QByteArray>(context->argument(3));
			auto arg3 = tmp_3.toStdString();
			auto tmp_4 = qscriptvalue_cast<QByteArray>(context->argument(4));
			auto arg4 = tmp_4.toStdString();
			auto tmp_5 = qscriptvalue_cast<QByteArray>(context->argument(5));
			auto arg5 = tmp_5.toStdString();
			return __e->toScriptValue(TextureCube::create(arg0, arg1, arg2, arg3, arg4, arg5));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::TextureCube::create");
	return __e->uncaughtException();
}

int QtScriptTextureCube::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTextureCube::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTextureCube::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new TextureCube();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::TextureCube constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptTextureCache::QtScriptTextureCache(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptTextureCache::QtScriptTextureCache(QScriptEngine *engine)
	: QtScriptTextureCache(engine, "TextureCache")
{
}

void QtScriptTextureCache::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<TextureCache, QtScriptTextureCache>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("getETC1AlphaFileSuffix", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTextureCache::getETC1AlphaFileSuffix)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("setETC1AlphaFileSuffix", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTextureCache::setETC1AlphaFileSuffix)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

cocos2d::Texture2D* QtScriptTextureCache::addImage(const QByteArray& filepath)
{
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		return __o->addImage(filepath.toStdString());
	}
	return nullptr;
}

cocos2d::Texture2D* QtScriptTextureCache::addImage(cocos2d::Image* image, const QByteArray& key)
{
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		return __o->addImage(image, key.toStdString());
	}
	return nullptr;
}

void QtScriptTextureCache::addImageAsync(const QByteArray& filepath, QScriptValue callback)
{
	auto __e = this->engine();
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		__o->addImageAsync(filepath.toStdString(), !callback.isFunction() ? std::function<void (cocos2d::Texture2D *)>() : [=](cocos2d::Texture2D* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
});
	}
}

void QtScriptTextureCache::addImageAsync(const QByteArray& path, QScriptValue callback, const QByteArray& callbackKey)
{
	auto __e = this->engine();
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		__o->addImageAsync(path.toStdString(), !callback.isFunction() ? std::function<void (cocos2d::Texture2D *)>() : [=](cocos2d::Texture2D* larg0) mutable -> void
{
	QScriptValueList arguments;
	arguments << __e->toScriptValue(larg0);
	callback.call(QScriptValue(), arguments);
}, callbackKey.toStdString());
	}
}

cocos2d::Texture2D* QtScriptTextureCache::getCachedTexture(const QByteArray& filepath)
{
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		return __o->getCachedTexture(filepath.toStdString());
	}
	return nullptr;
}

QByteArray QtScriptTextureCache::getCachedTextureInfo()
{
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getCachedTextureInfo());
	}
	return QByteArray();
}

QByteArray QtScriptTextureCache::getDescription()
{
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getDescription());
	}
	return QByteArray();
}

QByteArray QtScriptTextureCache::getTextureFilePath(cocos2d::Texture2D* texture)
{
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getTextureFilePath(texture));
	}
	return QByteArray();
}

cocos2d::Texture2D* QtScriptTextureCache::getTextureForKey(const QByteArray& key)
{
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		return __o->getTextureForKey(key.toStdString());
	}
	return nullptr;
}

bool QtScriptTextureCache::reloadTexture(const QByteArray& fileName)
{
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		return __o->reloadTexture(fileName.toStdString());
	}
	return false;
}

void QtScriptTextureCache::removeAllTextures()
{
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		__o->removeAllTextures();
	}
}

void QtScriptTextureCache::removeTexture(cocos2d::Texture2D* texture)
{
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		__o->removeTexture(texture);
	}
}

void QtScriptTextureCache::removeTextureForKey(const QByteArray& key)
{
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		__o->removeTextureForKey(key.toStdString());
	}
}

void QtScriptTextureCache::removeUnusedTextures()
{
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		__o->removeUnusedTextures();
	}
}

void QtScriptTextureCache::renameTextureWithKey(const QByteArray& srcName, const QByteArray& dstName)
{
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		__o->renameTextureWithKey(srcName.toStdString(), dstName.toStdString());
	}
}

void QtScriptTextureCache::unbindAllImageAsync()
{
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		__o->unbindAllImageAsync();
	}
}

void QtScriptTextureCache::unbindImageAsync(const QByteArray& filename)
{
	auto __o = this->thiz<TextureCache *>();
	if (__o)
	{
		__o->unbindImageAsync(filename.toStdString());
	}
}

QScriptValue QtScriptTextureCache::getETC1AlphaFileSuffix(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(QByteArray::fromStdString(TextureCache::getETC1AlphaFileSuffix()));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::TextureCache::getETC1AlphaFileSuffix");
	return __e->uncaughtException();
}

QScriptValue QtScriptTextureCache::setETC1AlphaFileSuffix(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			TextureCache::setETC1AlphaFileSuffix(arg0);
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::TextureCache::setETC1AlphaFileSuffix");
	return __e->uncaughtException();
}

int QtScriptTextureCache::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTextureCache::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTextureCache::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new TextureCache();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::TextureCache constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptTextPixelsInfo::QtScriptTextPixelsInfo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<TextPixelsInfo, false>(engine, className)
{
}

QtScriptTextPixelsInfo::QtScriptTextPixelsInfo(QScriptEngine *engine)
	: QtScriptTextPixelsInfo(engine, "TextPixelsInfo")
{
}

void QtScriptTextPixelsInfo::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<TextPixelsInfo, QtScriptTextPixelsInfo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptTextPixelsInfo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTextPixelsInfo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTextPixelsInfo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		Q_UNUSED(out);
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::TextPixelsInfo constructor");
	return false;
}

int QtScriptTextPixelsInfo::_public_field_get_height() const
{
	auto object = thiz<TextPixelsInfo *>();
	if (object)
	{
		return object->height;
	}
	return static_cast<int>(0);
}

void QtScriptTextPixelsInfo::_public_field_set_height(int value)
{
	auto object = thiz<TextPixelsInfo *>();
	if (object)
	{
		object->height = value;
	}
}

cocos2d::Data QtScriptTextPixelsInfo::_public_field_get_pixels() const
{
	auto object = thiz<TextPixelsInfo *>();
	if (object)
	{
		return object->pixels;
	}
	return cocos2d::Data();
}

void QtScriptTextPixelsInfo::_public_field_set_pixels(const cocos2d::Data& value)
{
	auto object = thiz<TextPixelsInfo *>();
	if (object)
	{
		object->pixels = value;
	}
}

bool QtScriptTextPixelsInfo::_public_field_get_premultiplied() const
{
	auto object = thiz<TextPixelsInfo *>();
	if (object)
	{
		return object->premultiplied;
	}
	return false;
}

void QtScriptTextPixelsInfo::_public_field_set_premultiplied(const bool& value)
{
	auto object = thiz<TextPixelsInfo *>();
	if (object)
	{
		object->premultiplied = value;
	}
}

int QtScriptTextPixelsInfo::_public_field_get_width() const
{
	auto object = thiz<TextPixelsInfo *>();
	if (object)
	{
		return object->width;
	}
	return static_cast<int>(0);
}

void QtScriptTextPixelsInfo::_public_field_set_width(int value)
{
	auto object = thiz<TextPixelsInfo *>();
	if (object)
	{
		object->width = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptDeviceUtils::QtScriptDeviceUtils(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Device *, false>(engine, className)
{
}

QtScriptDeviceUtils::QtScriptDeviceUtils(QScriptEngine *engine)
	: QtScriptDeviceUtils(engine, "DeviceUtils")
{
}

void QtScriptDeviceUtils::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	QScriptValue inherit;
	auto ctor = RegisterT<Device, QtScriptDeviceUtils>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("getDPI", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptDeviceUtils::getDPI)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getTextureDataForText", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptDeviceUtils::getTextureDataForText)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("setKeepScreenOn", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptDeviceUtils::setKeepScreenOn)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("vibrate", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptDeviceUtils::vibrate)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptDeviceUtils::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptDeviceUtils::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptDeviceUtils::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Device");
	return false;
}

QScriptValue QtScriptDeviceUtils::getDPI(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Device::getDPI());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Device::getDPI");
	return __e->uncaughtException();
}

QScriptValue QtScriptDeviceUtils::getTextureDataForText(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 5, 5))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 5:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.data();
			auto arg1 = qscriptvalue_cast<cocos2d::FontDefinition>(context->argument(1));
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::Device::TextAlign(tmp_2);
			auto arg3 = qscriptvalue_cast<int>(context->argument(3));
			auto arg4 = qscriptvalue_cast<int>(context->argument(4));
			return __e->toScriptValue(Device::getTextureDataForText(arg0, arg1, arg2, arg3, arg4));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Device::getTextureDataForText");
	return __e->uncaughtException();
}

QScriptValue QtScriptDeviceUtils::setKeepScreenOn(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<bool>(context->argument(0));
			Device::setKeepScreenOn(arg0);
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Device::setKeepScreenOn");
	return __e->uncaughtException();
}

QScriptValue QtScriptDeviceUtils::vibrate(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			Device::vibrate(arg0);
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Device::vibrate");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptApplicationProtocol::QtScriptApplicationProtocol(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<ApplicationProtocol *, true>(engine, className)
{
}

QtScriptApplicationProtocol::QtScriptApplicationProtocol(QScriptEngine *engine)
	: QtScriptApplicationProtocol(engine, "ApplicationProtocol")
{
}

void QtScriptApplicationProtocol::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<ApplicationProtocol, QtScriptApplicationProtocol>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptApplicationProtocol::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptApplicationProtocol::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptApplicationProtocol::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ApplicationProtocol");
	return false;
}

int QtScriptApplicationProtocol::getCurrentLanguage()
{
	auto __o = this->thiz<ApplicationProtocol *>();
	if (__o)
	{
		return int(__o->getCurrentLanguage());
	}
	return 0;
}

QByteArray QtScriptApplicationProtocol::getCurrentLanguageCode()
{
	auto __o = this->thiz<ApplicationProtocol *>();
	if (__o)
	{
		return QByteArray(__o->getCurrentLanguageCode());
	}
	return QByteArray();
}

int QtScriptApplicationProtocol::getTargetPlatform()
{
	auto __o = this->thiz<ApplicationProtocol *>();
	if (__o)
	{
		return int(__o->getTargetPlatform());
	}
	return 0;
}

QByteArray QtScriptApplicationProtocol::getVersion()
{
	auto __o = this->thiz<ApplicationProtocol *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getVersion());
	}
	return QByteArray();
}

bool QtScriptApplicationProtocol::openURL(const QByteArray& url)
{
	auto __o = this->thiz<ApplicationProtocol *>();
	if (__o)
	{
		return __o->openURL(url.toStdString());
	}
	return false;
}

} // end of cocos2d

namespace cocos2d {
QtScriptApplication::QtScriptApplication(QScriptEngine *engine, const QByteArray &className)
	: QtScriptApplicationProtocol(engine, className)
{
}

QtScriptApplication::QtScriptApplication(QScriptEngine *engine)
	: QtScriptApplication(engine, "Application")
{
}

void QtScriptApplication::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<ApplicationProtocol *>());
	auto ctor = RegisterT<Application, QtScriptApplication>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("getInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptApplication::getInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptApplication::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptApplication::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptApplication::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Application");
	return false;
}

QScriptValue QtScriptApplication::getInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Application::getInstance());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Application::getInstance");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptAnimationCache::QtScriptAnimationCache(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptAnimationCache::QtScriptAnimationCache(QScriptEngine *engine)
	: QtScriptAnimationCache(engine, "AnimationCache")
{
}

void QtScriptAnimationCache::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<AnimationCache, QtScriptAnimationCache>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("destroyInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAnimationCache::destroyInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAnimationCache::getInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

void QtScriptAnimationCache::addAnimation(cocos2d::Animation* animation, const QByteArray& name)
{
	auto __o = this->thiz<AnimationCache *>();
	if (__o)
	{
		__o->addAnimation(animation, name.toStdString());
	}
}

void QtScriptAnimationCache::addAnimationsWithData(const QByteArray& arg0)
{
	auto __o = this->thiz<AnimationCache *>();
	if (__o)
	{
		__o->addAnimationsWithData(arg0.data(), arg0.size());
	}
}

void QtScriptAnimationCache::addAnimationsWithFile(const QByteArray& plist)
{
	auto __o = this->thiz<AnimationCache *>();
	if (__o)
	{
		__o->addAnimationsWithFile(plist.toStdString());
	}
}

cocos2d::Animation* QtScriptAnimationCache::getAnimation(const QByteArray& name)
{
	auto __o = this->thiz<AnimationCache *>();
	if (__o)
	{
		return __o->getAnimation(name.toStdString());
	}
	return nullptr;
}

bool QtScriptAnimationCache::init()
{
	auto __o = this->thiz<AnimationCache *>();
	if (__o)
	{
		return __o->init();
	}
	return false;
}

void QtScriptAnimationCache::removeAnimation(const QByteArray& name)
{
	auto __o = this->thiz<AnimationCache *>();
	if (__o)
	{
		__o->removeAnimation(name.toStdString());
	}
}

QScriptValue QtScriptAnimationCache::destroyInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			AnimationCache::destroyInstance();
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::AnimationCache::destroyInstance");
	return __e->uncaughtException();
}

QScriptValue QtScriptAnimationCache::getInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(AnimationCache::getInstance());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::AnimationCache::getInstance");
	return __e->uncaughtException();
}

int QtScriptAnimationCache::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAnimationCache::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptAnimationCache::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new AnimationCache();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::AnimationCache constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptSpriteBatchNode::QtScriptSpriteBatchNode(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptSpriteBatchNode::QtScriptSpriteBatchNode(QScriptEngine *engine)
	: QtScriptSpriteBatchNode(engine, "SpriteBatchNode")
{
}

void QtScriptSpriteBatchNode::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<SpriteBatchNode, QtScriptSpriteBatchNode>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSpriteBatchNode::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTexture", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSpriteBatchNode::createWithTexture)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSpriteBatchNode::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSpriteBatchNode::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSpriteBatchNode::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::SpriteBatchNode");
	return false;
}

cocos2d::SpriteBatchNode* QtScriptSpriteBatchNode::addSpriteWithoutQuad(cocos2d::Sprite* child, int z, int aTag)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		return __o->addSpriteWithoutQuad(child, z, aTag);
	}
	return nullptr;
}

void QtScriptSpriteBatchNode::appendChild(cocos2d::Sprite* sprite)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		__o->appendChild(sprite);
	}
}

int QtScriptSpriteBatchNode::atlasIndexForChild(cocos2d::Sprite* sprite, int z)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		return int(__o->atlasIndexForChild(sprite, z));
	}
	return 0;
}

cocos2d::BlendFunc QtScriptSpriteBatchNode::getBlendFunc()
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		return __o->getBlendFunc();
	}
	return cocos2d::BlendFunc();
}

cocos2d::Texture2D* QtScriptSpriteBatchNode::getTexture()
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		return __o->getTexture();
	}
	return nullptr;
}

cocos2d::TextureAtlas* QtScriptSpriteBatchNode::getTextureAtlas()
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		return __o->getTextureAtlas();
	}
	return nullptr;
}

int QtScriptSpriteBatchNode::highestAtlasIndexInChild(cocos2d::Sprite* sprite)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		return int(__o->highestAtlasIndexInChild(sprite));
	}
	return 0;
}

void QtScriptSpriteBatchNode::increaseAtlasCapacity()
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		__o->increaseAtlasCapacity();
	}
}

bool QtScriptSpriteBatchNode::initWithFile(const QByteArray& fileImage)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		return __o->initWithFile(fileImage.toStdString());
	}
	return false;
}

bool QtScriptSpriteBatchNode::initWithFile(const QByteArray& fileImage, int capacity)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		return __o->initWithFile(fileImage.toStdString(), capacity);
	}
	return false;
}

bool QtScriptSpriteBatchNode::initWithTexture(cocos2d::Texture2D* tex)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		return __o->initWithTexture(tex);
	}
	return false;
}

bool QtScriptSpriteBatchNode::initWithTexture(cocos2d::Texture2D* tex, int capacity)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		return __o->initWithTexture(tex, capacity);
	}
	return false;
}

void QtScriptSpriteBatchNode::insertQuadFromSprite(cocos2d::Sprite* sprite, int index)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		__o->insertQuadFromSprite(sprite, index);
	}
}

int QtScriptSpriteBatchNode::lowestAtlasIndexInChild(cocos2d::Sprite* sprite)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		return int(__o->lowestAtlasIndexInChild(sprite));
	}
	return 0;
}

int QtScriptSpriteBatchNode::rebuildIndexInOrder(cocos2d::Sprite* parent, int index)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		return int(__o->rebuildIndexInOrder(parent, index));
	}
	return 0;
}

void QtScriptSpriteBatchNode::removeChildAtIndex(int index, bool doCleanup)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		__o->removeChildAtIndex(index, doCleanup);
	}
}

void QtScriptSpriteBatchNode::removeSpriteFromAtlas(cocos2d::Sprite* sprite)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		__o->removeSpriteFromAtlas(sprite);
	}
}

void QtScriptSpriteBatchNode::reorderBatch(bool reorder)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		__o->reorderBatch(reorder);
	}
}

void QtScriptSpriteBatchNode::reserveCapacity(int newCapacity)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		__o->reserveCapacity(newCapacity);
	}
}

void QtScriptSpriteBatchNode::setBlendFunc(const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		__o->setBlendFunc(blendFunc);
	}
}

void QtScriptSpriteBatchNode::setTexture(cocos2d::Texture2D* texture)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		__o->setTexture(texture);
	}
}

void QtScriptSpriteBatchNode::setTextureAtlas(cocos2d::TextureAtlas* textureAtlas)
{
	auto __o = this->thiz<SpriteBatchNode *>();
	if (__o)
	{
		__o->setTextureAtlas(textureAtlas);
	}
}

QScriptValue QtScriptSpriteBatchNode::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(SpriteBatchNode::create(arg0));
		}
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<int>(context->argument(1));
			return __e->toScriptValue(SpriteBatchNode::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::SpriteBatchNode::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptSpriteBatchNode::createWithTexture(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(0));
			return __e->toScriptValue(SpriteBatchNode::createWithTexture(arg0));
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(0));
			auto arg1 = qscriptvalue_cast<int>(context->argument(1));
			return __e->toScriptValue(SpriteBatchNode::createWithTexture(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::SpriteBatchNode::createWithTexture");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptSpriteFrameCache::QtScriptSpriteFrameCache(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptSpriteFrameCache::QtScriptSpriteFrameCache(QScriptEngine *engine)
	: QtScriptSpriteFrameCache(engine, "SpriteFrameCache")
{
}

void QtScriptSpriteFrameCache::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<SpriteFrameCache, QtScriptSpriteFrameCache>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("destroyInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSpriteFrameCache::destroyInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSpriteFrameCache::getInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSpriteFrameCache::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSpriteFrameCache::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSpriteFrameCache::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::SpriteFrameCache");
	return false;
}

void QtScriptSpriteFrameCache::addSpriteFrame(cocos2d::SpriteFrame* frame, const QByteArray& frameName)
{
	auto __o = this->thiz<SpriteFrameCache *>();
	if (__o)
	{
		__o->addSpriteFrame(frame, frameName.toStdString());
	}
}

void QtScriptSpriteFrameCache::addSpriteFramesWithFile(const QByteArray& plist)
{
	auto __o = this->thiz<SpriteFrameCache *>();
	if (__o)
	{
		__o->addSpriteFramesWithFile(plist.toStdString());
	}
}

void QtScriptSpriteFrameCache::addSpriteFramesWithFile(const QByteArray& plist, const QByteArray& textureFileName)
{
	auto __o = this->thiz<SpriteFrameCache *>();
	if (__o)
	{
		__o->addSpriteFramesWithFile(plist.toStdString(), textureFileName.toStdString());
	}
}

void QtScriptSpriteFrameCache::addSpriteFramesWithFileContent(const QByteArray& plist_content, cocos2d::Texture2D* texture)
{
	auto __o = this->thiz<SpriteFrameCache *>();
	if (__o)
	{
		__o->addSpriteFramesWithFileContent(plist_content.toStdString(), texture);
	}
}

cocos2d::SpriteFrame* QtScriptSpriteFrameCache::getSpriteFrameByName(const QByteArray& name)
{
	auto __o = this->thiz<SpriteFrameCache *>();
	if (__o)
	{
		return __o->getSpriteFrameByName(name.toStdString());
	}
	return nullptr;
}

bool QtScriptSpriteFrameCache::init()
{
	auto __o = this->thiz<SpriteFrameCache *>();
	if (__o)
	{
		return __o->init();
	}
	return false;
}

bool QtScriptSpriteFrameCache::isSpriteFramesWithFileLoaded(const QByteArray& plist)
{
	auto __o = this->thiz<SpriteFrameCache *>();
	if (__o)
	{
		return __o->isSpriteFramesWithFileLoaded(plist.toStdString());
	}
	return false;
}

bool QtScriptSpriteFrameCache::reloadTexture(const QByteArray& plist)
{
	auto __o = this->thiz<SpriteFrameCache *>();
	if (__o)
	{
		return __o->reloadTexture(plist.toStdString());
	}
	return false;
}

void QtScriptSpriteFrameCache::removeSpriteFrameByName(const QByteArray& name)
{
	auto __o = this->thiz<SpriteFrameCache *>();
	if (__o)
	{
		__o->removeSpriteFrameByName(name.toStdString());
	}
}

void QtScriptSpriteFrameCache::removeSpriteFrames()
{
	auto __o = this->thiz<SpriteFrameCache *>();
	if (__o)
	{
		__o->removeSpriteFrames();
	}
}

void QtScriptSpriteFrameCache::removeSpriteFramesFromFile(const QByteArray& plist)
{
	auto __o = this->thiz<SpriteFrameCache *>();
	if (__o)
	{
		__o->removeSpriteFramesFromFile(plist.toStdString());
	}
}

void QtScriptSpriteFrameCache::removeSpriteFramesFromFileContent(const QByteArray& plist_content)
{
	auto __o = this->thiz<SpriteFrameCache *>();
	if (__o)
	{
		__o->removeSpriteFramesFromFileContent(plist_content.toStdString());
	}
}

void QtScriptSpriteFrameCache::removeSpriteFramesFromTexture(cocos2d::Texture2D* texture)
{
	auto __o = this->thiz<SpriteFrameCache *>();
	if (__o)
	{
		__o->removeSpriteFramesFromTexture(texture);
	}
}

void QtScriptSpriteFrameCache::removeUnusedSpriteFrames()
{
	auto __o = this->thiz<SpriteFrameCache *>();
	if (__o)
	{
		__o->removeUnusedSpriteFrames();
	}
}

QScriptValue QtScriptSpriteFrameCache::destroyInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			SpriteFrameCache::destroyInstance();
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::SpriteFrameCache::destroyInstance");
	return __e->uncaughtException();
}

QScriptValue QtScriptSpriteFrameCache::getInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(SpriteFrameCache::getInstance());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::SpriteFrameCache::getInstance");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptParallaxNode::QtScriptParallaxNode(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptParallaxNode::QtScriptParallaxNode(QScriptEngine *engine)
	: QtScriptParallaxNode(engine, "ParallaxNode")
{
}

void QtScriptParallaxNode::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<ParallaxNode, QtScriptParallaxNode>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptParallaxNode::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptParallaxNode::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptParallaxNode::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptParallaxNode::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::ParallaxNode");
	return false;
}

void QtScriptParallaxNode::addChild(cocos2d::Node* child, int z, const cocos2d::Vec2& parallaxRatio, const cocos2d::Vec2& positionOffset)
{
	auto __o = this->thiz<ParallaxNode *>();
	if (__o)
	{
		__o->addChild(child, z, parallaxRatio, positionOffset);
	}
}

cocos2d::_ccArray* QtScriptParallaxNode::getParallaxArray()
{
	auto __o = this->thiz<ParallaxNode *>();
	if (__o)
	{
		return __o->getParallaxArray();
	}
	return nullptr;
}

void QtScriptParallaxNode::setParallaxArray(cocos2d::_ccArray* parallaxArray)
{
	auto __o = this->thiz<ParallaxNode *>();
	if (__o)
	{
		__o->setParallaxArray(parallaxArray);
	}
}

QScriptValue QtScriptParallaxNode::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ParallaxNode::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::ParallaxNode::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptTileMapAtlas::QtScriptTileMapAtlas(QScriptEngine *engine, const QByteArray &className)
	: QtScriptAtlasNode(engine, className)
{
}

QtScriptTileMapAtlas::QtScriptTileMapAtlas(QScriptEngine *engine)
	: QtScriptTileMapAtlas(engine, "TileMapAtlas")
{
}

void QtScriptTileMapAtlas::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<AtlasNode *>());
	auto ctor = RegisterT<TileMapAtlas, QtScriptTileMapAtlas>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptTileMapAtlas::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptTileMapAtlas::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptTileMapAtlas::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptTileMapAtlas::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::TileMapAtlas");
	return false;
}

cocos2d::sImageTGA* QtScriptTileMapAtlas::getTGAInfo()
{
	auto __o = this->thiz<TileMapAtlas *>();
	if (__o)
	{
		return __o->getTGAInfo();
	}
	return nullptr;
}

cocos2d::Color3B QtScriptTileMapAtlas::getTileAt(const cocos2d::Vec2& position)
{
	auto __o = this->thiz<TileMapAtlas *>();
	if (__o)
	{
		return __o->getTileAt(position);
	}
	return cocos2d::Color3B();
}

bool QtScriptTileMapAtlas::initWithTileFile(const QByteArray& tile, const QByteArray& mapFile, int tileWidth, int tileHeight)
{
	auto __o = this->thiz<TileMapAtlas *>();
	if (__o)
	{
		return __o->initWithTileFile(tile.toStdString(), mapFile.toStdString(), tileWidth, tileHeight);
	}
	return false;
}

void QtScriptTileMapAtlas::releaseMap()
{
	auto __o = this->thiz<TileMapAtlas *>();
	if (__o)
	{
		__o->releaseMap();
	}
}

void QtScriptTileMapAtlas::setTGAInfo(cocos2d::sImageTGA* TGAInfo)
{
	auto __o = this->thiz<TileMapAtlas *>();
	if (__o)
	{
		__o->setTGAInfo(TGAInfo);
	}
}

void QtScriptTileMapAtlas::setTile(const cocos2d::Color3B& tile, const cocos2d::Vec2& position)
{
	auto __o = this->thiz<TileMapAtlas *>();
	if (__o)
	{
		__o->setTile(tile, position);
	}
}

QScriptValue QtScriptTileMapAtlas::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 4, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 4:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto arg2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg3 = qscriptvalue_cast<int>(context->argument(3));
			return __e->toScriptValue(TileMapAtlas::create(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::TileMapAtlas::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptAttachNode::QtScriptAttachNode(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptAttachNode::QtScriptAttachNode(QScriptEngine *engine)
	: QtScriptAttachNode(engine, "AttachNode")
{
}

void QtScriptAttachNode::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<AttachNode, QtScriptAttachNode>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptAttachNode::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptAttachNode::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptAttachNode::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptAttachNode::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::AttachNode");
	return false;
}

QScriptValue QtScriptAttachNode::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Bone3D*>(context->argument(0));
			return __e->toScriptValue(AttachNode::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::AttachNode::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptBillBoard::QtScriptBillBoard(QScriptEngine *engine, const QByteArray &className)
	: QtScriptSprite(engine, className)
{
}

QtScriptBillBoard::QtScriptBillBoard(QScriptEngine *engine)
	: QtScriptBillBoard(engine, "BillBoard")
{
}

void QtScriptBillBoard::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Sprite *>());
	auto ctor = RegisterT<BillBoard, QtScriptBillBoard>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptBillBoard::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithTexture", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptBillBoard::createWithTexture)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptBillBoard::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptBillBoard::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptBillBoard::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::BillBoard");
	return false;
}

int QtScriptBillBoard::getMode()
{
	auto __o = this->thiz<BillBoard *>();
	if (__o)
	{
		return int(__o->getMode());
	}
	return 0;
}

void QtScriptBillBoard::setMode(int mode)
{
	auto __o = this->thiz<BillBoard *>();
	if (__o)
	{
		__o->setMode(cocos2d::BillBoard::Mode(mode));
	}
}

QScriptValue QtScriptBillBoard::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(BillBoard::create());
		}
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<int>(context->argument(0));
			auto arg0 = cocos2d::BillBoard::Mode(tmp_0);
			return __e->toScriptValue(BillBoard::create(arg0));
		}
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<int>(context->argument(1));
			auto arg1 = cocos2d::BillBoard::Mode(tmp_1);
			return __e->toScriptValue(BillBoard::create(arg0, arg1));
		}
		case 3:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<cocos2d::Rect>(context->argument(1));
			auto tmp_2 = qscriptvalue_cast<int>(context->argument(2));
			auto arg2 = cocos2d::BillBoard::Mode(tmp_2);
			return __e->toScriptValue(BillBoard::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::BillBoard::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptBillBoard::createWithTexture(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(0));
			return __e->toScriptValue(BillBoard::createWithTexture(arg0));
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Texture2D*>(context->argument(0));
			auto tmp_1 = qscriptvalue_cast<int>(context->argument(1));
			auto arg1 = cocos2d::BillBoard::Mode(tmp_1);
			return __e->toScriptValue(BillBoard::createWithTexture(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::BillBoard::createWithTexture");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptMesh::QtScriptMesh(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptMesh::QtScriptMesh(QScriptEngine *engine)
	: QtScriptMesh(engine, "Mesh")
{
}

void QtScriptMesh::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Mesh, QtScriptMesh>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMesh::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

void QtScriptMesh::calculateAABB()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		__o->calculateAABB();
	}
}

cocos2d::AABB QtScriptMesh::getAABB()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return __o->getAABB();
	}
	return cocos2d::AABB();
}

cocos2d::BlendFunc QtScriptMesh::getBlendFunc()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return __o->getBlendFunc();
	}
	return cocos2d::BlendFunc();
}

cocos2d::backend::Buffer* QtScriptMesh::getIndexBuffer()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return __o->getIndexBuffer();
	}
	return nullptr;
}

int QtScriptMesh::getIndexCount()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return int(__o->getIndexCount());
	}
	return 0;
}

int QtScriptMesh::getIndexFormat()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return int(__o->getIndexFormat());
	}
	return 0;
}

cocos2d::Material* QtScriptMesh::getMaterial()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return __o->getMaterial();
	}
	return nullptr;
}

cocos2d::MeshIndexData* QtScriptMesh::getMeshIndexData()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return __o->getMeshIndexData();
	}
	return nullptr;
}

int QtScriptMesh::getMeshVertexAttribCount()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return int(__o->getMeshVertexAttribCount());
	}
	return 0;
}

cocos2d::MeshVertexAttrib QtScriptMesh::getMeshVertexAttribute(int idx)
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return __o->getMeshVertexAttribute(idx);
	}
	return cocos2d::MeshVertexAttrib();
}

QByteArray QtScriptMesh::getName()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getName());
	}
	return QByteArray();
}

int QtScriptMesh::getPrimitiveType()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return int(__o->getPrimitiveType());
	}
	return 0;
}

cocos2d::backend::ProgramState* QtScriptMesh::getProgramState()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return __o->getProgramState();
	}
	return nullptr;
}

cocos2d::MeshSkin* QtScriptMesh::getSkin()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return __o->getSkin();
	}
	return nullptr;
}

cocos2d::Texture2D* QtScriptMesh::getTexture()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return __o->getTexture();
	}
	return nullptr;
}

cocos2d::Texture2D* QtScriptMesh::getTexture(int usage)
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return __o->getTexture(cocos2d::NTextureData::Usage(usage));
	}
	return nullptr;
}

QByteArray QtScriptMesh::getTextureFileName()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getTextureFileName());
	}
	return QByteArray();
}

cocos2d::backend::Buffer* QtScriptMesh::getVertexBuffer()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return __o->getVertexBuffer();
	}
	return nullptr;
}

int QtScriptMesh::getVertexSizeInBytes()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return __o->getVertexSizeInBytes();
	}
	return 0;
}

bool QtScriptMesh::hasVertexAttrib(int attrib)
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return __o->hasVertexAttrib(cocos2d::shaderinfos::VertexKey(attrib));
	}
	return false;
}

bool QtScriptMesh::isForceDisableDepthTest()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return __o->isForceDisableDepthTest();
	}
	return false;
}

bool QtScriptMesh::isVisible()
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		return __o->isVisible();
	}
	return false;
}

void QtScriptMesh::setBlendFunc(const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		__o->setBlendFunc(blendFunc);
	}
}

void QtScriptMesh::setForce2DQueue(bool force2D)
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		__o->setForce2DQueue(force2D);
	}
}

void QtScriptMesh::setForceDisableDepthTest(bool is)
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		__o->setForceDisableDepthTest(is);
	}
}

void QtScriptMesh::setMaterial(cocos2d::Material* material)
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		__o->setMaterial(material);
	}
}

void QtScriptMesh::setMeshIndexData(cocos2d::MeshIndexData* indexdata)
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		__o->setMeshIndexData(indexdata);
	}
}

void QtScriptMesh::setName(const QByteArray& name)
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		__o->setName(name.toStdString());
	}
}

void QtScriptMesh::setProgramState(cocos2d::backend::ProgramState* programState)
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		__o->setProgramState(programState);
	}
}

void QtScriptMesh::setSkin(cocos2d::MeshSkin* skin)
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		__o->setSkin(skin);
	}
}

void QtScriptMesh::setTexture(cocos2d::Texture2D* tex)
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		__o->setTexture(tex);
	}
}

void QtScriptMesh::setTexture(cocos2d::Texture2D* tex, int usage)
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		__o->setTexture(tex, cocos2d::NTextureData::Usage(usage));
	}
}

void QtScriptMesh::setTexture(cocos2d::Texture2D* tex, int usage, bool cacheFileName)
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		__o->setTexture(tex, cocos2d::NTextureData::Usage(usage), cacheFileName);
	}
}

void QtScriptMesh::setVisible(bool visible)
{
	auto __o = this->thiz<Mesh *>();
	if (__o)
	{
		__o->setVisible(visible);
	}
}

QScriptValue QtScriptMesh::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<cocos2d::MeshIndexData*>(context->argument(1));
			return __e->toScriptValue(Mesh::create(arg0, arg1));
		}
		case 3:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<cocos2d::MeshIndexData*>(context->argument(1));
			auto arg2 = qscriptvalue_cast<cocos2d::MeshSkin*>(context->argument(2));
			return __e->toScriptValue(Mesh::create(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Mesh::create");
	return __e->uncaughtException();
}

int QtScriptMesh::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMesh::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMesh::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new Mesh();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Mesh constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptMeshSkin::QtScriptMeshSkin(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptMeshSkin::QtScriptMeshSkin(QScriptEngine *engine)
	: QtScriptMeshSkin(engine, "MeshSkin")
{
}

void QtScriptMeshSkin::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<MeshSkin, QtScriptMeshSkin>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

void QtScriptMeshSkin::addSkinBone(cocos2d::Bone3D* bone)
{
	auto __o = this->thiz<MeshSkin *>();
	if (__o)
	{
		__o->addSkinBone(bone);
	}
}

cocos2d::Bone3D* QtScriptMeshSkin::getBoneByIndex(unsigned int index)
{
	auto __o = this->thiz<MeshSkin *>();
	if (__o)
	{
		return __o->getBoneByIndex(index);
	}
	return nullptr;
}

cocos2d::Bone3D* QtScriptMeshSkin::getBoneByName(const QByteArray& id)
{
	auto __o = this->thiz<MeshSkin *>();
	if (__o)
	{
		return __o->getBoneByName(id.toStdString());
	}
	return nullptr;
}

int QtScriptMeshSkin::getBoneCount()
{
	auto __o = this->thiz<MeshSkin *>();
	if (__o)
	{
		return int(__o->getBoneCount());
	}
	return 0;
}

int QtScriptMeshSkin::getBoneIndex(cocos2d::Bone3D* bone)
{
	auto __o = this->thiz<MeshSkin *>();
	if (__o)
	{
		return __o->getBoneIndex(bone);
	}
	return 0;
}

cocos2d::Mat4 QtScriptMeshSkin::getInvBindPose(const cocos2d::Bone3D* bone)
{
	auto __o = this->thiz<MeshSkin *>();
	if (__o)
	{
		return __o->getInvBindPose(bone);
	}
	return cocos2d::Mat4();
}

cocos2d::Bone3D* QtScriptMeshSkin::getRootBone()
{
	auto __o = this->thiz<MeshSkin *>();
	if (__o)
	{
		return __o->getRootBone();
	}
	return nullptr;
}

void QtScriptMeshSkin::removeAllBones()
{
	auto __o = this->thiz<MeshSkin *>();
	if (__o)
	{
		__o->removeAllBones();
	}
}

int QtScriptMeshSkin::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMeshSkin::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMeshSkin::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new MeshSkin();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::MeshSkin constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptMotionStreak3D::QtScriptMotionStreak3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptMotionStreak3D::QtScriptMotionStreak3D(QScriptEngine *engine)
	: QtScriptMotionStreak3D(engine, "MotionStreak3D")
{
}

void QtScriptMotionStreak3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<MotionStreak3D, QtScriptMotionStreak3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptMotionStreak3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptMotionStreak3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMotionStreak3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMotionStreak3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::MotionStreak3D");
	return false;
}

cocos2d::BlendFunc QtScriptMotionStreak3D::getBlendFunc()
{
	auto __o = this->thiz<MotionStreak3D *>();
	if (__o)
	{
		return __o->getBlendFunc();
	}
	return cocos2d::BlendFunc();
}

float QtScriptMotionStreak3D::getStroke()
{
	auto __o = this->thiz<MotionStreak3D *>();
	if (__o)
	{
		return __o->getStroke();
	}
	return static_cast<float>(0);
}

cocos2d::Vec3 QtScriptMotionStreak3D::getSweepAxis()
{
	auto __o = this->thiz<MotionStreak3D *>();
	if (__o)
	{
		return __o->getSweepAxis();
	}
	return cocos2d::Vec3();
}

cocos2d::Texture2D* QtScriptMotionStreak3D::getTexture()
{
	auto __o = this->thiz<MotionStreak3D *>();
	if (__o)
	{
		return __o->getTexture();
	}
	return nullptr;
}

bool QtScriptMotionStreak3D::initWithFade(float fade, float minSeg, float stroke, const cocos2d::Color3B& color, const QByteArray& path)
{
	auto __o = this->thiz<MotionStreak3D *>();
	if (__o)
	{
		return __o->initWithFade(fade, minSeg, stroke, color, path.toStdString());
	}
	return false;
}

bool QtScriptMotionStreak3D::isStartingPositionInitialized()
{
	auto __o = this->thiz<MotionStreak3D *>();
	if (__o)
	{
		return __o->isStartingPositionInitialized();
	}
	return false;
}

void QtScriptMotionStreak3D::reset()
{
	auto __o = this->thiz<MotionStreak3D *>();
	if (__o)
	{
		__o->reset();
	}
}

void QtScriptMotionStreak3D::setBlendFunc(const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<MotionStreak3D *>();
	if (__o)
	{
		__o->setBlendFunc(blendFunc);
	}
}

void QtScriptMotionStreak3D::setStartingPositionInitialized(bool bStartingPositionInitialized)
{
	auto __o = this->thiz<MotionStreak3D *>();
	if (__o)
	{
		__o->setStartingPositionInitialized(bStartingPositionInitialized);
	}
}

void QtScriptMotionStreak3D::setStroke(float stroke)
{
	auto __o = this->thiz<MotionStreak3D *>();
	if (__o)
	{
		__o->setStroke(stroke);
	}
}

void QtScriptMotionStreak3D::setSweepAxis(const cocos2d::Vec3& sweepAxis)
{
	auto __o = this->thiz<MotionStreak3D *>();
	if (__o)
	{
		__o->setSweepAxis(sweepAxis);
	}
}

void QtScriptMotionStreak3D::setTexture(cocos2d::Texture2D* texture)
{
	auto __o = this->thiz<MotionStreak3D *>();
	if (__o)
	{
		__o->setTexture(texture);
	}
}

void QtScriptMotionStreak3D::tintWithColor(const cocos2d::Color3B& colors)
{
	auto __o = this->thiz<MotionStreak3D *>();
	if (__o)
	{
		__o->tintWithColor(colors);
	}
}

QScriptValue QtScriptMotionStreak3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 5, 5))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 5:
		{
			auto arg0 = qscriptvalue_cast<float>(context->argument(0));
			auto arg1 = qscriptvalue_cast<float>(context->argument(1));
			auto arg2 = qscriptvalue_cast<float>(context->argument(2));
			auto arg3 = qscriptvalue_cast<cocos2d::Color3B>(context->argument(3));
			auto tmp_4 = qscriptvalue_cast<QByteArray>(context->argument(4));
			auto arg4 = tmp_4.toStdString();
			return __e->toScriptValue(MotionStreak3D::create(arg0, arg1, arg2, arg3, arg4));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::MotionStreak3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptMeshIndexData::QtScriptMeshIndexData(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptMeshIndexData::QtScriptMeshIndexData(QScriptEngine *engine)
	: QtScriptMeshIndexData(engine, "MeshIndexData")
{
}

void QtScriptMeshIndexData::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<MeshIndexData, QtScriptMeshIndexData>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptMeshIndexData::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMeshIndexData::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMeshIndexData::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::MeshIndexData");
	return false;
}

cocos2d::AABB QtScriptMeshIndexData::getAABB()
{
	auto __o = this->thiz<MeshIndexData *>();
	if (__o)
	{
		return __o->getAABB();
	}
	return cocos2d::AABB();
}

QByteArray QtScriptMeshIndexData::getId()
{
	auto __o = this->thiz<MeshIndexData *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getId());
	}
	return QByteArray();
}

cocos2d::backend::Buffer* QtScriptMeshIndexData::getIndexBuffer()
{
	auto __o = this->thiz<MeshIndexData *>();
	if (__o)
	{
		return __o->getIndexBuffer();
	}
	return nullptr;
}

const cocos2d::MeshVertexData* QtScriptMeshIndexData::getMeshVertexData()
{
	auto __o = this->thiz<MeshIndexData *>();
	if (__o)
	{
		return __o->getMeshVertexData();
	}
	return nullptr;
}

int QtScriptMeshIndexData::getPrimitiveType()
{
	auto __o = this->thiz<MeshIndexData *>();
	if (__o)
	{
		return int(__o->getPrimitiveType());
	}
	return 0;
}

cocos2d::backend::Buffer* QtScriptMeshIndexData::getVertexBuffer()
{
	auto __o = this->thiz<MeshIndexData *>();
	if (__o)
	{
		return __o->getVertexBuffer();
	}
	return nullptr;
}

void QtScriptMeshIndexData::setAABB(const cocos2d::AABB& aabb)
{
	auto __o = this->thiz<MeshIndexData *>();
	if (__o)
	{
		__o->setAABB(aabb);
	}
}

void QtScriptMeshIndexData::setId(const QByteArray& id)
{
	auto __o = this->thiz<MeshIndexData *>();
	if (__o)
	{
		__o->setId(id.toStdString());
	}
}

void QtScriptMeshIndexData::setPrimitiveType(int primitive)
{
	auto __o = this->thiz<MeshIndexData *>();
	if (__o)
	{
		__o->setPrimitiveType(cocos2d::backend::PrimitiveType(primitive));
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptMeshVertexData::QtScriptMeshVertexData(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptMeshVertexData::QtScriptMeshVertexData(QScriptEngine *engine)
	: QtScriptMeshVertexData(engine, "MeshVertexData")
{
}

void QtScriptMeshVertexData::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<MeshVertexData, QtScriptMeshVertexData>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptMeshVertexData::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptMeshVertexData::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptMeshVertexData::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::MeshVertexData");
	return false;
}

unsigned QtScriptMeshVertexData::getAtrSetId()
{
	auto __o = this->thiz<MeshVertexData *>();
	if (__o)
	{
		return unsigned(__o->getAtrSetId());
	}
	return static_cast<unsigned>(0);
}

cocos2d::MeshIndexData* QtScriptMeshVertexData::getMeshIndexDataById(const QByteArray& id)
{
	auto __o = this->thiz<MeshVertexData *>();
	if (__o)
	{
		return __o->getMeshIndexDataById(id.toStdString());
	}
	return nullptr;
}

cocos2d::MeshIndexData* QtScriptMeshVertexData::getMeshIndexDataByIndex(int index)
{
	auto __o = this->thiz<MeshVertexData *>();
	if (__o)
	{
		return __o->getMeshIndexDataByIndex(index);
	}
	return nullptr;
}

int QtScriptMeshVertexData::getMeshIndexDataCount()
{
	auto __o = this->thiz<MeshVertexData *>();
	if (__o)
	{
		return int(__o->getMeshIndexDataCount());
	}
	return 0;
}

cocos2d::MeshVertexAttrib QtScriptMeshVertexData::getMeshVertexAttrib(int index)
{
	auto __o = this->thiz<MeshVertexData *>();
	if (__o)
	{
		return __o->getMeshVertexAttrib(index);
	}
	return cocos2d::MeshVertexAttrib();
}

int QtScriptMeshVertexData::getMeshVertexAttribCount()
{
	auto __o = this->thiz<MeshVertexData *>();
	if (__o)
	{
		return int(__o->getMeshVertexAttribCount());
	}
	return 0;
}

int QtScriptMeshVertexData::getSizePerVertex()
{
	auto __o = this->thiz<MeshVertexData *>();
	if (__o)
	{
		return int(__o->getSizePerVertex());
	}
	return 0;
}

cocos2d::backend::Buffer* QtScriptMeshVertexData::getVertexBuffer()
{
	auto __o = this->thiz<MeshVertexData *>();
	if (__o)
	{
		return __o->getVertexBuffer();
	}
	return nullptr;
}

bool QtScriptMeshVertexData::hasVertexAttrib(int attrib)
{
	auto __o = this->thiz<MeshVertexData *>();
	if (__o)
	{
		return __o->hasVertexAttrib(cocos2d::shaderinfos::VertexKey(attrib));
	}
	return false;
}

} // end of cocos2d

namespace cocos2d {
QtScriptRay::QtScriptRay(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Ray, false>(engine, className)
{
}

QtScriptRay::QtScriptRay(QScriptEngine *engine)
	: QtScriptRay(engine, "Ray")
{
}

void QtScriptRay::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<Ray, QtScriptRay>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

float QtScriptRay::dist(const cocos2d::Plane& plane)
{
	auto __o = this->thiz<Ray *>();
	if (__o)
	{
		return __o->dist(plane);
	}
	return static_cast<float>(0);
}

bool QtScriptRay::intersectsAABB(const cocos2d::AABB& arg0)
{
	auto __o = this->thiz<Ray *>();
	if (__o)
	{
		return __o->intersects(arg0, nullptr);
	}
	return false;
}

bool QtScriptRay::intersectsOBB(const cocos2d::OBB& arg0)
{
	auto __o = this->thiz<Ray *>();
	if (__o)
	{
		return __o->intersects(arg0, nullptr);
	}
	return false;
}

cocos2d::Vec3 QtScriptRay::intersectsPlane(const cocos2d::Plane& plane)
{
	auto __o = this->thiz<Ray *>();
	if (__o)
	{
		return __o->intersects(plane);
	}
	return cocos2d::Vec3();
}

void QtScriptRay::set(const cocos2d::Vec3& origin, const cocos2d::Vec3& direction)
{
	auto __o = this->thiz<Ray *>();
	if (__o)
	{
		__o->set(origin, direction);
	}
}

void QtScriptRay::transform(const cocos2d::Mat4& matrix)
{
	auto __o = this->thiz<Ray *>();
	if (__o)
	{
		__o->transform(matrix);
	}
}

int QtScriptRay::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptRay::constructorArgumentCountMax() const
{
	return 2;
}

bool QtScriptRay::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			Q_UNUSED(out);
			ok = true;
			break;
		}
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Ray>(context->argument(0));
			out = Ray(arg0);
			ok = true;
			break;
		}
		case 2:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(0));
			auto arg1 = qscriptvalue_cast<cocos2d::Vec3>(context->argument(1));
			out = Ray(arg0, arg1);
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Ray constructor");
	}
	return ok;
}

cocos2d::Vec3 QtScriptRay::_public_field_get_direction() const
{
	auto object = thiz<Ray *>();
	if (object)
	{
		return object->_direction;
	}
	return cocos2d::Vec3();
}

void QtScriptRay::_public_field_set_direction(const cocos2d::Vec3& value)
{
	auto object = thiz<Ray *>();
	if (object)
	{
		object->_direction = value;
	}
}

cocos2d::Vec3 QtScriptRay::_public_field_get_origin() const
{
	auto object = thiz<Ray *>();
	if (object)
	{
		return object->_origin;
	}
	return cocos2d::Vec3();
}

void QtScriptRay::_public_field_set_origin(const cocos2d::Vec3& value)
{
	auto object = thiz<Ray *>();
	if (object)
	{
		object->_origin = value;
	}
}

} // end of cocos2d

namespace cocos2d {
QtScriptBone3D::QtScriptBone3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptBone3D::QtScriptBone3D(QScriptEngine *engine)
	: QtScriptBone3D(engine, "Bone3D")
{
}

void QtScriptBone3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Bone3D, QtScriptBone3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptBone3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptBone3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptBone3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptBone3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Bone3D");
	return false;
}

void QtScriptBone3D::addChildBone(cocos2d::Bone3D* bone)
{
	auto __o = this->thiz<Bone3D *>();
	if (__o)
	{
		__o->addChildBone(bone);
	}
}

void QtScriptBone3D::clearBoneBlendState()
{
	auto __o = this->thiz<Bone3D *>();
	if (__o)
	{
		__o->clearBoneBlendState();
	}
}

cocos2d::Bone3D* QtScriptBone3D::getChildBoneByIndex(int index)
{
	auto __o = this->thiz<Bone3D *>();
	if (__o)
	{
		return __o->getChildBoneByIndex(index);
	}
	return nullptr;
}

int QtScriptBone3D::getChildBoneCount()
{
	auto __o = this->thiz<Bone3D *>();
	if (__o)
	{
		return int(__o->getChildBoneCount());
	}
	return 0;
}

cocos2d::Mat4 QtScriptBone3D::getInverseBindPose()
{
	auto __o = this->thiz<Bone3D *>();
	if (__o)
	{
		return __o->getInverseBindPose();
	}
	return cocos2d::Mat4();
}

QByteArray QtScriptBone3D::getName()
{
	auto __o = this->thiz<Bone3D *>();
	if (__o)
	{
		return QByteArray::fromStdString(__o->getName());
	}
	return QByteArray();
}

cocos2d::Bone3D* QtScriptBone3D::getParentBone()
{
	auto __o = this->thiz<Bone3D *>();
	if (__o)
	{
		return __o->getParentBone();
	}
	return nullptr;
}

cocos2d::Mat4 QtScriptBone3D::getWorldMat()
{
	auto __o = this->thiz<Bone3D *>();
	if (__o)
	{
		return __o->getWorldMat();
	}
	return cocos2d::Mat4();
}

void QtScriptBone3D::removeAllChildBone()
{
	auto __o = this->thiz<Bone3D *>();
	if (__o)
	{
		__o->removeAllChildBone();
	}
}

void QtScriptBone3D::removeChildBone(cocos2d::Bone3D* bone)
{
	auto __o = this->thiz<Bone3D *>();
	if (__o)
	{
		__o->removeChildBone(bone);
	}
}

void QtScriptBone3D::removeChildBoneByIndex(int index)
{
	auto __o = this->thiz<Bone3D *>();
	if (__o)
	{
		__o->removeChildBoneByIndex(index);
	}
}

void QtScriptBone3D::resetPose()
{
	auto __o = this->thiz<Bone3D *>();
	if (__o)
	{
		__o->resetPose();
	}
}

void QtScriptBone3D::setInverseBindPose(const cocos2d::Mat4& m)
{
	auto __o = this->thiz<Bone3D *>();
	if (__o)
	{
		__o->setInverseBindPose(m);
	}
}

void QtScriptBone3D::setOriPose(const cocos2d::Mat4& m)
{
	auto __o = this->thiz<Bone3D *>();
	if (__o)
	{
		__o->setOriPose(m);
	}
}

QScriptValue QtScriptBone3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(Bone3D::create(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Bone3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptSkeleton3D::QtScriptSkeleton3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptSkeleton3D::QtScriptSkeleton3D(QScriptEngine *engine)
	: QtScriptSkeleton3D(engine, "Skeleton3D")
{
}

void QtScriptSkeleton3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Skeleton3D, QtScriptSkeleton3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

void QtScriptSkeleton3D::addBone(cocos2d::Bone3D* bone)
{
	auto __o = this->thiz<Skeleton3D *>();
	if (__o)
	{
		__o->addBone(bone);
	}
}

cocos2d::Bone3D* QtScriptSkeleton3D::getBoneByIndex(unsigned int index)
{
	auto __o = this->thiz<Skeleton3D *>();
	if (__o)
	{
		return __o->getBoneByIndex(index);
	}
	return nullptr;
}

cocos2d::Bone3D* QtScriptSkeleton3D::getBoneByName(const QByteArray& id)
{
	auto __o = this->thiz<Skeleton3D *>();
	if (__o)
	{
		return __o->getBoneByName(id.toStdString());
	}
	return nullptr;
}

int QtScriptSkeleton3D::getBoneCount()
{
	auto __o = this->thiz<Skeleton3D *>();
	if (__o)
	{
		return int(__o->getBoneCount());
	}
	return 0;
}

int QtScriptSkeleton3D::getBoneIndex(cocos2d::Bone3D* bone)
{
	auto __o = this->thiz<Skeleton3D *>();
	if (__o)
	{
		return __o->getBoneIndex(bone);
	}
	return 0;
}

cocos2d::Bone3D* QtScriptSkeleton3D::getRootBone(int index)
{
	auto __o = this->thiz<Skeleton3D *>();
	if (__o)
	{
		return __o->getRootBone(index);
	}
	return nullptr;
}

int QtScriptSkeleton3D::getRootCount()
{
	auto __o = this->thiz<Skeleton3D *>();
	if (__o)
	{
		return int(__o->getRootCount());
	}
	return 0;
}

void QtScriptSkeleton3D::removeAllBones()
{
	auto __o = this->thiz<Skeleton3D *>();
	if (__o)
	{
		__o->removeAllBones();
	}
}

void QtScriptSkeleton3D::updateBoneMatrix()
{
	auto __o = this->thiz<Skeleton3D *>();
	if (__o)
	{
		__o->updateBoneMatrix();
	}
}

int QtScriptSkeleton3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSkeleton3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSkeleton3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new Skeleton3D();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Skeleton3D constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptSkybox::QtScriptSkybox(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptSkybox::QtScriptSkybox(QScriptEngine *engine)
	: QtScriptSkybox(engine, "Skybox")
{
}

void QtScriptSkybox::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<Skybox, QtScriptSkybox>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSkybox::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSkybox::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSkybox::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSkybox::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Skybox");
	return false;
}

bool QtScriptSkybox::init(const QByteArray& positive_x, const QByteArray& negative_x, const QByteArray& positive_y, const QByteArray& negative_y, const QByteArray& positive_z, const QByteArray& negative_z)
{
	auto __o = this->thiz<Skybox *>();
	if (__o)
	{
		return __o->init(positive_x.toStdString(), negative_x.toStdString(), positive_y.toStdString(), negative_y.toStdString(), positive_z.toStdString(), negative_z.toStdString());
	}
	return false;
}

void QtScriptSkybox::reload()
{
	auto __o = this->thiz<Skybox *>();
	if (__o)
	{
		__o->reload();
	}
}

void QtScriptSkybox::setTexture(cocos2d::TextureCube* arg0)
{
	auto __o = this->thiz<Skybox *>();
	if (__o)
	{
		__o->setTexture(arg0);
	}
}

QScriptValue QtScriptSkybox::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 6))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Skybox::create());
		}
		case 1:
		{
			break;
		}
		case 2:
		{
			break;
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			break;
		}
		case 5:
		{
			break;
		}
		case 6:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto tmp_2 = qscriptvalue_cast<QByteArray>(context->argument(2));
			auto arg2 = tmp_2.toStdString();
			auto tmp_3 = qscriptvalue_cast<QByteArray>(context->argument(3));
			auto arg3 = tmp_3.toStdString();
			auto tmp_4 = qscriptvalue_cast<QByteArray>(context->argument(4));
			auto arg4 = tmp_4.toStdString();
			auto tmp_5 = qscriptvalue_cast<QByteArray>(context->argument(5));
			auto arg5 = tmp_5.toStdString();
			return __e->toScriptValue(Skybox::create(arg0, arg1, arg2, arg3, arg4, arg5));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Skybox::create");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptSprite3DData::QtScriptSprite3DData(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptSprite3DData::QtScriptSprite3DData(QScriptEngine *engine)
	: QtScriptSprite3DData(engine, "Sprite3DData")
{
}

void QtScriptSprite3DData::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Sprite3DData, QtScriptSprite3DData>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptSprite3DData::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSprite3DData::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSprite3DData::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		out = new Sprite3DData;
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::Sprite3DData constructor");
	return false;
}

bool QtScriptSprite3DData::loadFromBundle(cocos2d::Bundle3D* bundle)
{
	auto __o = this->thiz<Sprite3DData *>();
	if (__o)
	{
		return __o->loadFromBundle(bundle);
	}
	return false;
}

bool QtScriptSprite3DData::loadFromFile(const QByteArray& filePath)
{
	auto __o = this->thiz<Sprite3DData *>();
	if (__o)
	{
		return __o->loadFromFile(filePath.toStdString());
	}
	return false;
}

bool QtScriptSprite3DData::loadFromObj(const QByteArray& filePath)
{
	auto __o = this->thiz<Sprite3DData *>();
	if (__o)
	{
		return __o->loadFromObj(filePath.toStdString());
	}
	return false;
}

} // end of cocos2d

namespace cocos2d {
QtScriptSprite3DCache::QtScriptSprite3DCache(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Sprite3DCache *, true>(engine, className)
{
}

QtScriptSprite3DCache::QtScriptSprite3DCache(QScriptEngine *engine)
	: QtScriptSprite3DCache(engine, "Sprite3DCache")
{
}

void QtScriptSprite3DCache::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	QScriptValue inherit;
	auto ctor = RegisterT<Sprite3DCache, QtScriptSprite3DCache>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("destroyInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite3DCache::destroyInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite3DCache::getInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSprite3DCache::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSprite3DCache::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSprite3DCache::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Sprite3DCache");
	return false;
}

bool QtScriptSprite3DCache::addSprite3DData(const QByteArray& key, cocos2d::Sprite3DData* spritedata)
{
	auto __o = this->thiz<Sprite3DCache *>();
	if (__o)
	{
		return __o->addSprite3DData(key.toStdString(), spritedata);
	}
	return false;
}

cocos2d::Sprite3DData* QtScriptSprite3DCache::getDataFromFileCached(const QByteArray& filePath)
{
	auto __o = this->thiz<Sprite3DCache *>();
	if (__o)
	{
		return __o->getDataFromFileCached(filePath.toStdString());
	}
	return nullptr;
}

cocos2d::Sprite3DData* QtScriptSprite3DCache::getSpriteData(const QByteArray& key)
{
	auto __o = this->thiz<Sprite3DCache *>();
	if (__o)
	{
		return __o->getSpriteData(key.toStdString());
	}
	return nullptr;
}

void QtScriptSprite3DCache::removeAllSprite3DData()
{
	auto __o = this->thiz<Sprite3DCache *>();
	if (__o)
	{
		__o->removeAllSprite3DData();
	}
}

void QtScriptSprite3DCache::removeSprite3DData(const QByteArray& key)
{
	auto __o = this->thiz<Sprite3DCache *>();
	if (__o)
	{
		__o->removeSprite3DData(key.toStdString());
	}
}

void QtScriptSprite3DCache::removeUnusedSprite3DData()
{
	auto __o = this->thiz<Sprite3DCache *>();
	if (__o)
	{
		__o->removeUnusedSprite3DData();
	}
}

QScriptValue QtScriptSprite3DCache::destroyInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			Sprite3DCache::destroyInstance();
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite3DCache::destroyInstance");
	return __e->uncaughtException();
}

QScriptValue QtScriptSprite3DCache::getInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Sprite3DCache::getInstance());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite3DCache::getInstance");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptSprite3D::QtScriptSprite3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptSprite3D::QtScriptSprite3D(QScriptEngine *engine)
	: QtScriptSprite3D(engine, "Sprite3D")
{
}

void QtScriptSprite3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<Sprite3D, QtScriptSprite3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createAsync", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite3D::createAsync)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createAsyncWithSkeleton", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite3D::createAsyncWithSkeleton)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithSkeleton", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite3D::createWithSkeleton)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getOverrideTextureExtension", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite3D::getOverrideTextureExtension)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("setOverrideTextureExtension", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite3D::setOverrideTextureExtension)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSprite3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSprite3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSprite3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Sprite3D");
	return false;
}

void QtScriptSprite3D::applySpriteData(cocos2d::Sprite3DData* data)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->applySpriteData(data);
	}
}

void QtScriptSprite3D::applySpriteData(cocos2d::Sprite3DData* data, cocos2d::Sprite3DData* skele)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->applySpriteData(data, skele);
	}
}

void QtScriptSprite3D::genMaterial()
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->genMaterial();
	}
}

void QtScriptSprite3D::genMaterial(bool useLight)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->genMaterial(useLight);
	}
}

cocos2d::AABB QtScriptSprite3D::getAABB()
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->getAABB();
	}
	return cocos2d::AABB();
}

cocos2d::AttachNode* QtScriptSprite3D::getAttachNode(const QByteArray& boneName)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->getAttachNode(boneName.toStdString());
	}
	return nullptr;
}

cocos2d::BlendFunc QtScriptSprite3D::getBlendFunc()
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->getBlendFunc();
	}
	return cocos2d::BlendFunc();
}

unsigned int QtScriptSprite3D::getLightMask()
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->getLightMask();
	}
	return static_cast<unsigned int>(0);
}

cocos2d::Material* QtScriptSprite3D::getMaterial(int meshIndex)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->getMaterial(meshIndex);
	}
	return nullptr;
}

cocos2d::Mesh* QtScriptSprite3D::getMesh()
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->getMesh();
	}
	return nullptr;
}

cocos2d::Mesh* QtScriptSprite3D::getMeshByIndex(int index)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->getMeshByIndex(index);
	}
	return nullptr;
}

cocos2d::Mesh* QtScriptSprite3D::getMeshByName(const QByteArray& name)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->getMeshByName(name.toStdString());
	}
	return nullptr;
}

int QtScriptSprite3D::getMeshCount()
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return int(__o->getMeshCount());
	}
	return 0;
}

cocos2d::MeshIndexData* QtScriptSprite3D::getMeshIndexData(const QByteArray& indexId)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->getMeshIndexData(indexId.toStdString());
	}
	return nullptr;
}

cocos2d::Skeleton3D* QtScriptSprite3D::getSkeleton()
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->getSkeleton();
	}
	return nullptr;
}

bool QtScriptSprite3D::initWithFile(const QByteArray& path)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->initWithFile(path.toStdString());
	}
	return false;
}

bool QtScriptSprite3D::initWithFile(const QByteArray& path, cocos2d::Sprite3DData* skele)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->initWithFile(path.toStdString(), skele);
	}
	return false;
}

bool QtScriptSprite3D::initWithSkeletonFile(const QByteArray& modelPath, const QByteArray& skeletonPath)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->initWithSkeletonFile(modelPath.toStdString(), skeletonPath.toStdString());
	}
	return false;
}

bool QtScriptSprite3D::isForce2Dqueue()
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->isForce2Dqueue();
	}
	return false;
}

bool QtScriptSprite3D::isForceDepthWrite()
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->isForceDepthWrite();
	}
	return false;
}

bool QtScriptSprite3D::isForceDisableDepthTest()
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->isForceDisableDepthTest();
	}
	return false;
}

bool QtScriptSprite3D::loadFromCache(const QByteArray& path)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->loadFromCache(path.toStdString());
	}
	return false;
}

bool QtScriptSprite3D::loadFromCache(const QByteArray& path, cocos2d::Sprite3DData* skele)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->loadFromCache(path.toStdString(), skele);
	}
	return false;
}

bool QtScriptSprite3D::loadFromCacheWithSkeleton(const QByteArray& path, const QByteArray& skeletonPath)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		return __o->loadFromCacheWithSkeleton(path.toStdString(), skeletonPath.toStdString());
	}
	return false;
}

void QtScriptSprite3D::removeAllAttachNode()
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->removeAllAttachNode();
	}
}

void QtScriptSprite3D::removeAttachNode(const QByteArray& boneName)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->removeAttachNode(boneName.toStdString());
	}
}

void QtScriptSprite3D::reset()
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->reset();
	}
}

void QtScriptSprite3D::setBlendFunc(const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->setBlendFunc(blendFunc);
	}
}

void QtScriptSprite3D::setCullFace(int side)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->setCullFace(cocos2d::backend::CullMode(side));
	}
}

void QtScriptSprite3D::setCullFaceEnabled(bool enable)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->setCullFaceEnabled(enable);
	}
}

void QtScriptSprite3D::setForce2DQueue(bool force2D)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->setForce2DQueue(force2D);
	}
}

void QtScriptSprite3D::setForceDepthWrite(bool value)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->setForceDepthWrite(value);
	}
}

void QtScriptSprite3D::setForceDisableDepthTest(bool is)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->setForceDisableDepthTest(is);
	}
}

void QtScriptSprite3D::setLightMask(unsigned int mask)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->setLightMask(mask);
	}
}

void QtScriptSprite3D::setMaterial(cocos2d::Material* material)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->setMaterial(material);
	}
}

void QtScriptSprite3D::setMaterial(cocos2d::Material* material, int meshIndex)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->setMaterial(material, meshIndex);
	}
}

void QtScriptSprite3D::setTexture(cocos2d::Texture2D* texture)
{
	auto __o = this->thiz<Sprite3D *>();
	if (__o)
	{
		__o->setTexture(texture);
	}
}

QScriptValue QtScriptSprite3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Sprite3D::create());
		}
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(Sprite3D::create(arg0));
		}
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			return __e->toScriptValue(Sprite3D::create(arg0, arg1));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite3D::create");
	return __e->uncaughtException();
}

QScriptValue QtScriptSprite3D::createAsync(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = context->argument(1);
			Sprite3D::createAsync(arg0, QtCocosScriptUtils::getSprite3DCallback(arg1), nullptr);
			return __e->undefinedValue();
		}
		case 3:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto arg2 = context->argument(2);
			Sprite3D::createAsync(arg0, arg1, QtCocosScriptUtils::getSprite3DCallback(arg2), nullptr);
			return __e->undefinedValue();
		}
		case 4:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto tmp_2 = qscriptvalue_cast<QByteArray>(context->argument(2));
			auto arg2 = tmp_2.toStdString();
			auto arg3 = context->argument(3);
			Sprite3D::createAsync(arg0, arg1, arg2, QtCocosScriptUtils::getSprite3DCallback(arg3), nullptr);
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite3D::createAsync");
	return __e->uncaughtException();
}

QScriptValue QtScriptSprite3D::createAsyncWithSkeleton(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 3, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 3:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto arg2 = context->argument(2);
			Sprite3D::createAsyncWithSkeleton(arg0, arg1, QtCocosScriptUtils::getSprite3DCallback(arg2), nullptr);
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite3D::createAsyncWithSkeleton");
	return __e->uncaughtException();
}

QScriptValue QtScriptSprite3D::createWithSkeleton(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 3))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			return __e->toScriptValue(Sprite3D::createWithSkeleton(arg0, arg1));
		}
		case 3:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto tmp_1 = qscriptvalue_cast<QByteArray>(context->argument(1));
			auto arg1 = tmp_1.toStdString();
			auto tmp_2 = qscriptvalue_cast<QByteArray>(context->argument(2));
			auto arg2 = tmp_2.toStdString();
			return __e->toScriptValue(Sprite3D::createWithSkeleton(arg0, arg1, arg2));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite3D::createWithSkeleton");
	return __e->uncaughtException();
}

QScriptValue QtScriptSprite3D::getOverrideTextureExtension(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(QByteArray::fromStdString(Sprite3D::getOverrideTextureExtension()));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite3D::getOverrideTextureExtension");
	return __e->uncaughtException();
}

QScriptValue QtScriptSprite3D::setOverrideTextureExtension(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			Sprite3D::setOverrideTextureExtension(arg0);
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite3D::setOverrideTextureExtension");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptSprite3DMaterial::QtScriptSprite3DMaterial(QScriptEngine *engine, const QByteArray &className)
	: QtScriptMaterial(engine, className)
{
}

QtScriptSprite3DMaterial::QtScriptSprite3DMaterial(QScriptEngine *engine)
	: QtScriptSprite3DMaterial(engine, "Sprite3DMaterial")
{
}

void QtScriptSprite3DMaterial::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Material *>());
	auto ctor = RegisterT<Sprite3DMaterial, QtScriptSprite3DMaterial>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("createBuiltInMaterial", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite3DMaterial::createBuiltInMaterial)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithFilename", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite3DMaterial::createWithFilename)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("createWithProgramState", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite3DMaterial::createWithProgramState)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("releaseBuiltInMaterial", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite3DMaterial::releaseBuiltInMaterial)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("releaseCachedMaterial", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite3DMaterial::releaseCachedMaterial)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSprite3DMaterial::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSprite3DMaterial::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSprite3DMaterial::constructObject(QScriptContext *context, NativeObjectType &out)
{
	if (context->argumentCount() == 0)
	{
		out = new Sprite3DMaterial;
		return true;
	}

	QtScriptUtils::badArgumentsException(context,
		"cocos2d::Sprite3DMaterial constructor");
	return false;
}

int QtScriptSprite3DMaterial::getMaterialType()
{
	auto __o = this->thiz<Sprite3DMaterial *>();
	if (__o)
	{
		return int(__o->getMaterialType());
	}
	return 0;
}

void QtScriptSprite3DMaterial::setTexture(cocos2d::Texture2D* tex, int usage)
{
	auto __o = this->thiz<Sprite3DMaterial *>();
	if (__o)
	{
		__o->setTexture(tex, cocos2d::NTextureData::Usage(usage));
	}
}

QScriptValue QtScriptSprite3DMaterial::createBuiltInMaterial(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 4))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			Sprite3DMaterial::createBuiltInMaterial();
			return __e->undefinedValue();
		}
		case 1:
		{
			break;
		}
		case 2:
		{
			break;
		}
		case 3:
		{
			break;
		}
		case 4:
		{
			auto tmp_0 = qscriptvalue_cast<int>(context->argument(0));
			auto arg0 = cocos2d::Sprite3DMaterial::MaterialType(tmp_0);
			auto arg1 = qscriptvalue_cast<bool>(context->argument(1));
			auto arg2 = qscriptvalue_cast<unsigned>(context->argument(2));
			auto arg3 = qscriptvalue_cast<bool>(context->argument(3));
			return __e->toScriptValue(Sprite3DMaterial::createBuiltInMaterial(arg0, arg1, arg2, arg3));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite3DMaterial::createBuiltInMaterial");
	return __e->uncaughtException();
}

QScriptValue QtScriptSprite3DMaterial::createWithFilename(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(Sprite3DMaterial::createWithFilename(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite3DMaterial::createWithFilename");
	return __e->uncaughtException();
}

QScriptValue QtScriptSprite3DMaterial::createWithProgramState(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto arg0 = qscriptvalue_cast<cocos2d::backend::ProgramState*>(context->argument(0));
			return __e->toScriptValue(Sprite3DMaterial::createWithProgramState(arg0));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite3DMaterial::createWithProgramState");
	return __e->uncaughtException();
}

QScriptValue QtScriptSprite3DMaterial::releaseBuiltInMaterial(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			Sprite3DMaterial::releaseBuiltInMaterial();
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite3DMaterial::releaseBuiltInMaterial");
	return __e->uncaughtException();
}

QScriptValue QtScriptSprite3DMaterial::releaseCachedMaterial(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			Sprite3DMaterial::releaseCachedMaterial();
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite3DMaterial::releaseCachedMaterial");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptSprite3DMaterialCache::QtScriptSprite3DMaterialCache(QScriptEngine *engine, const QByteArray &className)
	: QtScriptTextureCacheProtocol(engine, className)
{
}

QtScriptSprite3DMaterialCache::QtScriptSprite3DMaterialCache(QScriptEngine *engine)
	: QtScriptSprite3DMaterialCache(engine, "Sprite3DMaterialCache")
{
}

void QtScriptSprite3DMaterialCache::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<TextureCacheProtocol *>());
	auto ctor = RegisterT<Sprite3DMaterialCache, QtScriptSprite3DMaterialCache>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("destroyInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite3DMaterialCache::destroyInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptSprite3DMaterialCache::getInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptSprite3DMaterialCache::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptSprite3DMaterialCache::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptSprite3DMaterialCache::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::Sprite3DMaterialCache");
	return false;
}

bool QtScriptSprite3DMaterialCache::addTexture(const QByteArray& key, cocos2d::Texture2D* tex)
{
	auto __o = this->thiz<Sprite3DMaterialCache *>();
	if (__o)
	{
		return __o->addTexture(key.toStdString(), tex);
	}
	return false;
}

void QtScriptSprite3DMaterialCache::removeAllTextures()
{
	auto __o = this->thiz<Sprite3DMaterialCache *>();
	if (__o)
	{
		__o->removeAllTextures();
	}
}

void QtScriptSprite3DMaterialCache::removeTexture(const QByteArray& key)
{
	auto __o = this->thiz<Sprite3DMaterialCache *>();
	if (__o)
	{
		__o->removeTexture(key.toStdString());
	}
}

void QtScriptSprite3DMaterialCache::removeUnusedTextures()
{
	auto __o = this->thiz<Sprite3DMaterialCache *>();
	if (__o)
	{
		__o->removeUnusedTextures();
	}
}

QScriptValue QtScriptSprite3DMaterialCache::destroyInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			Sprite3DMaterialCache::destroyInstance();
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite3DMaterialCache::destroyInstance");
	return __e->uncaughtException();
}

QScriptValue QtScriptSprite3DMaterialCache::getInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Sprite3DMaterialCache::getInstance());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Sprite3DMaterialCache::getInstance");
	return __e->uncaughtException();
}

} // end of cocos2d

namespace cocos2d {
QtScriptVertexAttribBinding::QtScriptVertexAttribBinding(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptVertexAttribBinding::QtScriptVertexAttribBinding(QScriptEngine *engine)
	: QtScriptVertexAttribBinding(engine, "VertexAttribBinding")
{
}

void QtScriptVertexAttribBinding::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<VertexAttribBinding, QtScriptVertexAttribBinding>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptVertexAttribBinding::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptVertexAttribBinding::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptVertexAttribBinding::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::VertexAttribBinding");
	return false;
}

quint32 QtScriptVertexAttribBinding::getVertexAttribsFlags()
{
	auto __o = this->thiz<VertexAttribBinding *>();
	if (__o)
	{
		return __o->getVertexAttribsFlags();
	}
	return static_cast<quint32>(0);
}

bool QtScriptVertexAttribBinding::hasAttribute(const int& key)
{
	auto __o = this->thiz<VertexAttribBinding *>();
	if (__o)
	{
		return __o->hasAttribute(cocos2d::shaderinfos::VertexKey(key));
	}
	return false;
}

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptProgramCache::QtScriptProgramCache(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptProgramCache::QtScriptProgramCache(QScriptEngine *engine)
	: QtScriptProgramCache(engine, "ProgramCache")
{
}

void QtScriptProgramCache::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<ProgramCache, QtScriptProgramCache>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("destroyInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptProgramCache::destroyInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("getInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptProgramCache::getInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptProgramCache::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptProgramCache::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptProgramCache::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::backend::ProgramCache");
	return false;
}

void QtScriptProgramCache::addCustomProgram(const QByteArray& key, cocos2d::backend::Program* program)
{
	auto __o = this->thiz<ProgramCache *>();
	if (__o)
	{
		__o->addCustomProgram(key.toStdString(), program);
	}
}

cocos2d::backend::Program* QtScriptProgramCache::getBuiltinProgram(int type)
{
	auto __o = this->thiz<ProgramCache *>();
	if (__o)
	{
		return __o->getBuiltinProgram(cocos2d::backend::ProgramType(type));
	}
	return nullptr;
}

cocos2d::backend::Program* QtScriptProgramCache::getCustomProgram(const QByteArray& key)
{
	auto __o = this->thiz<ProgramCache *>();
	if (__o)
	{
		return __o->getCustomProgram(key.toStdString());
	}
	return nullptr;
}

void QtScriptProgramCache::removeAllPrograms()
{
	auto __o = this->thiz<ProgramCache *>();
	if (__o)
	{
		__o->removeAllPrograms();
	}
}

void QtScriptProgramCache::removeProgram(cocos2d::backend::Program* program)
{
	auto __o = this->thiz<ProgramCache *>();
	if (__o)
	{
		__o->removeProgram(program);
	}
}

void QtScriptProgramCache::removeUnusedProgram()
{
	auto __o = this->thiz<ProgramCache *>();
	if (__o)
	{
		__o->removeUnusedProgram();
	}
}

QScriptValue QtScriptProgramCache::destroyInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			ProgramCache::destroyInstance();
			return __e->undefinedValue();
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::backend::ProgramCache::destroyInstance");
	return __e->uncaughtException();
}

QScriptValue QtScriptProgramCache::getInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(ProgramCache::getInstance());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::backend::ProgramCache::getInstance");
	return __e->uncaughtException();
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptDeviceInfo::QtScriptDeviceInfo(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<DeviceInfo *, false>(engine, className)
{
}

QtScriptDeviceInfo::QtScriptDeviceInfo(QScriptEngine *engine)
	: QtScriptDeviceInfo(engine, "DeviceInfo")
{
}

void QtScriptDeviceInfo::Register(const QScriptValue &targetNamespace)
{
	QScriptValue inherit;
	auto ctor = RegisterT<DeviceInfo, QtScriptDeviceInfo>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptDeviceInfo::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptDeviceInfo::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptDeviceInfo::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::backend::DeviceInfo");
	return false;
}

bool QtScriptDeviceInfo::checkForFeatureSupported(int feature)
{
	auto __o = this->thiz<DeviceInfo *>();
	if (__o)
	{
		return __o->checkForFeatureSupported(cocos2d::backend::FeatureType(feature));
	}
	return false;
}

QByteArray QtScriptDeviceInfo::getExtension()
{
	auto __o = this->thiz<DeviceInfo *>();
	if (__o)
	{
		return QByteArray(__o->getExtension());
	}
	return QByteArray();
}

int QtScriptDeviceInfo::getMaxAttributes()
{
	auto __o = this->thiz<DeviceInfo *>();
	if (__o)
	{
		return __o->getMaxAttributes();
	}
	return 0;
}

int QtScriptDeviceInfo::getMaxSamplesAllowed()
{
	auto __o = this->thiz<DeviceInfo *>();
	if (__o)
	{
		return __o->getMaxSamplesAllowed();
	}
	return 0;
}

int QtScriptDeviceInfo::getMaxTextureSize()
{
	auto __o = this->thiz<DeviceInfo *>();
	if (__o)
	{
		return __o->getMaxTextureSize();
	}
	return 0;
}

int QtScriptDeviceInfo::getMaxTextureUnits()
{
	auto __o = this->thiz<DeviceInfo *>();
	if (__o)
	{
		return __o->getMaxTextureUnits();
	}
	return 0;
}

QByteArray QtScriptDeviceInfo::getRenderer()
{
	auto __o = this->thiz<DeviceInfo *>();
	if (__o)
	{
		return QByteArray(__o->getRenderer());
	}
	return QByteArray();
}

QByteArray QtScriptDeviceInfo::getVendor()
{
	auto __o = this->thiz<DeviceInfo *>();
	if (__o)
	{
		return QByteArray(__o->getVendor());
	}
	return QByteArray();
}

QByteArray QtScriptDeviceInfo::getVersion()
{
	auto __o = this->thiz<DeviceInfo *>();
	if (__o)
	{
		return QByteArray(__o->getVersion());
	}
	return QByteArray();
}

bool QtScriptDeviceInfo::init()
{
	auto __o = this->thiz<DeviceInfo *>();
	if (__o)
	{
		return __o->init();
	}
	return false;
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptDevice::QtScriptDevice(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptDevice::QtScriptDevice(QScriptEngine *engine)
	: QtScriptDevice(engine, "Device")
{
}

void QtScriptDevice::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Device, QtScriptDevice>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("getInstance", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptDevice::getInstance)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptDevice::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptDevice::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptDevice::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::backend::Device");
	return false;
}

cocos2d::backend::DepthStencilState* QtScriptDevice::createDepthStencilState(const cocos2d::backend::DepthStencilDescriptor& descriptor)
{
	auto __o = this->thiz<Device *>();
	if (__o)
	{
		return __o->createDepthStencilState(descriptor);
	}
	return nullptr;
}

cocos2d::backend::DeviceInfo* QtScriptDevice::getDeviceInfo()
{
	auto __o = this->thiz<Device *>();
	if (__o)
	{
		return __o->getDeviceInfo();
	}
	return nullptr;
}

cocos2d::backend::Buffer* QtScriptDevice::newBuffer(unsigned size, int type, int usage)
{
	auto __o = this->thiz<Device *>();
	if (__o)
	{
		return __o->newBuffer(size, cocos2d::backend::BufferType(type), cocos2d::backend::BufferUsage(usage));
	}
	return nullptr;
}

cocos2d::backend::Program* QtScriptDevice::newProgram(const QByteArray& vertexShader, const QByteArray& fragmentShader)
{
	auto __o = this->thiz<Device *>();
	if (__o)
	{
		return __o->newProgram(vertexShader.toStdString(), fragmentShader.toStdString());
	}
	return nullptr;
}

cocos2d::backend::TextureBackend* QtScriptDevice::newTexture(const cocos2d::backend::TextureDescriptor& descriptor)
{
	auto __o = this->thiz<Device *>();
	if (__o)
	{
		return __o->newTexture(descriptor);
	}
	return nullptr;
}

QScriptValue QtScriptDevice::getInstance(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(Device::getInstance());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::backend::Device::getInstance");
	return __e->uncaughtException();
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
namespace backend {
QtScriptBuffer::QtScriptBuffer(QScriptEngine *engine, const QByteArray &className)
	: QtScriptRef(engine, className)
{
}

QtScriptBuffer::QtScriptBuffer(QScriptEngine *engine)
	: QtScriptBuffer(engine, "Buffer")
{
}

void QtScriptBuffer::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Ref *>());
	auto ctor = RegisterT<Buffer, QtScriptBuffer>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
}

int QtScriptBuffer::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptBuffer::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptBuffer::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::backend::Buffer");
	return false;
}

unsigned QtScriptBuffer::getSize()
{
	auto __o = this->thiz<Buffer *>();
	if (__o)
	{
		return unsigned(__o->getSize());
	}
	return static_cast<unsigned>(0);
}

void QtScriptBuffer::updateData(const QByteArray& arg0)
{
	auto __o = this->thiz<Buffer *>();
	if (__o)
	{
		__o->updateData(const_cast<char*>(arg0.data()), size_t(arg0.length()));
	}
}

void QtScriptBuffer::updateSubData(const QByteArray& arg0, unsigned arg1)
{
	auto __o = this->thiz<Buffer *>();
	if (__o)
	{
		__o->updateSubData(const_cast<char*>(arg0.data()), arg1, size_t(arg0.length()));
	}
}

void QtScriptBuffer::usingDefaultStoredData(bool needDefaultStoredData)
{
	auto __o = this->thiz<Buffer *>();
	if (__o)
	{
		__o->usingDefaultStoredData(needDefaultStoredData);
	}
}

} // end of backend

} // end of cocos2d

namespace cocos2d {
QtScriptBundle3D::QtScriptBundle3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptBaseClassPrototype<Bundle3D *, false>(engine, className)
{
}

QtScriptBundle3D::QtScriptBundle3D(QScriptEngine *engine)
	: QtScriptBundle3D(engine, "Bundle3D")
{
}

void QtScriptBundle3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	QScriptValue inherit;
	auto ctor = RegisterT<Bundle3D, QtScriptBundle3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("parseGLDataType", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptBundle3D::parseGLDataType)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
	ctor.setProperty("parseSamplerAddressMode", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptBundle3D::parseSamplerAddressMode)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

void QtScriptBundle3D::clear()
{
	auto __o = this->thiz<Bundle3D *>();
	if (__o)
	{
		__o->clear();
	}
}

bool QtScriptBundle3D::isLoaded()
{
	auto __o = this->thiz<Bundle3D *>();
	if (__o)
	{
		return __o->isLoaded();
	}
	return false;
}

bool QtScriptBundle3D::load(const QByteArray& path)
{
	auto __o = this->thiz<Bundle3D *>();
	if (__o)
	{
		return __o->load(path.toStdString());
	}
	return false;
}

bool QtScriptBundle3D::loadBinary(cocos2d::Data data)
{
	auto __o = this->thiz<Bundle3D *>();
	if (__o)
	{
		return __o->loadBinary(data);
	}
	return false;
}

bool QtScriptBundle3D::loadBinaryFrom(const QByteArray& path)
{
	auto __o = this->thiz<Bundle3D *>();
	if (__o)
	{
		return __o->loadBinaryFrom(path.toStdString());
	}
	return false;
}

bool QtScriptBundle3D::loadJson(QByteArray text)
{
	auto __o = this->thiz<Bundle3D *>();
	if (__o)
	{
		return __o->loadJson(text.toStdString());
	}
	return false;
}

bool QtScriptBundle3D::loadJsonFrom(const QByteArray& path)
{
	auto __o = this->thiz<Bundle3D *>();
	if (__o)
	{
		return __o->loadJsonFrom(path.toStdString());
	}
	return false;
}

QScriptValue QtScriptBundle3D::parseGLDataType(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 2, 2))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 2:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			auto arg1 = qscriptvalue_cast<int>(context->argument(1));
			return __e->toScriptValue(int(Bundle3D::parseGLDataType(arg0, arg1)));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Bundle3D::parseGLDataType");
	return __e->uncaughtException();
}

QScriptValue QtScriptBundle3D::parseSamplerAddressMode(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 1, 1))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 1:
		{
			auto tmp_0 = qscriptvalue_cast<QByteArray>(context->argument(0));
			auto arg0 = tmp_0.toStdString();
			return __e->toScriptValue(int(Bundle3D::parseSamplerAddressMode(arg0)));
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::Bundle3D::parseSamplerAddressMode");
	return __e->uncaughtException();
}

int QtScriptBundle3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptBundle3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptBundle3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	auto __e = context->engine();
	Q_UNUSED(__e);
	bool ok = false;
	switch (context->argumentCount())
	{
		case 0:
		{
			out = new Bundle3D();
			ok = true;
			break;
		}
	}

	if (!ok)
	{
		QtScriptUtils::badArgumentsException(context,
			"cocos2d::Bundle3D constructor");
	}
	return ok;
}

} // end of cocos2d

namespace cocos2d {
QtScriptDrawNode3D::QtScriptDrawNode3D(QScriptEngine *engine, const QByteArray &className)
	: QtScriptNode(engine, className)
{
}

QtScriptDrawNode3D::QtScriptDrawNode3D(QScriptEngine *engine)
	: QtScriptDrawNode3D(engine, "DrawNode3D")
{
}

void QtScriptDrawNode3D::Register(const QScriptValue &targetNamespace)
{
	auto engine = targetNamespace.engine();
	Q_ASSERT(engine);
	auto inherit = engine->defaultPrototype(qMetaTypeId<Node *>());
	auto ctor = RegisterT<DrawNode3D, QtScriptDrawNode3D>(targetNamespace, inherit);
	Q_ASSERT(ctor.isFunction());
	ctor.setProperty("create", engine->newFunction(
		static_cast<QScriptValue (*)(QScriptContext *, QScriptEngine *)>(
			&QtScriptDrawNode3D::create)),
			QScriptValue::ReadOnly | QScriptValue::Undeletable);
}

int QtScriptDrawNode3D::constructorArgumentCountMin() const
{
	return 0;
}

int QtScriptDrawNode3D::constructorArgumentCountMax() const
{
	return 0;
}

bool QtScriptDrawNode3D::constructObject(QScriptContext *context, NativeObjectType &out)
{
	Q_UNUSED(out);
	QtScriptUtils::noPublicConstructorException(context,
		"cocos2d::DrawNode3D");
	return false;
}

void QtScriptDrawNode3D::clear()
{
	auto __o = this->thiz<DrawNode3D *>();
	if (__o)
	{
		__o->clear();
	}
}

void QtScriptDrawNode3D::drawCube(const cocos2d::Vec3& from, const cocos2d::Vec3& to, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode3D *>();
	if (__o)
	{
		__o->drawCube(from, to, color);
	}
}

void QtScriptDrawNode3D::drawCubeAABB(const cocos2d::AABB& aabb, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode3D *>();
	if (__o)
	{
		__o->drawCube(aabb, color);
	}
}

void QtScriptDrawNode3D::drawCubeOBB(const cocos2d::OBB& obb, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode3D *>();
	if (__o)
	{
		__o->drawCube(obb, color);
	}
}

void QtScriptDrawNode3D::drawLine(const cocos2d::Vec3& from, const cocos2d::Vec3& to, const cocos2d::Color4B& color)
{
	auto __o = this->thiz<DrawNode3D *>();
	if (__o)
	{
		__o->drawLine(from, to, color);
	}
}

cocos2d::BlendFunc QtScriptDrawNode3D::getBlendFunc()
{
	auto __o = this->thiz<DrawNode3D *>();
	if (__o)
	{
		return __o->getBlendFunc();
	}
	return cocos2d::BlendFunc();
}

void QtScriptDrawNode3D::setBlendFunc(const cocos2d::BlendFunc& blendFunc)
{
	auto __o = this->thiz<DrawNode3D *>();
	if (__o)
	{
		__o->setBlendFunc(blendFunc);
	}
}

QScriptValue QtScriptDrawNode3D::create(QScriptContext *context, QScriptEngine* __e)
{
	if (!QtScriptUtils::checkArgumentCount(context, 0, 0))
	{
		return __e->uncaughtException();
	}

	switch (context->argumentCount())
	{
		case 0:
		{
			return __e->toScriptValue(DrawNode3D::create());
		}
	}

	QtScriptUtils::badArgumentsException(context,
			"cocos2d::DrawNode3D::create");
	return __e->uncaughtException();
}

} // end of cocos2d

void qtscript_register_all_cocos2dx(QScriptEngine* engine)
{
	QScriptValue targetNamespace;
	targetNamespace = QtScriptUtils::getNamespaceObject(engine, "cc");
	cocos2d::QtScriptAABB::Register(targetNamespace);
	cocos2d::QtScriptAccelAmplitude::Register(targetNamespace);
	cocos2d::QtScriptAccelDeccelAmplitude::Register(targetNamespace);
	cocos2d::QtScriptAction::Register(targetNamespace);
	cocos2d::QtScriptActionCamera::Register(targetNamespace);
	cocos2d::QtScriptActionEase::Register(targetNamespace);
	cocos2d::QtScriptActionFloat::Register(targetNamespace);
	cocos2d::QtScriptActionInstant::Register(targetNamespace);
	cocos2d::QtScriptActionInterval::Register(targetNamespace);
	cocos2d::QtScriptActionManager::Register(targetNamespace);
	cocos2d::QtScriptActionTween::Register(targetNamespace);
	cocos2d::QtScriptAffineTransform::Register(targetNamespace);
	cocos2d::QtScriptAmbientLight::Register(targetNamespace);
	cocos2d::QtScriptAnimate::Register(targetNamespace);
	cocos2d::QtScriptAnimate3D::Register(targetNamespace);
	cocos2d::QtScriptAnimation::Register(targetNamespace);
	cocos2d::QtScriptAnimation3D::Register(targetNamespace);
	cocos2d::QtScriptAnimation3DCache::Register(targetNamespace);
	cocos2d::QtScriptAnimationCache::Register(targetNamespace);
	cocos2d::QtScriptAnimationFrame::Register(targetNamespace);
	cocos2d::QtScriptApplication::Register(targetNamespace);
	cocos2d::QtScriptApplicationProtocol::Register(targetNamespace);
	cocos2d::QtScriptAtlasNode::Register(targetNamespace);
	cocos2d::QtScriptAttachNode::Register(targetNamespace);
	cocos2d::QtScriptBMFontConfiguration::Register(targetNamespace);
	cocos2d::QtScriptBaseLight::Register(targetNamespace);
	cocos2d::QtScriptBezierBy::Register(targetNamespace);
	cocos2d::QtScriptBezierTo::Register(targetNamespace);
	cocos2d::QtScriptBillBoard::Register(targetNamespace);
	cocos2d::QtScriptBlendFunc::Register(targetNamespace);
	cocos2d::QtScriptBlink::Register(targetNamespace);
	cocos2d::QtScriptBone3D::Register(targetNamespace);
	cocos2d::QtScriptBundle3D::Register(targetNamespace);
	cocos2d::QtScriptCallFunc::Register(targetNamespace);
	cocos2d::QtScriptCallFuncN::Register(targetNamespace);
	cocos2d::QtScriptCallbackCommand::Register(targetNamespace);
	cocos2d::QtScriptCamera::Register(targetNamespace);
	cocos2d::QtScriptCameraBackgroundBrush::Register(targetNamespace);
	cocos2d::QtScriptCameraBackgroundColorBrush::Register(targetNamespace);
	cocos2d::QtScriptCameraBackgroundDepthBrush::Register(targetNamespace);
	cocos2d::QtScriptCameraBackgroundSkyBoxBrush::Register(targetNamespace);
	cocos2d::QtScriptCaptureScreenCallbackCommand::Register(targetNamespace);
	cocos2d::QtScriptCardinalSplineBy::Register(targetNamespace);
	cocos2d::QtScriptCardinalSplineTo::Register(targetNamespace);
	cocos2d::QtScriptCatmullRomBy::Register(targetNamespace);
	cocos2d::QtScriptCatmullRomTo::Register(targetNamespace);
	cocos2d::QtScriptClippingNode::Register(targetNamespace);
	cocos2d::QtScriptClippingRectangleNode::Register(targetNamespace);
	cocos2d::QtScriptColor3B::Register(targetNamespace);
	cocos2d::QtScriptColor4B::Register(targetNamespace);
	cocos2d::QtScriptColor4F::Register(targetNamespace);
	cocos2d::QtScriptComponent::Register(targetNamespace);
	cocos2d::QtScriptConfiguration::Register(targetNamespace);
	cocos2d::QtScriptCustomCommand::Register(targetNamespace);
	cocos2d::QtScriptData::Register(targetNamespace);
	cocos2d::QtScriptDeccelAmplitude::Register(targetNamespace);
	cocos2d::QtScriptDelayTime::Register(targetNamespace);
	cocos2d::QtScriptDeviceUtils::Register(targetNamespace);
	cocos2d::QtScriptDirectionLight::Register(targetNamespace);
	cocos2d::QtScriptDirector::Register(targetNamespace);
	cocos2d::QtScriptDrawNode::Register(targetNamespace);
	cocos2d::QtScriptDrawNode3D::Register(targetNamespace);
	cocos2d::QtScriptEaseBackIn::Register(targetNamespace);
	cocos2d::QtScriptEaseBackInOut::Register(targetNamespace);
	cocos2d::QtScriptEaseBackOut::Register(targetNamespace);
	cocos2d::QtScriptEaseBezierAction::Register(targetNamespace);
	cocos2d::QtScriptEaseBounce::Register(targetNamespace);
	cocos2d::QtScriptEaseBounceIn::Register(targetNamespace);
	cocos2d::QtScriptEaseBounceInOut::Register(targetNamespace);
	cocos2d::QtScriptEaseBounceOut::Register(targetNamespace);
	cocos2d::QtScriptEaseCircleActionIn::Register(targetNamespace);
	cocos2d::QtScriptEaseCircleActionInOut::Register(targetNamespace);
	cocos2d::QtScriptEaseCircleActionOut::Register(targetNamespace);
	cocos2d::QtScriptEaseCubicActionIn::Register(targetNamespace);
	cocos2d::QtScriptEaseCubicActionInOut::Register(targetNamespace);
	cocos2d::QtScriptEaseCubicActionOut::Register(targetNamespace);
	cocos2d::QtScriptEaseElastic::Register(targetNamespace);
	cocos2d::QtScriptEaseElasticIn::Register(targetNamespace);
	cocos2d::QtScriptEaseElasticInOut::Register(targetNamespace);
	cocos2d::QtScriptEaseElasticOut::Register(targetNamespace);
	cocos2d::QtScriptEaseExponentialIn::Register(targetNamespace);
	cocos2d::QtScriptEaseExponentialInOut::Register(targetNamespace);
	cocos2d::QtScriptEaseExponentialOut::Register(targetNamespace);
	cocos2d::QtScriptEaseIn::Register(targetNamespace);
	cocos2d::QtScriptEaseInOut::Register(targetNamespace);
	cocos2d::QtScriptEaseOut::Register(targetNamespace);
	cocos2d::QtScriptEaseQuadraticActionIn::Register(targetNamespace);
	cocos2d::QtScriptEaseQuadraticActionInOut::Register(targetNamespace);
	cocos2d::QtScriptEaseQuadraticActionOut::Register(targetNamespace);
	cocos2d::QtScriptEaseQuarticActionIn::Register(targetNamespace);
	cocos2d::QtScriptEaseQuarticActionInOut::Register(targetNamespace);
	cocos2d::QtScriptEaseQuarticActionOut::Register(targetNamespace);
	cocos2d::QtScriptEaseQuinticActionIn::Register(targetNamespace);
	cocos2d::QtScriptEaseQuinticActionInOut::Register(targetNamespace);
	cocos2d::QtScriptEaseQuinticActionOut::Register(targetNamespace);
	cocos2d::QtScriptEaseRateAction::Register(targetNamespace);
	cocos2d::QtScriptEaseSineIn::Register(targetNamespace);
	cocos2d::QtScriptEaseSineInOut::Register(targetNamespace);
	cocos2d::QtScriptEaseSineOut::Register(targetNamespace);
	cocos2d::QtScriptFadeIn::Register(targetNamespace);
	cocos2d::QtScriptFadeOut::Register(targetNamespace);
	cocos2d::QtScriptFadeOutBLTiles::Register(targetNamespace);
	cocos2d::QtScriptFadeOutDownTiles::Register(targetNamespace);
	cocos2d::QtScriptFadeOutTRTiles::Register(targetNamespace);
	cocos2d::QtScriptFadeOutUpTiles::Register(targetNamespace);
	cocos2d::QtScriptFadeTo::Register(targetNamespace);
	cocos2d::QtScriptFileUtils::Register(targetNamespace);
	cocos2d::QtScriptFiniteTimeAction::Register(targetNamespace);
	cocos2d::QtScriptFlipX::Register(targetNamespace);
	cocos2d::QtScriptFlipX3D::Register(targetNamespace);
	cocos2d::QtScriptFlipY::Register(targetNamespace);
	cocos2d::QtScriptFlipY3D::Register(targetNamespace);
	cocos2d::QtScriptFollow::Register(targetNamespace);
	cocos2d::QtScriptFont::Register(targetNamespace);
	cocos2d::QtScriptFontAtlas::Register(targetNamespace);
	cocos2d::QtScriptFontDefinition::Register(targetNamespace);
	cocos2d::QtScriptFontFNT::Register(targetNamespace);
	cocos2d::QtScriptFontLetterDefinition::Register(targetNamespace);
	cocos2d::QtScriptFontShadow::Register(targetNamespace);
	cocos2d::QtScriptFontStroke::Register(targetNamespace);
	cocos2d::QtScriptFrustum::Register(targetNamespace);
	cocos2d::QtScriptGLContextAttrs::Register(targetNamespace);
	cocos2d::QtScriptGLView::Register(targetNamespace);
	cocos2d::QtScriptGrid3D::Register(targetNamespace);
	cocos2d::QtScriptGrid3DAction::Register(targetNamespace);
	cocos2d::QtScriptGridAction::Register(targetNamespace);
	cocos2d::QtScriptGridBase::Register(targetNamespace);
	cocos2d::QtScriptGroupCommand::Register(targetNamespace);
	cocos2d::QtScriptHide::Register(targetNamespace);
	cocos2d::QtScriptImage::Register(targetNamespace);
	cocos2d::QtScriptJumpBy::Register(targetNamespace);
	cocos2d::QtScriptJumpTiles3D::Register(targetNamespace);
	cocos2d::QtScriptJumpTo::Register(targetNamespace);
	cocos2d::QtScriptLabel::Register(targetNamespace);
	cocos2d::QtScriptLabelAtlas::Register(targetNamespace);
	cocos2d::QtScriptLayer::Register(targetNamespace);
	cocos2d::QtScriptLayerColor::Register(targetNamespace);
	cocos2d::QtScriptLayerGradient::Register(targetNamespace);
	cocos2d::QtScriptLayerMultiplex::Register(targetNamespace);
	cocos2d::QtScriptLayerRadialGradient::Register(targetNamespace);
	cocos2d::QtScriptLens3D::Register(targetNamespace);
	cocos2d::QtScriptLiquid::Register(targetNamespace);
	cocos2d::QtScriptMat4::Register(targetNamespace);
	cocos2d::QtScriptMaterial::Register(targetNamespace);
	cocos2d::QtScriptMathUtil::Register(targetNamespace);
	cocos2d::QtScriptMenu::Register(targetNamespace);
	cocos2d::QtScriptMenuItem::Register(targetNamespace);
	cocos2d::QtScriptMenuItemAtlasFont::Register(targetNamespace);
	cocos2d::QtScriptMenuItemFont::Register(targetNamespace);
	cocos2d::QtScriptMenuItemImage::Register(targetNamespace);
	cocos2d::QtScriptMenuItemLabel::Register(targetNamespace);
	cocos2d::QtScriptMenuItemSprite::Register(targetNamespace);
	cocos2d::QtScriptMenuItemToggle::Register(targetNamespace);
	cocos2d::QtScriptMesh::Register(targetNamespace);
	cocos2d::QtScriptMeshIndexData::Register(targetNamespace);
	cocos2d::QtScriptMeshSkin::Register(targetNamespace);
	cocos2d::QtScriptMeshVertexAttrib::Register(targetNamespace);
	cocos2d::QtScriptMeshVertexData::Register(targetNamespace);
	cocos2d::QtScriptMotionStreak::Register(targetNamespace);
	cocos2d::QtScriptMotionStreak3D::Register(targetNamespace);
	cocos2d::QtScriptMoveBy::Register(targetNamespace);
	cocos2d::QtScriptMoveTo::Register(targetNamespace);
	cocos2d::QtScriptNode::Register(targetNamespace);
	cocos2d::QtScriptNodeGrid::Register(targetNamespace);
	cocos2d::QtScriptOBB::Register(targetNamespace);
	cocos2d::QtScriptOrbitCamera::Register(targetNamespace);
	cocos2d::QtScriptPageTurn3D::Register(targetNamespace);
	cocos2d::QtScriptParallaxNode::Register(targetNamespace);
	cocos2d::QtScriptParticleBatchNode::Register(targetNamespace);
	cocos2d::QtScriptParticleExplosion::Register(targetNamespace);
	cocos2d::QtScriptParticleFire::Register(targetNamespace);
	cocos2d::QtScriptParticleFireworks::Register(targetNamespace);
	cocos2d::QtScriptParticleFlower::Register(targetNamespace);
	cocos2d::QtScriptParticleGalaxy::Register(targetNamespace);
	cocos2d::QtScriptParticleMeteor::Register(targetNamespace);
	cocos2d::QtScriptParticleRain::Register(targetNamespace);
	cocos2d::QtScriptParticleSmoke::Register(targetNamespace);
	cocos2d::QtScriptParticleSnow::Register(targetNamespace);
	cocos2d::QtScriptParticleSpiral::Register(targetNamespace);
	cocos2d::QtScriptParticleSun::Register(targetNamespace);
	cocos2d::QtScriptParticleSystem::Register(targetNamespace);
	cocos2d::QtScriptParticleSystemQuad::Register(targetNamespace);
	cocos2d::QtScriptPass::Register(targetNamespace);
	cocos2d::QtScriptPipelineDescriptor::Register(targetNamespace);
	cocos2d::QtScriptPlace::Register(targetNamespace);
	cocos2d::QtScriptPlane::Register(targetNamespace);
	cocos2d::QtScriptPointArray::Register(targetNamespace);
	cocos2d::QtScriptPointLight::Register(targetNamespace);
	cocos2d::QtScriptPointSprite::Register(targetNamespace);
	cocos2d::QtScriptProgressFromTo::Register(targetNamespace);
	cocos2d::QtScriptProgressTimer::Register(targetNamespace);
	cocos2d::QtScriptProgressTo::Register(targetNamespace);
	cocos2d::QtScriptProtectedNode::Register(targetNamespace);
	cocos2d::QtScriptQuad2::Register(targetNamespace);
	cocos2d::QtScriptQuad3::Register(targetNamespace);
	cocos2d::QtScriptQuaternion::Register(targetNamespace);
	cocos2d::QtScriptRay::Register(targetNamespace);
	cocos2d::QtScriptRect::Register(targetNamespace);
	cocos2d::QtScriptRemoveSelf::Register(targetNamespace);
	cocos2d::QtScriptRenderCommand::Register(targetNamespace);
	cocos2d::QtScriptRenderState::Register(targetNamespace);
	cocos2d::QtScriptRenderStateBlock::Register(targetNamespace);
	cocos2d::QtScriptRenderTexture::Register(targetNamespace);
	cocos2d::QtScriptRenderer::Register(targetNamespace);
	cocos2d::QtScriptRepeat::Register(targetNamespace);
	cocos2d::QtScriptRepeatForever::Register(targetNamespace);
	cocos2d::QtScriptResizeBy::Register(targetNamespace);
	cocos2d::QtScriptResizeTo::Register(targetNamespace);
	cocos2d::QtScriptReuseGrid::Register(targetNamespace);
	cocos2d::QtScriptReverseTime::Register(targetNamespace);
	cocos2d::QtScriptRipple3D::Register(targetNamespace);
	cocos2d::QtScriptRotateBy::Register(targetNamespace);
	cocos2d::QtScriptRotateTo::Register(targetNamespace);
	cocos2d::QtScriptScaleBy::Register(targetNamespace);
	cocos2d::QtScriptScaleTo::Register(targetNamespace);
	cocos2d::QtScriptScene::Register(targetNamespace);
	cocos2d::QtScriptScheduler::Register(targetNamespace);
	cocos2d::QtScriptScissorRect::Register(targetNamespace);
	cocos2d::QtScriptSequence::Register(targetNamespace);
	cocos2d::QtScriptShaky3D::Register(targetNamespace);
	cocos2d::QtScriptShakyTiles3D::Register(targetNamespace);
	cocos2d::QtScriptShatteredTiles3D::Register(targetNamespace);
	cocos2d::QtScriptShow::Register(targetNamespace);
	cocos2d::QtScriptShuffleTiles::Register(targetNamespace);
	cocos2d::QtScriptSize::Register(targetNamespace);
	cocos2d::QtScriptSkeleton3D::Register(targetNamespace);
	cocos2d::QtScriptSkewBy::Register(targetNamespace);
	cocos2d::QtScriptSkewTo::Register(targetNamespace);
	cocos2d::QtScriptSkybox::Register(targetNamespace);
	cocos2d::QtScriptSpawn::Register(targetNamespace);
	cocos2d::QtScriptSpeed::Register(targetNamespace);
	cocos2d::QtScriptSphericalRadius::Register(targetNamespace);
	cocos2d::QtScriptSplitCols::Register(targetNamespace);
	cocos2d::QtScriptSplitRows::Register(targetNamespace);
	cocos2d::QtScriptSpotLight::Register(targetNamespace);
	cocos2d::QtScriptSprite::Register(targetNamespace);
	cocos2d::QtScriptSprite3D::Register(targetNamespace);
	cocos2d::QtScriptSprite3DCache::Register(targetNamespace);
	cocos2d::QtScriptSprite3DData::Register(targetNamespace);
	cocos2d::QtScriptSprite3DMaterial::Register(targetNamespace);
	cocos2d::QtScriptSprite3DMaterialCache::Register(targetNamespace);
	cocos2d::QtScriptSpriteBatchNode::Register(targetNamespace);
	cocos2d::QtScriptSpriteFrame::Register(targetNamespace);
	cocos2d::QtScriptSpriteFrameCache::Register(targetNamespace);
	cocos2d::QtScriptStopGrid::Register(targetNamespace);
	cocos2d::QtScriptT2F_Quad::Register(targetNamespace);
	cocos2d::QtScriptTargetedAction::Register(targetNamespace);
	cocos2d::QtScriptTechnique::Register(targetNamespace);
	cocos2d::QtScriptTex2F::Register(targetNamespace);
	cocos2d::QtScriptTextPixelsInfo::Register(targetNamespace);
	cocos2d::QtScriptTexture2D::Register(targetNamespace);
	cocos2d::QtScriptTextureAtlas::Register(targetNamespace);
	cocos2d::QtScriptTextureCache::Register(targetNamespace);
	cocos2d::QtScriptTextureCacheProtocol::Register(targetNamespace);
	cocos2d::QtScriptTextureCube::Register(targetNamespace);
	cocos2d::QtScriptTileMapAtlas::Register(targetNamespace);
	cocos2d::QtScriptTiledGrid3D::Register(targetNamespace);
	cocos2d::QtScriptTiledGrid3DAction::Register(targetNamespace);
	cocos2d::QtScriptTintBy::Register(targetNamespace);
	cocos2d::QtScriptTintTo::Register(targetNamespace);
	cocos2d::QtScriptToggleVisibility::Register(targetNamespace);
	cocos2d::QtScriptTouch::Register(targetNamespace);
	cocos2d::QtScriptTurnOffTiles::Register(targetNamespace);
	cocos2d::QtScriptTwirl::Register(targetNamespace);
	cocos2d::QtScriptV2F_C4B_PF::Register(targetNamespace);
	cocos2d::QtScriptV2F_C4B_T2F::Register(targetNamespace);
	cocos2d::QtScriptV2F_C4B_T2F_Quad::Register(targetNamespace);
	cocos2d::QtScriptV2F_C4B_T2F_Triangle::Register(targetNamespace);
	cocos2d::QtScriptV2F_C4F_T2F::Register(targetNamespace);
	cocos2d::QtScriptV2F_C4F_T2F_Quad::Register(targetNamespace);
	cocos2d::QtScriptV3F_C4B_T2F::Register(targetNamespace);
	cocos2d::QtScriptV3F_C4B_T2F_Quad::Register(targetNamespace);
	cocos2d::QtScriptV3F_C4F::Register(targetNamespace);
	cocos2d::QtScriptV3F_T2F::Register(targetNamespace);
	cocos2d::QtScriptV3F_T2F_Quad::Register(targetNamespace);
	cocos2d::QtScriptVec2::Register(targetNamespace);
	cocos2d::QtScriptVec3::Register(targetNamespace);
	cocos2d::QtScriptVec4::Register(targetNamespace);
	cocos2d::QtScriptVertexAttribBinding::Register(targetNamespace);
	cocos2d::QtScriptViewport::Register(targetNamespace);
	cocos2d::QtScriptWaves::Register(targetNamespace);
	cocos2d::QtScriptWaves3D::Register(targetNamespace);
	cocos2d::QtScriptWavesTiles3D::Register(targetNamespace);
	cocos2d::QtScriptZipFile::Register(targetNamespace);
	cocos2d::QtScriptBezierConfig::Register(targetNamespace);
	cocos2d::QtScriptTTFConfig::Register(targetNamespace);
	cocos2d::backend::QtScriptAttributeBindInfo::Register(targetNamespace);
	cocos2d::backend::QtScriptBlendDescriptor::Register(targetNamespace);
	cocos2d::backend::QtScriptBuffer::Register(targetNamespace);
	cocos2d::backend::QtScriptDepthStencilDescriptor::Register(targetNamespace);
	cocos2d::backend::QtScriptDepthStencilState::Register(targetNamespace);
	cocos2d::backend::QtScriptDevice::Register(targetNamespace);
	cocos2d::backend::QtScriptDeviceInfo::Register(targetNamespace);
	cocos2d::backend::QtScriptProgram::Register(targetNamespace);
	cocos2d::backend::QtScriptProgramCache::Register(targetNamespace);
	cocos2d::backend::QtScriptProgramState::Register(targetNamespace);
	cocos2d::backend::QtScriptSamplerDescriptor::Register(targetNamespace);
	cocos2d::backend::QtScriptShaderCache::Register(targetNamespace);
	cocos2d::backend::QtScriptShaderModule::Register(targetNamespace);
	cocos2d::backend::QtScriptStencilDescriptor::Register(targetNamespace);
	cocos2d::backend::QtScriptTexture2DBackend::Register(targetNamespace);
	cocos2d::backend::QtScriptTextureBackend::Register(targetNamespace);
	cocos2d::backend::QtScriptTextureCubemapBackend::Register(targetNamespace);
	cocos2d::backend::QtScriptTextureDescriptor::Register(targetNamespace);
	cocos2d::backend::QtScriptUniformInfo::Register(targetNamespace);
	cocos2d::backend::QtScriptUniformLocation::Register(targetNamespace);
}
